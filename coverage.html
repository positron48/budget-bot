
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">budget-bot/cmd/bot/main.go (0.0%)</option>
				
				<option value="file1">budget-bot/internal/bot/auth_manager.go (0.0%)</option>
				
				<option value="file2">budget-bot/internal/bot/category_matcher.go (93.3%)</option>
				
				<option value="file3">budget-bot/internal/bot/category_name_mapper.go (87.0%)</option>
				
				<option value="file4">budget-bot/internal/bot/currency_converter.go (83.9%)</option>
				
				<option value="file5">budget-bot/internal/bot/currency_parser.go (94.4%)</option>
				
				<option value="file6">budget-bot/internal/bot/error_utils.go (64.0%)</option>
				
				<option value="file7">budget-bot/internal/bot/handler.go (58.6%)</option>
				
				<option value="file8">budget-bot/internal/bot/oauth_manager.go (51.6%)</option>
				
				<option value="file9">budget-bot/internal/bot/parser.go (90.8%)</option>
				
				<option value="file10">budget-bot/internal/bot/state_manager.go (100.0%)</option>
				
				<option value="file11">budget-bot/internal/bot/test_helpers.go (25.0%)</option>
				
				<option value="file12">budget-bot/internal/bot/ui/keyboards.go (100.0%)</option>
				
				<option value="file13">budget-bot/internal/bot/ui/message_formatter.go (90.0%)</option>
				
				<option value="file14">budget-bot/internal/domain/money.go (0.0%)</option>
				
				<option value="file15">budget-bot/internal/grpc/auth_client.go (86.2%)</option>
				
				<option value="file16">budget-bot/internal/grpc/category_client.go (76.6%)</option>
				
				<option value="file17">budget-bot/internal/grpc/client.go (80.0%)</option>
				
				<option value="file18">budget-bot/internal/grpc/fx_client.go (87.5%)</option>
				
				<option value="file19">budget-bot/internal/grpc/oauth_client.go (69.2%)</option>
				
				<option value="file20">budget-bot/internal/grpc/report_client.go (67.9%)</option>
				
				<option value="file21">budget-bot/internal/grpc/tenant_client.go (82.4%)</option>
				
				<option value="file22">budget-bot/internal/grpc/transaction_client.go (84.3%)</option>
				
				<option value="file23">budget-bot/internal/grpc/wire.go (0.0%)</option>
				
				<option value="file24">budget-bot/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file25">budget-bot/internal/pb/budget/v1/auth.pb.go (0.0%)</option>
				
				<option value="file26">budget-bot/internal/pb/budget/v1/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file27">budget-bot/internal/pb/budget/v1/category.pb.go (0.0%)</option>
				
				<option value="file28">budget-bot/internal/pb/budget/v1/category_grpc.pb.go (0.0%)</option>
				
				<option value="file29">budget-bot/internal/pb/budget/v1/common.pb.go (0.0%)</option>
				
				<option value="file30">budget-bot/internal/pb/budget/v1/fx.pb.go (0.0%)</option>
				
				<option value="file31">budget-bot/internal/pb/budget/v1/fx_grpc.pb.go (0.0%)</option>
				
				<option value="file32">budget-bot/internal/pb/budget/v1/import.pb.go (0.0%)</option>
				
				<option value="file33">budget-bot/internal/pb/budget/v1/import_grpc.pb.go (0.0%)</option>
				
				<option value="file34">budget-bot/internal/pb/budget/v1/oauth.pb.go (0.0%)</option>
				
				<option value="file35">budget-bot/internal/pb/budget/v1/oauth_grpc.pb.go (0.0%)</option>
				
				<option value="file36">budget-bot/internal/pb/budget/v1/report.pb.go (0.0%)</option>
				
				<option value="file37">budget-bot/internal/pb/budget/v1/report_grpc.pb.go (0.0%)</option>
				
				<option value="file38">budget-bot/internal/pb/budget/v1/tenant.pb.go (0.0%)</option>
				
				<option value="file39">budget-bot/internal/pb/budget/v1/tenant_grpc.pb.go (0.0%)</option>
				
				<option value="file40">budget-bot/internal/pb/budget/v1/transaction.pb.go (0.0%)</option>
				
				<option value="file41">budget-bot/internal/pb/budget/v1/transaction_grpc.pb.go (0.0%)</option>
				
				<option value="file42">budget-bot/internal/pb/budget/v1/user.pb.go (0.0%)</option>
				
				<option value="file43">budget-bot/internal/pb/budget/v1/user_grpc.pb.go (0.0%)</option>
				
				<option value="file44">budget-bot/internal/pkg/config/config.go (95.5%)</option>
				
				<option value="file45">budget-bot/internal/pkg/db/db.go (55.0%)</option>
				
				<option value="file46">budget-bot/internal/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file47">budget-bot/internal/repository/category_mapping_repo.go (90.9%)</option>
				
				<option value="file48">budget-bot/internal/repository/dialog_state_repo.go (100.0%)</option>
				
				<option value="file49">budget-bot/internal/repository/draft_repo.go (100.0%)</option>
				
				<option value="file50">budget-bot/internal/repository/preferences_repo.go (91.7%)</option>
				
				<option value="file51">budget-bot/internal/repository/session_repo.go (100.0%)</option>
				
				<option value="file52">budget-bot/internal/testutil/sqlite.go (0.0%)</option>
				
				<option value="file53">budget-bot/internal/testutil/telegram.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Command budget-bot runs the Telegram bot.
package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"

        botpkg "budget-bot/internal/bot"
        "budget-bot/internal/pkg/config"
        "budget-bot/internal/pkg/db"
        botlogger "budget-bot/internal/pkg/logger"

        "budget-bot/internal/repository"
        grpcwire "budget-bot/internal/grpc"
        "budget-bot/internal/metrics"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
        "go.uber.org/zap"
        "net/url"
)

func main() <span class="cov0" title="0">{
        // Load config
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("config error: %w", err))</span>
        }

        // Logger
        <span class="cov0" title="0">log, err := botlogger.New(cfg.Logging.Level)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("logger init error: %w", err))</span>
        }
        <span class="cov0" title="0">defer log.Sync() //nolint:errcheck

        log.Info("starting bot")

        // Telegram bot init with optional BaseURL for emulator
        var bot *tgbotapi.BotAPI
        if cfg.Telegram.APIBaseURL != "" </span><span class="cov0" title="0">{
                endpoint := normalizeAPIEndpoint(cfg.Telegram.APIBaseURL)
                bot, err = tgbotapi.NewBotAPIWithAPIEndpoint(cfg.Telegram.Token, endpoint)
        }</span> else<span class="cov0" title="0"> {
                bot, err = tgbotapi.NewBotAPI(cfg.Telegram.Token)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to init bot", zap.Error(err))
        }</span>
        <span class="cov0" title="0">bot.Debug = cfg.Telegram.Debug

        log.Info("authorized on account", zap.String("username", bot.Self.UserName))

        // Ensure data dir exists and DB is migrated
        if err := os.MkdirAll("./data", 0o755); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to create data dir", zap.Error(err))
        }</span>
        <span class="cov0" title="0">dbConn, err := db.OpenAndMigrate(cfg.Database.DSN, "./migrations", log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("database init failed", zap.Error(err))
        }</span>

        // Graceful shutdown
        <span class="cov0" title="0">ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer cancel()

        // Handler wiring
        stateRepo := repository.NewSQLiteDialogStateRepository(dbConn)
        sessionRepo := repository.NewSQLiteSessionRepository(dbConn)
        mappingRepo := repository.NewSQLiteCategoryMappingRepository(dbConn)
        prefsRepo := repository.NewSQLitePreferencesRepository(dbConn)
        draftRepo := repository.NewSQLiteDraftRepository(dbConn)
        
        // Wire OAuth clients
        catClient, reportClient, tenantClient, txClient, oauthClient := grpcwire.WireClients(log)
        
        // Create OAuth manager
        oauthManager := botpkg.NewOAuthManager(oauthClient, sessionRepo, log, cfg.OAuth.WebBaseURL)
        
        h := botpkg.NewHandler(bot, stateRepo, oauthManager, mappingRepo, catClient, log).
                WithPreferences(prefsRepo).
                WithDrafts(draftRepo).
                WithCategoryClient(catClient).
                WithReportClient(reportClient).
                WithTransactionClient(txClient).
                WithTenantClient(tenantClient)

        // Webhook mode vs long polling
        if cfg.Telegram.WebhookEnable </span><span class="cov0" title="0">{
                // Determine webhook URL
                var webhookURL string
                if cfg.Telegram.WebhookURL != "" </span><span class="cov0" title="0">{
                        // Use explicit webhook URL if provided
                        webhookURL = cfg.Telegram.WebhookURL
                }</span> else<span class="cov0" title="0"> if cfg.Telegram.WebhookDomain != "" </span><span class="cov0" title="0">{
                        // Build webhook URL from domain and path
                        webhookURL = strings.TrimSuffix(cfg.Telegram.WebhookDomain, "/") + cfg.Telegram.WebhookPath
                }</span> else<span class="cov0" title="0"> {
                        log.Fatal("webhook enabled but neither webhook_url nor webhook_domain is configured")
                }</span>
                
                <span class="cov0" title="0">log.Info("setting webhook", zap.String("url", webhookURL))
                
                // Set webhook using the configured API base URL
                whCfg, _ := tgbotapi.NewWebhook(webhookURL)
                if _, err := bot.Request(whCfg); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to set webhook", zap.Error(err))
                }</span>
                
                <span class="cov0" title="0">log.Info("webhook set successfully")
                
                // Serve webhook on configured path
                http.HandleFunc(cfg.Telegram.WebhookPath, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        update, err := bot.HandleUpdate(r)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warn("webhook handle error", zap.Error(err))
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">if update != nil </span><span class="cov0" title="0">{
                                go h.HandleUpdate(context.Background(), *update)
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
                })
                // Health and metrics on same server
                <span class="cov0" title="0">http.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{ _, _ = w.Write([]byte("OK")) }</span>)
                <span class="cov0" title="0">if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                        http.Handle("/metrics", metrics.Handler())
                }</span>
                
                <span class="cov0" title="0">log.Info("starting HTTP server for webhook", zap.String("address", cfg.Server.Address))
                go func() </span><span class="cov0" title="0">{ _ = http.ListenAndServe(cfg.Server.Address, nil) }</span>()
                
                // Wait for shutdown signal
                <span class="cov0" title="0">&lt;-ctx.Done()
                
                // Clean up webhook on shutdown using the configured API base URL
                log.Info("cleaning up webhook")
                if _, err := bot.Request(tgbotapi.DeleteWebhookConfig{}); err != nil </span><span class="cov0" title="0">{
                        log.Warn("failed to delete webhook", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        log.Info("webhook deleted successfully")
                }</span>
                
                <span class="cov0" title="0">log.Info("shutting down")
                return</span>
        }

        // Health endpoint and metrics (optional) for long polling
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                http.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{ _, _ = w.Write([]byte("OK")) }</span>)
                <span class="cov0" title="0">if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                        http.Handle("/metrics", metrics.Handler())
                }</span>
                <span class="cov0" title="0">_ = http.ListenAndServe(cfg.Server.Address, nil)</span>
        }()

        // Long polling loop
        <span class="cov0" title="0">u := tgbotapi.NewUpdate(0)
        u.Timeout = cfg.Telegram.UpdatesTimeout
        updates := bot.GetUpdatesChan(u)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("shutting down")
                        return</span>
                case update := &lt;-updates:<span class="cov0" title="0">
                        h.HandleUpdate(ctx, update)</span>
                }
        }

        // end of main
}

// normalizeAPIEndpoint ensures endpoint string is a valid format expected by tgbotapi: it must contain exactly two %s placeholders for token and method.
func normalizeAPIEndpoint(base string) string <span class="cov0" title="0">{
        s := strings.TrimSpace(base)
        // Fix encoded placeholders
        s = strings.ReplaceAll(s, "%25s", "%s")
        // If it already has exactly two placeholders, keep as-is
        if strings.Count(s, "%s") == 2 </span><span class="cov0" title="0">{
                return s
        }</span>
        // If the placeholder count is wrong or missing, rebuild using parsed URL
        <span class="cov0" title="0">if u, err := url.Parse(s); err == nil &amp;&amp; u.Scheme != "" &amp;&amp; u.Host != "" </span><span class="cov0" title="0">{
                path := strings.TrimSuffix(u.Path, "/")
                return u.Scheme + "://" + u.Host + path + "/bot%s/%s"
        }</span>
        // Fallback: just append the correct suffix
        <span class="cov0" title="0">if strings.HasSuffix(s, "/") </span><span class="cov0" title="0">{
                return s + "bot%s/%s"
        }</span>
        <span class="cov0" title="0">return s + "/bot%s/%s"</span>
}




</pre>
		
		<pre class="file" id="file1" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"
        "time"

        "budget-bot/internal/repository"
        "go.uber.org/zap"
)

// AuthClient defines auth server operations used by the bot.
type AuthClient interface {
        Register(ctx context.Context, email, password, name string) (userID string, tenantID string, accessToken string, refreshToken string, accessExp time.Time, refreshExp time.Time, err error)
        Login(ctx context.Context, email, password string) (userID string, tenantID string, accessToken string, refreshToken string, accessExp time.Time, refreshExp time.Time, err error)
        RefreshToken(ctx context.Context, refreshToken string) (accessToken string, refreshTokenNew string, accessExp time.Time, refreshExp time.Time, err error)
}

// AuthManager coordinates auth flows and session persistence.
type AuthManager struct {
        authClient  AuthClient
        sessionRepo repository.SessionRepository
        logger     *zap.Logger
}

// NewAuthManager constructs an AuthManager.
func NewAuthManager(authClient AuthClient, sessionRepo repository.SessionRepository, logger *zap.Logger) *AuthManager <span class="cov0" title="0">{
        return &amp;AuthManager{authClient: authClient, sessionRepo: sessionRepo, logger: logger}
}</span>

// Register registers and stores session tokens for a user.
func (am *AuthManager) Register(ctx context.Context, telegramID int64, email, password, name string) error <span class="cov0" title="0">{
        userID, tenantID, accessToken, refreshToken, accessExp, refreshExp, err := am.authClient.Register(ctx, email, password, name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return am.sessionRepo.SaveSession(ctx, &amp;repository.UserSession{
                TelegramID:            telegramID,
                UserID:                userID,
                TenantID:              tenantID,
                AccessToken:           accessToken,
                RefreshToken:          refreshToken,
                AccessTokenExpiresAt:  accessExp,
                RefreshTokenExpiresAt: refreshExp,
        })</span>
}

// Login authenticates and stores session tokens for a user.
func (am *AuthManager) Login(ctx context.Context, telegramID int64, email, password string) error <span class="cov0" title="0">{
        userID, tenantID, accessToken, refreshToken, accessExp, refreshExp, err := am.authClient.Login(ctx, email, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return am.sessionRepo.SaveSession(ctx, &amp;repository.UserSession{
                TelegramID:            telegramID,
                UserID:                userID,
                TenantID:              tenantID,
                AccessToken:           accessToken,
                RefreshToken:          refreshToken,
                AccessTokenExpiresAt:  accessExp,
                RefreshTokenExpiresAt: refreshExp,
        })</span>
}

// Logout removes stored session for a user.
func (am *AuthManager) Logout(ctx context.Context, telegramID int64) error <span class="cov0" title="0">{
        return am.sessionRepo.DeleteSession(ctx, telegramID)
}</span>

// GetSession returns current session for a user.
func (am *AuthManager) GetSession(ctx context.Context, telegramID int64) (*repository.UserSession, error) <span class="cov0" title="0">{
        session, err := am.sessionRepo.GetSession(ctx, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Проверяем, не истек ли access token
        <span class="cov0" title="0">if time.Now().After(session.AccessTokenExpiresAt) </span><span class="cov0" title="0">{
                am.logger.Debug("Access token expired, attempting refresh", 
                        zap.Int64("telegramID", telegramID),
                        zap.Time("expiresAt", session.AccessTokenExpiresAt))
                
                // Пытаемся обновить токены
                err := am.RefreshTokens(ctx, telegramID)
                if err != nil </span><span class="cov0" title="0">{
                        am.logger.Error("Failed to refresh tokens", 
                                zap.Int64("telegramID", telegramID),
                                zap.Error(err))
                        return nil, err
                }</span>
                
                // Получаем обновленную сессию
                <span class="cov0" title="0">session, err = am.sessionRepo.GetSession(ctx, telegramID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                <span class="cov0" title="0">am.logger.Debug("Tokens refreshed successfully", 
                        zap.Int64("telegramID", telegramID),
                        zap.Time("newExpiresAt", session.AccessTokenExpiresAt))</span>
        }
        
        <span class="cov0" title="0">return session, nil</span>
}

// RefreshTokens refreshes auth tokens and stores them.
func (am *AuthManager) RefreshTokens(ctx context.Context, telegramID int64) error <span class="cov0" title="0">{
        s, err := am.sessionRepo.GetSession(ctx, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">access, refresh, accessExp, refreshExp, err := am.authClient.RefreshToken(ctx, s.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return am.sessionRepo.UpdateTokens(ctx, telegramID, &amp;repository.TokenPair{
                AccessToken:           access,
                RefreshToken:          refresh,
                AccessTokenExpiresAt:  accessExp,
                RefreshTokenExpiresAt: refreshExp,
        })</span>
}


</pre>
		
		<pre class="file" id="file2" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
    "context"
    "strings"

    "budget-bot/internal/repository"
)

// CategoryMatcher matches free text to categories using mappings.
type CategoryMatcher struct {
    mappingRepo repository.CategoryMappingRepository
}

// NewCategoryMatcher constructs a CategoryMatcher.
func NewCategoryMatcher(repo repository.CategoryMappingRepository) *CategoryMatcher <span class="cov8" title="1">{
    return &amp;CategoryMatcher{mappingRepo: repo}
}</span>

// FindCategory tries to find a category by exact or partial keyword match.
func (cm *CategoryMatcher) FindCategory(ctx context.Context, tenantID string, description string) (*repository.CategoryMapping, error) <span class="cov8" title="1">{
    // exact match first
    words := strings.Fields(strings.ToLower(description))
    for _, w := range words </span><span class="cov8" title="1">{
        if m, err := cm.mappingRepo.FindMapping(ctx, tenantID, w); err == nil &amp;&amp; m != nil </span><span class="cov8" title="1">{
            return m, nil
        }</span>
    }
    // partial match over all mappings ordered by priority
    <span class="cov8" title="1">all, err := cm.mappingRepo.ListMappings(ctx, tenantID)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov8" title="1">low := strings.ToLower(description)
    var best *repository.CategoryMapping
    for _, m := range all </span><span class="cov8" title="1">{
        if strings.Contains(low, strings.ToLower(m.Keyword)) </span><span class="cov8" title="1">{
            if best == nil || m.Priority &gt; best.Priority </span><span class="cov8" title="1">{
                best = m
            }</span>
        }
    }
    <span class="cov8" title="1">return best, nil</span>
}


</pre>
		
		<pre class="file" id="file3" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"
        "strings"

        "budget-bot/internal/domain"
        grpcclient "budget-bot/internal/grpc"
)

// CategoryNameMapper maps category names to IDs and vice versa.
type CategoryNameMapper struct {
        categoryClient grpcclient.CategoryClient
}

// NewCategoryNameMapper constructs a CategoryNameMapper.
func NewCategoryNameMapper(categoryClient grpcclient.CategoryClient) *CategoryNameMapper <span class="cov8" title="1">{
        return &amp;CategoryNameMapper{categoryClient: categoryClient}
}</span>

// GetCategoryIDByName finds category ID by name (case-insensitive).
func (cnm *CategoryNameMapper) GetCategoryIDByName(ctx context.Context, tenantID, accessToken, name string, transactionType domain.TransactionType, locale string) (string, error) <span class="cov8" title="1">{
        categories, err := cnm.categoryClient.ListCategories(ctx, tenantID, accessToken, transactionType, locale)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">normalizedName := strings.ToLower(strings.TrimSpace(name))
        for _, category := range categories </span><span class="cov8" title="1">{
                if strings.ToLower(strings.TrimSpace(category.Name)) == normalizedName </span><span class="cov8" title="1">{
                        return category.ID, nil
                }</span>
        }

        <span class="cov8" title="1">return "", nil</span> // Not found
}

// GetCategoryNameByID finds category name by ID.
func (cnm *CategoryNameMapper) GetCategoryNameByID(ctx context.Context, tenantID, accessToken, categoryID string, transactionType domain.TransactionType, locale string) (string, error) <span class="cov8" title="1">{
        categories, err := cnm.categoryClient.ListCategories(ctx, tenantID, accessToken, transactionType, locale)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, category := range categories </span><span class="cov8" title="1">{
                if category.ID == categoryID </span><span class="cov8" title="1">{
                        return category.Name, nil
                }</span>
        }

        <span class="cov8" title="1">return "", nil</span> // Not found
}

// GetCategoryByID finds full category by ID.
func (cnm *CategoryNameMapper) GetCategoryByID(ctx context.Context, tenantID, accessToken, categoryID string, transactionType domain.TransactionType, locale string) (*domain.Category, error) <span class="cov8" title="1">{
        categories, err := cnm.categoryClient.ListCategories(ctx, tenantID, accessToken, transactionType, locale)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, category := range categories </span><span class="cov8" title="1">{
                if category.ID == categoryID </span><span class="cov8" title="1">{
                        return category, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span> // Not found
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"
        "sync"
        "time"

        grpcclient "budget-bot/internal/grpc"
        "go.uber.org/zap"
)

// CurrencyConverter converts between currencies using FxClient with simple in-memory caching.
type CurrencyConverter struct {
        fxClient grpcclient.FxClient
        logger  *zap.Logger
        cache   *fxCache
}

type fxCache struct {
        mu    sync.RWMutex
        data  map[string]cachedRate // key: from|to|YYYY-MM-DD
}

type cachedRate struct {
        rate     float64
        storedAt time.Time
}

// NewCurrencyConverter constructs CurrencyConverter.
func NewCurrencyConverter(fx grpcclient.FxClient, logger *zap.Logger) *CurrencyConverter <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = zap.NewNop()
        }</span>
        <span class="cov8" title="1">return &amp;CurrencyConverter{fxClient: fx, logger: logger, cache: &amp;fxCache{data: make(map[string]cachedRate)}}</span>
}

// GetExchangeRate fetches or caches FX rate.
func (cc *CurrencyConverter) GetExchangeRate(ctx context.Context, fromCurrency, toCurrency string, date time.Time, accessToken string) (float64, error) <span class="cov8" title="1">{
        if fromCurrency == toCurrency </span><span class="cov8" title="1">{
                return 1.0, nil
        }</span>
        <span class="cov8" title="1">key := cc.cacheKey(fromCurrency, toCurrency, date)
        if r, ok := cc.cacheGet(key); ok </span><span class="cov8" title="1">{
                return r, nil
        }</span>
        <span class="cov8" title="1">rate, err := cc.fxClient.GetRate(ctx, fromCurrency, toCurrency, date, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                cc.logger.Warn("fx get rate failed", zap.Error(err), zap.String("from", fromCurrency), zap.String("to", toCurrency))
                return 0, err
        }</span>
        <span class="cov8" title="1">cc.cacheSet(key, rate)
        return rate, nil</span>
}

// ConvertToBaseCurrency converts amount from fromCurrency to toCurrency for a given date.
func (cc *CurrencyConverter) ConvertToBaseCurrency(ctx context.Context, amountMinor int64, fromCurrency, toCurrency string, date time.Time, accessToken string) (int64, error) <span class="cov8" title="1">{
        rate, err := cc.GetExchangeRate(ctx, fromCurrency, toCurrency, date, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        // multiply and round to nearest minor unit; use banker's rounding if needed later
        <span class="cov8" title="1">converted := float64(amountMinor) * rate
        return int64(converted + 0.5), nil</span>
}

func (cc *CurrencyConverter) cacheKey(from, to string, date time.Time) string <span class="cov8" title="1">{
        return from + "|" + to + "|" + date.Format("2006-01-02")
}</span>

func (cc *CurrencyConverter) cacheGet(key string) (float64, bool) <span class="cov8" title="1">{
        cc.cache.mu.RLock()
        defer cc.cache.mu.RUnlock()
        val, ok := cc.cache.data[key]
        if !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        // cache TTL 24h per date key, but since key contains date, we can keep infinitely; still guard staleness
        <span class="cov8" title="1">if time.Since(val.storedAt) &gt; 24*time.Hour </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">return val.rate, true</span>
}

func (cc *CurrencyConverter) cacheSet(key string, rate float64) <span class="cov8" title="1">{
        cc.cache.mu.Lock()
        cc.cache.data[key] = cachedRate{rate: rate, storedAt: time.Now()}
        cc.cache.mu.Unlock()
}</span>


</pre>
		
		<pre class="file" id="file5" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
    "regexp"
    "strings"
)

// CurrencyParser validates and normalizes currency codes.
type CurrencyParser struct {
    symbolToCode map[string]string
    codeToSymbol map[string]string
}

// NewCurrencyParser constructs a CurrencyParser.
func NewCurrencyParser() *CurrencyParser <span class="cov8" title="1">{
    s2c := map[string]string{
        "₽": "RUB",
        "$": "USD",
        "€": "EUR",
        "£": "GBP",
        "¥": "JPY",
    }
    c2s := map[string]string{
        "RUB": "₽",
        "USD": "$",
        "EUR": "€",
        "GBP": "£",
        "JPY": "¥",
    }
    return &amp;CurrencyParser{symbolToCode: s2c, codeToSymbol: c2s}
}</span>

var currencyCodeRe = regexp.MustCompile(`\b(RUB|USD|EUR|GBP|JPY)\b`)

// ParseCurrency returns ISO code and the matched token, and the cleaned text without that token.
func (cp *CurrencyParser) ParseCurrency(text string) (code string, matched string, cleaned string) <span class="cov8" title="1">{
    t := text
    // Look for symbols anywhere
    for sym, c := range cp.symbolToCode </span><span class="cov8" title="1">{
        if strings.Contains(t, sym) </span><span class="cov8" title="1">{
            cleaned = strings.ReplaceAll(t, sym, "")
            return c, sym, strings.TrimSpace(cleaned)
        }</span>
    }
    // Look for 3-letter codes (case-insensitive)
    <span class="cov8" title="1">upper := strings.ToUpper(t)
    if loc := currencyCodeRe.FindStringIndex(upper); loc != nil </span><span class="cov8" title="1">{
        matched = upper[loc[0]:loc[1]]
        cleaned = strings.TrimSpace(t[:loc[0]] + t[loc[1]:])
        return matched, matched, cleaned
    }</span>
    <span class="cov8" title="1">return "", "", t</span>
}

// ValidateCurrency checks if code looks like an ISO 4217 currency.
func (cp *CurrencyParser) ValidateCurrency(code string) bool <span class="cov8" title="1">{
    if code == "" </span><span class="cov0" title="0">{
        return false
    }</span>
    <span class="cov8" title="1">_, ok := cp.codeToSymbol[strings.ToUpper(code)]
    return ok</span>
}


</pre>
		
		<pre class="file" id="file6" style="display: none">package bot

import (
        "strings"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// GetUserFriendlyError возвращает понятное пользователю сообщение об ошибке
func GetUserFriendlyError(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Проверяем, является ли это gRPC ошибкой
        <span class="cov8" title="1">if st, ok := status.FromError(err); ok </span><span class="cov8" title="1">{
                switch st.Code() </span>{
                case codes.InvalidArgument:<span class="cov8" title="1">
                        // Извлекаем сообщение из деталей ошибки
                        msg := st.Message()
                        if strings.Contains(msg, "invalid email format") </span><span class="cov8" title="1">{
                                return "Неверный формат email. Пожалуйста, введите корректный email адрес."
                        }</span>
                        <span class="cov8" title="1">if strings.Contains(msg, "invalid verification code") </span><span class="cov8" title="1">{
                                return "Неверный код подтверждения. Пожалуйста, проверьте код и попробуйте снова."
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(msg, "email") </span><span class="cov0" title="0">{
                                return "Ошибка с email: " + msg
                        }</span>
                        <span class="cov0" title="0">return "Неверные данные: " + msg</span>
                case codes.NotFound:<span class="cov8" title="1">
                        return "Данные не найдены. Попробуйте снова."</span>
                case codes.PermissionDenied:<span class="cov8" title="1">
                        return "Доступ запрещен. Проверьте права доступа."</span>
                case codes.Unauthenticated:<span class="cov0" title="0">
                        return "Требуется авторизация. Выполните вход снова."</span>
                case codes.ResourceExhausted:<span class="cov0" title="0">
                        return "Превышен лимит запросов. Попробуйте позже."</span>
                case codes.Unavailable:<span class="cov8" title="1">
                        return "Сервис временно недоступен. Попробуйте позже."</span>
                case codes.DeadlineExceeded:<span class="cov0" title="0">
                        return "Превышено время ожидания. Попробуйте снова."</span>
                case codes.Internal:<span class="cov0" title="0">
                        return "Внутренняя ошибка сервера. Попробуйте позже."</span>
                default:<span class="cov0" title="0">
                        return "Произошла ошибка: " + st.Message()</span>
                }
        }

        // Если это не gRPC ошибка, проверяем содержимое сообщения
        <span class="cov0" title="0">errMsg := err.Error()
        if strings.Contains(errMsg, "invalid email format") </span><span class="cov0" title="0">{
                return "Неверный формат email. Пожалуйста, введите корректный email адрес."
        }</span>
        <span class="cov0" title="0">if strings.Contains(errMsg, "invalid verification code") </span><span class="cov0" title="0">{
                return "Неверный код подтверждения. Пожалуйста, проверьте код и попробуйте снова."
        }</span>
        <span class="cov0" title="0">if strings.Contains(errMsg, "email") </span><span class="cov0" title="0">{
                return "Ошибка с email: " + errMsg
        }</span>
        <span class="cov0" title="0">if strings.Contains(errMsg, "network") || strings.Contains(errMsg, "connection") </span><span class="cov0" title="0">{
                return "Ошибка соединения. Проверьте интернет и попробуйте снова."
        }</span>

        // Общая ошибка
        <span class="cov0" title="0">return "Произошла ошибка: " + errMsg</span>
}

// IsRetryableError проверяет, можно ли повторить запрос при этой ошибке
func IsRetryableError(err error) bool <span class="cov8" title="1">{
        if st, ok := status.FromError(err); ok </span><span class="cov8" title="1">{
                switch st.Code() </span>{
                case codes.Unavailable, codes.ResourceExhausted, codes.DeadlineExceeded:<span class="cov8" title="1">
                        return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// isValidEmail выполняет простую валидацию email
func isValidEmail(email string) bool <span class="cov8" title="1">{
        if email == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Проверяем наличие @ символа
        <span class="cov8" title="1">if !strings.Contains(email, "@") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Проверяем, что есть часть до и после @
        <span class="cov8" title="1">parts := strings.Split(email, "@")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">localPart := parts[0]
        domainPart := parts[1]
        
        // Проверяем, что части не пустые
        if localPart == "" || domainPart == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Проверяем, что домен содержит точку
        <span class="cov8" title="1">if !strings.Contains(domainPart, ".") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Проверяем минимальную длину
        <span class="cov8" title="1">if len(localPart) &lt; 1 || len(domainPart) &lt; 4 </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"
        "fmt"
        "strings"
        "time"

        "budget-bot/internal/bot/ui"
        "budget-bot/internal/domain"
        "budget-bot/internal/metrics"
        grpcclient "budget-bot/internal/grpc"
        "budget-bot/internal/repository"
        "github.com/google/uuid"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
        "go.uber.org/zap"
        pb "budget-bot/internal/pb/budget/v1"
)

// Handler wires bot dependencies and handles Telegram updates.
type Handler struct {
        bot        *tgbotapi.BotAPI
        states     repository.DialogStateRepository
        auth       *OAuthManager
        logger     *zap.Logger
        parser     *MessageParser
        categories grpcclient.CategoryClient
        mappings   repository.CategoryMappingRepository
        matcher    *CategoryMatcher
        nameMapper *CategoryNameMapper
        txClient   grpcclient.TransactionClient
        prefs      repository.PreferencesRepository
        report     grpcclient.ReportClient
        drafts     repository.DraftRepository
        tenants    grpcclient.TenantClient
        fmt        *ui.MessageFormatter
}

// NewHandler constructs a Handler.
func NewHandler(bot *tgbotapi.BotAPI, states repository.DialogStateRepository, auth *OAuthManager, mappings repository.CategoryMappingRepository, categories grpcclient.CategoryClient, logger *zap.Logger) *Handler <span class="cov8" title="1">{
        if categories == nil </span><span class="cov8" title="1">{
                categories = &amp;grpcclient.StaticCategoryClient{}
        }</span>
        <span class="cov8" title="1">return &amp;Handler{bot: bot, states: states, auth: auth, logger: logger, parser: NewMessageParser(), categories: categories, mappings: mappings, matcher: NewCategoryMatcher(mappings), nameMapper: NewCategoryNameMapper(categories), txClient: &amp;grpcclient.FakeTransactionClient{}, report: &amp;grpcclient.FakeReportClient{}, tenants: &amp;grpcclient.FakeTenantClient{}, fmt: ui.NewMessageFormatter()}</span>
}

// WithPreferences allows injecting a preferences repository after construction.
func (h *Handler) WithPreferences(p repository.PreferencesRepository) *Handler <span class="cov8" title="1">{
        h.prefs = p
        return h
}</span>

// WithDrafts allows injecting a draft repository.
func (h *Handler) WithDrafts(d repository.DraftRepository) *Handler <span class="cov8" title="1">{
        h.drafts = d
        return h
}</span>

// WithReportClient allows injecting a report client.
func (h *Handler) WithReportClient(rc grpcclient.ReportClient) *Handler <span class="cov8" title="1">{
        if rc != nil </span><span class="cov8" title="1">{
                h.report = rc
        }</span>
        <span class="cov8" title="1">return h</span>
}

// WithCategoryClient allows injecting a category client.
func (h *Handler) WithCategoryClient(cc grpcclient.CategoryClient) *Handler <span class="cov8" title="1">{
        if cc != nil </span><span class="cov8" title="1">{
                h.categories = cc
        }</span>
        <span class="cov8" title="1">return h</span>
}

// WithTransactionClient allows injecting a transaction client.
func (h *Handler) WithTransactionClient(tc grpcclient.TransactionClient) *Handler <span class="cov8" title="1">{
        if tc != nil </span><span class="cov8" title="1">{
                h.txClient = tc
        }</span>
        <span class="cov8" title="1">return h</span>
}

// WithTenantClient allows injecting a tenant client.
func (h *Handler) WithTenantClient(tc grpcclient.TenantClient) *Handler <span class="cov8" title="1">{
        if tc != nil </span><span class="cov8" title="1">{
                h.tenants = tc
        }</span>
        <span class="cov8" title="1">return h</span>
}

// HandleUpdate processes a single Telegram update.
func (h *Handler) HandleUpdate(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                h.handleCallback(ctx, update)
                return
        }</span>
        <span class="cov8" title="1">if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">metrics.IncUpdate()

        // Debug logging for command detection
        if strings.HasPrefix(update.Message.Text, "/") </span><span class="cov8" title="1">{
                h.logger.Debug("potential command detected", 
                        zap.String("text", update.Message.Text),
                        zap.Bool("is_command", update.Message.IsCommand()),
                        zap.Any("entities", update.Message.Entities))
        }</span>

        <span class="cov8" title="1">if update.Message.IsCommand() </span><span class="cov8" title="1">{
                h.handleCommand(ctx, update)
                return
        }</span>

        // Fallback for commands that start with / but are not recognized as commands
        <span class="cov8" title="1">if strings.HasPrefix(update.Message.Text, "/") </span><span class="cov0" title="0">{
                h.logger.Warn("command not recognized by IsCommand()", 
                        zap.String("text", update.Message.Text))
                // Try to handle as command anyway
                h.handleCommand(ctx, update)
                return
        }</span>

        <span class="cov8" title="1">rec, _ := h.states.GetState(ctx, update.Message.From.ID)
        if rec != nil </span><span class="cov8" title="1">{
                switch rec.State </span>{
                case repository.StateWaitingForOAuthEmail:<span class="cov8" title="1">
                        h.handleOAuthEmail(ctx, update)
                        return</span>
                case repository.StateWaitingForOAuthCode:<span class="cov8" title="1">
                        h.handleOAuthCode(ctx, update)
                        return</span>
                }
        }

        // Try parse transaction
        <span class="cov8" title="1">parsed, _ := h.parser.ParseMessage(update.Message.Text)
        if parsed != nil &amp;&amp; parsed.IsValid </span><span class="cov8" title="1">{
                // Default currency from preferences if missing
                cur := parsed.Currency
                if cur == "" &amp;&amp; h.prefs != nil </span><span class="cov8" title="1">{
                        if pref, err := h.prefs.GetPreferences(ctx, update.Message.From.ID); err == nil &amp;&amp; pref != nil &amp;&amp; pref.DefaultCurrency != "" </span><span class="cov0" title="0">{
                                cur = pref.DefaultCurrency
                        }</span>
                        <span class="cov8" title="1">if cur == "" </span><span class="cov8" title="1">{
                                cur = "RUB"
                        }</span>
                }
                <span class="cov8" title="1">amt := float64(parsed.Amount.AmountMinor) / 100.0
                // Try suggest category if session present
                if sess, err := h.auth.GetSession(ctx, update.Message.From.ID); err == nil &amp;&amp; sess != nil </span><span class="cov8" title="1">{
                        var catID string
                        if h.matcher != nil </span><span class="cov8" title="1">{
                                if m, err := h.matcher.FindCategory(ctx, sess.TenantID, parsed.Description); err == nil &amp;&amp; m != nil </span><span class="cov0" title="0">{
                                        catID = m.CategoryID
                                }</span>
                        }
                        // If no mapping -&gt; ask for category (persist as draft)
                        <span class="cov8" title="1">if catID == "" </span><span class="cov8" title="1">{
                                pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
                                locale := ""
                                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{ locale = pref.Language }</span>
                                <span class="cov8" title="1">list, err := h.categories.ListCategories(ctx, sess.TenantID, sess.AccessToken, parsed.Type, locale)
                                if err != nil || len(list) == 0 </span><span class="cov0" title="0">{
                                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить категории"))
                                        return
                                }</span>
                                <span class="cov8" title="1">kb := ui.CreateCategoryKeyboard(list)
                                if h.drafts != nil </span><span class="cov8" title="1">{
                                        draftID := uuid.NewString()
                                        _ = h.drafts.Create(ctx, &amp;repository.TransactionDraft{ID: draftID, TelegramID: update.Message.From.ID, Type: string(parsed.Type), AmountMinor: parsed.Amount.AmountMinor, Currency: cur, Description: parsed.Description, OccurredAt: parsed.OccurredAt})
                                }</span>
                                <span class="cov8" title="1">_ = h.states.SetState(ctx, update.Message.From.ID, repository.StateWaitingForCategory, map[string]any{
                                        "type":         string(parsed.Type),
                                        "amount_minor": parsed.Amount.AmountMinor,
                                        "currency":     cur,
                                        "desc":         parsed.Description,
                                        "occurred_at":  occurredUnix(parsed.OccurredAt),
                                }, nil)
                                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Выберите категорию")
                                msg.ReplyMarkup = kb
                                _, _ = h.bot.Send(msg)
                                return</span>
                        }
                        // Have category -&gt; ask to confirm
                        // Get category name by ID for display
                        <span class="cov0" title="0">var categoryDisplayName string
                        if h.nameMapper != nil </span><span class="cov0" title="0">{
                                pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
                                locale := "ru"
                                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{
                                        locale = pref.Language
                                }</span>
                                <span class="cov0" title="0">if name, err := h.nameMapper.GetCategoryNameByID(ctx, sess.TenantID, sess.AccessToken, catID, parsed.Type, locale); err == nil &amp;&amp; name != "" </span><span class="cov0" title="0">{
                                        categoryDisplayName = name
                                }</span> else<span class="cov0" title="0"> {
                                        categoryDisplayName = catID // fallback to ID if name not found
                                }</span>
                        } else<span class="cov0" title="0"> {
                                categoryDisplayName = catID // fallback to ID if nameMapper not available
                        }</span>
                        
                        <span class="cov0" title="0">kb := ui.CreateConfirmationKeyboard()
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("Сохранить: %s %.2f %s — %s (категория: %s)?", string(parsed.Type), amt, cur, parsed.Description, categoryDisplayName))
                        msg.ReplyMarkup = kb
                        _ = h.states.SetState(ctx, update.Message.From.ID, repository.StateConfirmingTransaction, map[string]any{
                                "type":         string(parsed.Type),
                                "amount_minor": parsed.Amount.AmountMinor,
                                "currency":     cur,
                                "desc":         parsed.Description,
                                "category_id":  catID,
                                "occurred_at":  occurredUnix(parsed.OccurredAt),
                        }, nil)
                        _, _ = h.bot.Send(msg)
                        return</span>
                }
                // No session; just echo parse
                <span class="cov8" title="1">msgText := fmt.Sprintf("Распознано: %s %.2f %s — %s", string(parsed.Type), amt, cur, parsed.Description)
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, msgText)
                _, err := h.bot.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("failed to send parse result", zap.Error(err), zap.String("text", msgText))
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if parsed != nil &amp;&amp; !parsed.IsValid </span><span class="cov8" title="1">{
                // Provide simple validation feedback
                msgText := "Не удалось распознать сообщение. Убедитесь, что указана сумма (например: 100 кофе)"
                if len(parsed.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        // Show first error in a user-friendly way
                        msgText = "Ошибка: " + parsed.Errors[0]
                }</span>
                <span class="cov8" title="1">msg := tgbotapi.NewMessage(update.Message.Chat.ID, msgText)
                _, err := h.bot.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("failed to send validation error", zap.Error(err), zap.String("text", msgText))
                }</span>
                <span class="cov8" title="1">return</span>
        }
}

func occurredUnix(t *time.Time) int64 <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        // Time is already in UTC, just convert to Unix timestamp
        <span class="cov0" title="0">return t.Unix()</span>
}

func (h *Handler) handleCallback(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        cb := update.CallbackQuery
        if cb == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data := cb.Data
        if strings.HasPrefix(data, "confirm:") </span><span class="cov8" title="1">{
                choice := strings.TrimPrefix(data, "confirm:")
                if choice == "yes" </span><span class="cov8" title="1">{
                        // create transaction via txClient using stored state
                        rec, _ := h.states.GetState(ctx, cb.From.ID)
                        if rec != nil &amp;&amp; rec.Context != nil </span><span class="cov8" title="1">{
                                typeStr, _ := rec.Context["type"].(string)
                                var amountMinor int64
                                switch v := rec.Context["amount_minor"].(type) </span>{
                                case float64:<span class="cov8" title="1">
                                        amountMinor = int64(v)</span>
                                case int64:<span class="cov0" title="0">
                                        amountMinor = v</span>
                                case int:<span class="cov0" title="0">
                                        amountMinor = int64(v)</span>
                                }
                                <span class="cov8" title="1">currency, _ := rec.Context["currency"].(string)
                                desc, _ := rec.Context["desc"].(string)
                                catID, _ := rec.Context["category_id"].(string)
                                var occurred time.Time
                                if ts, ok := rec.Context["occurred_at"].(float64); ok &amp;&amp; ts &gt; 0 </span><span class="cov0" title="0">{
                                        // Time is already in UTC, just restore from Unix timestamp
                                        occurred = time.Unix(int64(ts), 0)
                                }</span> else<span class="cov8" title="1"> {
                                        occurred = time.Now()
                                }</span>
                                <span class="cov8" title="1">sess, err := h.auth.GetSession(ctx, cb.From.ID)
                                if err == nil </span><span class="cov8" title="1">{
                                        _, _ = h.txClient.CreateTransaction(ctx, &amp;grpcclient.CreateTransactionRequest{
                                                TenantID:    sess.TenantID,
                                                Type:        typeStr,
                                                AmountMinor: amountMinor,
                                                Currency:    currency,
                                                Description: desc,
                                                CategoryID:  catID,
                                                OccurredAt:  occurred,
                                        }, sess.AccessToken)
                                        metrics.IncTransactionsSaved("ok")
                                }</span>
                                // Cleanup draft if present
                                <span class="cov8" title="1">if h.drafts != nil </span><span class="cov8" title="1">{
                                        if dID, ok := rec.Context["draft_id"].(string); ok &amp;&amp; dID != "" </span><span class="cov0" title="0">{
                                                _ = h.drafts.Delete(ctx, dID)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">_ = h.states.ClearState(ctx, cb.From.ID)
                        _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Сохранено"))
                        _, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Транзакция сохранена"))
                        return</span>
                }
                <span class="cov8" title="1">if choice == "no" </span><span class="cov8" title="1">{
                        _ = h.states.ClearState(ctx, cb.From.ID)
                        _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Отменено"))
                        _, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Отменено"))
                        return
                }</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(data, "cat:") </span><span class="cov8" title="1">{
                categoryName := strings.TrimPrefix(data, "cat:")
                rec, _ := h.states.GetState(ctx, cb.From.ID)
                if rec == nil || rec.Context == nil </span><span class="cov8" title="1">{
                        _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Нет контекста"))
                        return
                }</span>
                
                // Get session for tenant and access token
                <span class="cov8" title="1">sess, err := h.auth.GetSession(ctx, cb.From.ID)
                if err != nil || sess == nil </span><span class="cov0" title="0">{
                        _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Нет сессии"))
                        return
                }</span>
                
                // Get preferences for locale
                <span class="cov8" title="1">pref, _ := h.prefs.GetPreferences(ctx, cb.From.ID)
                locale := "ru"
                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{
                        locale = pref.Language
                }</span>
                
                // Determine transaction type from context
                <span class="cov8" title="1">typeStr, _ := rec.Context["type"].(string)
                var transactionType domain.TransactionType
                if typeStr == "income" </span><span class="cov0" title="0">{
                        transactionType = domain.TransactionIncome
                }</span> else<span class="cov8" title="1"> {
                        transactionType = domain.TransactionExpense
                }</span>
                
                // Map category name to ID
                <span class="cov8" title="1">categoryID, err := h.nameMapper.GetCategoryIDByName(ctx, sess.TenantID, sess.AccessToken, categoryName, transactionType, locale)
                if err != nil || categoryID == "" </span><span class="cov0" title="0">{
                        _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Категория не найдена"))
                        return
                }</span>
                
                <span class="cov8" title="1">rec.Context["category_id"] = categoryID
                // Ask confirmation now
                var amountMinor int64
                switch v := rec.Context["amount_minor"].(type) </span>{
                case float64:<span class="cov8" title="1">
                        amountMinor = int64(v)</span>
                case int64:<span class="cov0" title="0">
                        amountMinor = v</span>
                case int:<span class="cov0" title="0">
                        amountMinor = int64(v)</span>
                }
                <span class="cov8" title="1">amt := float64(amountMinor) / 100.0
                currency, _ := rec.Context["currency"].(string)
                desc, _ := rec.Context["desc"].(string)
                kb := ui.CreateConfirmationKeyboard()
                msg := tgbotapi.NewMessage(cb.Message.Chat.ID,
                        fmt.Sprintf("Сохранить: %s %.2f %s — %s (категория: %s)?", typeStr, amt, currency, desc, categoryName))
                msg.ReplyMarkup = kb
                _ = h.states.SetState(ctx, cb.From.ID, repository.StateConfirmingTransaction, rec.Context, nil)
                _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Категория выбрана"))
                _, _ = h.bot.Send(msg)
                return</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(data, "lang:") </span><span class="cov8" title="1">{
                lang := strings.TrimPrefix(data, "lang:")
                if h.prefs != nil </span><span class="cov8" title="1">{
                        // preserve currency
                        var cur string
                        if pref, err := h.prefs.GetPreferences(ctx, cb.From.ID); err == nil &amp;&amp; pref != nil </span><span class="cov0" title="0">{
                                cur = pref.DefaultCurrency
                        }</span>
                        <span class="cov8" title="1">_ = h.prefs.SavePreferences(ctx, &amp;repository.UserPreferences{TelegramID: cb.From.ID, Language: lang, DefaultCurrency: cur})</span>
                }
                <span class="cov8" title="1">_, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Язык: "+lang))
                _, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Язык обновлён"))
                return</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(data, "cur:") </span><span class="cov8" title="1">{
                cur := strings.TrimPrefix(data, "cur:")
                if h.prefs != nil </span><span class="cov8" title="1">{
                        var lang string
                        if pref, err := h.prefs.GetPreferences(ctx, cb.From.ID); err == nil &amp;&amp; pref != nil </span><span class="cov8" title="1">{
                                lang = pref.Language
                        }</span>
                        <span class="cov8" title="1">_ = h.prefs.SavePreferences(ctx, &amp;repository.UserPreferences{TelegramID: cb.From.ID, Language: lang, DefaultCurrency: cur})</span>
                }
                <span class="cov8" title="1">_, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Валюта: "+cur))
                _, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Валюта по умолчанию обновлена"))
                return</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(data, "tenant:") </span><span class="cov8" title="1">{
                tenantID := strings.TrimPrefix(data, "tenant:")
                _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Организация выбрана"))
                if err := h.auth.sessionRepo.UpdateTenantID(ctx, cb.From.ID, tenantID); err == nil </span><span class="cov8" title="1">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Организация переключена"))
                        return
                }</span>
                <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(cb.Message.Chat.ID, "Не удалось переключить организацию"))
                return</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(data, "help:") </span><span class="cov8" title="1">{
                helpSection := strings.TrimPrefix(data, "help:")
                _, _ = h.bot.Request(tgbotapi.NewCallback(cb.ID, "Раздел справки"))
                
                // Create proper message with command entities
                messageText := "/help " + helpSection
                message := &amp;tgbotapi.Message{
                        Chat: cb.Message.Chat,
                        From: cb.From,
                        Text: messageText,
                        Entities: []tgbotapi.MessageEntity{
                                {
                                        Type:   "bot_command",
                                        Offset: 0,
                                        Length: 5, // "/help"
                                },
                        },
                }
                
                h.handleHelp(ctx, tgbotapi.Update{Message: message})
                return
        }</span>
}

func (h *Handler) handleCommand(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        switch update.Message.Command() </span>{
        case "start":<span class="cov8" title="1">
                h.handleStart(ctx, update)</span>
        case "login":<span class="cov8" title="1">
                h.startLogin(ctx, update)</span>
        case "register":<span class="cov0" title="0">
                h.startRegister(ctx, update)</span>
        case "logout":<span class="cov0" title="0">
                h.handleLogout(ctx, update)</span>
        case "map":<span class="cov8" title="1">
                h.handleMap(ctx, update)</span>
        case "unmap":<span class="cov8" title="1">
                h.handleUnmap(ctx, update)</span>
        case "categories":<span class="cov8" title="1">
                h.handleCategories(ctx, update)</span>
        case "language":<span class="cov8" title="1">
                h.handleLanguage(ctx, update)</span>
        case "currency":<span class="cov8" title="1">
                h.handleCurrency(ctx, update)</span>
        case "stats":<span class="cov8" title="1">
                h.handleStats(ctx, update)</span>
        case "top_categories":<span class="cov0" title="0">
                h.handleTopCategories(ctx, update)</span>
        case "recent":<span class="cov8" title="1">
                h.handleRecent(ctx, update)</span>
        case "export":<span class="cov8" title="1">
                h.handleExport(ctx, update)</span>
        case "create_category":<span class="cov8" title="1">
                h.handleCreateCategory(ctx, update)</span>
        case "rename_category":<span class="cov8" title="1">
                h.handleRenameCategory(ctx, update)</span>
        case "delete_category":<span class="cov8" title="1">
                h.handleDeleteCategory(ctx, update)</span>
        case "switch_tenant":<span class="cov8" title="1">
                h.handleSwitchTenant(ctx, update)</span>
        case "profile":<span class="cov8" title="1">
                h.handleProfile(ctx, update)</span>
        case "help":<span class="cov8" title="1">
                h.handleHelp(ctx, update)</span>
        case "cancel":<span class="cov8" title="1">
                h.handleCancel(ctx, update)</span>
        default:<span class="cov8" title="1">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Неизвестная команда. Используйте /help для получения справки.")
                _, err := h.bot.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("failed to send unknown command message", zap.Error(err))
                }</span>
        }
}

func (h *Handler) handleSwitchTenant(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        <span class="cov8" title="1">list, err := h.tenants.ListTenants(ctx, sess.AccessToken)
        if err != nil || len(list) == 0 </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить организации"))
                return
        }</span>
        <span class="cov8" title="1">kb := ui.CreateTenantKeyboard(list)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Выберите организацию")
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)</span>
}

func (h *Handler) handleCancel(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        _ = h.states.ClearState(ctx, update.Message.From.ID)
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Текущая операция отменена"))
}</span>

func (h *Handler) handleStart(_ context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        // Greet and show basic commands
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Привет! Я бот учёта бюджета.\n\n"+
                "/login — вход через OAuth\n"+
                "/logout — выход\n"+
                "/help — подробная справка\n\n"+
                "Отправьте сумму и описание для добавления транзакции, например:\n"+
                "1000 продукты\n"+
                "+50000 зарплата")
        
        menu := ui.CreateMainMenuKeyboard()
        msg.ReplyMarkup = menu
        
        _, err := h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to send start message", zap.Error(err))
        }</span>
}

func (h *Handler) startLogin(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        _ = h.states.SetState(ctx, update.Message.From.ID, repository.StateWaitingForOAuthEmail, nil, nil)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите email для авторизации через OAuth:")
        _, err := h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to send OAuth login email prompt", zap.Error(err))
        }</span>
}

func (h *Handler) handleOAuthEmail(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        email := strings.TrimSpace(update.Message.Text)
        
        // Простая валидация email на стороне клиента
        if !isValidEmail(email) </span><span class="cov8" title="1">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Неверный формат email. Пожалуйста, введите корректный email адрес.\n\nПример: user@example.com")
                _, _ = h.bot.Send(msg)
                return
        }</span>
        
        // Generate OAuth auth link
        <span class="cov8" title="1">userAgent := "TelegramBot/1.0"
        ipAddress := "127.0.0.1" // In real implementation, get from request context
        
        authURL, authToken, expiresAt, err := h.auth.GenerateAuthLink(ctx, update.Message.From.ID, email, userAgent, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := GetUserFriendlyError(err)
                if IsRetryableError(err) </span><span class="cov0" title="0">{
                        errorMsg += "\n\nПопробуйте снова через несколько секунд."
                }</span> else<span class="cov0" title="0"> {
                        errorMsg += "\n\nПопробуйте снова /login"
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, errorMsg)
                _, _ = h.bot.Send(msg)
                return</span>
        }
        
        // Store auth token in context for later verification
        <span class="cov8" title="1">ctxMap := map[string]any{
                "email":      email,
                "authToken":  authToken,
                "expiresAt":  expiresAt,
        }
        _ = h.states.SetState(ctx, update.Message.From.ID, repository.StateWaitingForOAuthCode, ctxMap, nil)
        
        // Send auth link to user
        authMessage := fmt.Sprintf("Для авторизации перейдите по ссылке:\n%s\n\nПосле авторизации введите код подтверждения, который появится на странице.", authURL)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, authMessage)
        _, _ = h.bot.Send(msg)</span>
}

func (h *Handler) handleOAuthCode(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        rec, _ := h.states.GetState(ctx, update.Message.From.ID)
        if rec == nil || rec.Context == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Начните с /login")
                _, _ = h.bot.Send(msg)
                return
        }</span>
        
        <span class="cov8" title="1">authToken, _ := rec.Context["authToken"].(string)
        verificationCode := strings.TrimSpace(update.Message.Text)
        
        h.logger.Info("User entered verification code",
                zap.Int64("telegramID", update.Message.From.ID),
                zap.String("verificationCode", verificationCode),
                zap.String("authToken", authToken))
        
        if err := h.auth.VerifyAuthCode(ctx, update.Message.From.ID, authToken, verificationCode); err != nil </span><span class="cov0" title="0">{
                errorMsg := GetUserFriendlyError(err)
                if IsRetryableError(err) </span><span class="cov0" title="0">{
                        errorMsg += "\n\nПопробуйте снова через несколько секунд."
                }</span> else<span class="cov0" title="0"> {
                        errorMsg += "\n\nПопробуйте снова /login"
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, errorMsg)
                _, _ = h.bot.Send(msg)
                return</span>
        }
        
        <span class="cov8" title="1">_ = h.states.ClearState(ctx, update.Message.From.ID)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Вы успешно авторизованы через OAuth!")
        _, _ = h.bot.Send(msg)</span>
}

func (h *Handler) handleLogout(ctx context.Context, update tgbotapi.Update) <span class="cov0" title="0">{
        _ = h.auth.Logout(ctx, update.Message.From.ID)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Вы вышли из системы")
        _, _ = h.bot.Send(msg)
}</span>

// getSessionWithErrorHandling получает сессию пользователя с понятной обработкой ошибок
func (h *Handler) getSessionWithErrorHandling(ctx context.Context, chatID int64, userID int64) (*repository.UserSession, bool) <span class="cov0" title="0">{
        session, err := h.auth.GetSession(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := GetUserFriendlyError(err)
                if errorMsg == "" </span><span class="cov0" title="0">{
                        errorMsg = "Требуется авторизация"
                }</span>
                <span class="cov0" title="0">errorMsg += "\n\nВыполните вход: /login"
                msg := tgbotapi.NewMessage(chatID, errorMsg)
                _, _ = h.bot.Send(msg)
                return nil, false</span>
        }
        <span class="cov0" title="0">return session, true</span>
}

// Registration is not supported in OAuth flow - users should register through the web interface
func (h *Handler) startRegister(ctx context.Context, update tgbotapi.Update) <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Регистрация через бота не поддерживается. Пожалуйста, зарегистрируйтесь через веб-интерфейс.")
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) handleMap(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        parts := strings.SplitN(strings.TrimSpace(update.Message.CommandArguments()), "=", 2)
        args := strings.TrimSpace(update.Message.CommandArguments())
        if args == "--all" </span><span class="cov8" title="1">{
                sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
                if err != nil </span><span class="cov8" title="1">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                        return
                }</span>
                <span class="cov0" title="0">items, err := h.mappings.ListMappings(ctx, sess.TenantID)
                if err != nil </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить сопоставления"))
                        return
                }</span>
                <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сопоставлений нет"))
                        return
                }</span>
                
                // Get preferences for locale
                <span class="cov0" title="0">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
                locale := "ru"
                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{
                        locale = pref.Language
                }</span>
                
                <span class="cov0" title="0">var b strings.Builder
                for _, m := range items </span><span class="cov0" title="0">{
                        // Try to get category name by ID
                        categoryName, err := h.nameMapper.GetCategoryNameByID(ctx, sess.TenantID, sess.AccessToken, m.CategoryID, domain.TransactionExpense, locale)
                        if err != nil || categoryName == "" </span><span class="cov0" title="0">{
                                // Fallback to ID if name not found
                                b.WriteString(fmt.Sprintf("%s = %s\n", m.Keyword, m.CategoryID))
                        }</span> else<span class="cov0" title="0"> {
                                b.WriteString(fmt.Sprintf("%s = %s\n", m.Keyword, categoryName))
                        }</span>
                }
                <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, b.String()))
                return</span>
        }
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                // show mapping for keyword
                keyword := strings.TrimSpace(parts[0])
                if keyword == "" </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /map слово = название_категории"))
                        return
                }</span>
                <span class="cov8" title="1">sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
                if err != nil </span><span class="cov8" title="1">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                        return
                }</span>
                <span class="cov0" title="0">m, err := h.mappings.FindMapping(ctx, sess.TenantID, keyword)
                if err != nil || m == nil </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сопоставление не найдено"))
                        return
                }</span>
                
                // Get preferences for locale
                <span class="cov0" title="0">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
                locale := "ru"
                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{
                        locale = pref.Language
                }</span>
                
                // Try to get category name by ID
                <span class="cov0" title="0">categoryName, err := h.nameMapper.GetCategoryNameByID(ctx, sess.TenantID, sess.AccessToken, m.CategoryID, domain.TransactionExpense, locale)
                if err != nil || categoryName == "" </span><span class="cov0" title="0">{
                        // Fallback to ID if name not found
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, fmt.Sprintf("%s = %s", m.Keyword, m.CategoryID)))
                }</span> else<span class="cov0" title="0"> {
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, fmt.Sprintf("%s = %s", m.Keyword, categoryName)))
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">if len(parts) == 2 </span><span class="cov8" title="1">{
                keyword := strings.TrimSpace(parts[0])
                categoryName := strings.TrimSpace(parts[1])
                if keyword == "" || categoryName == "" </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /map слово = название_категории"))
                        return
                }</span>
                <span class="cov8" title="1">sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
                if err != nil </span><span class="cov8" title="1">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                        return
                }</span>
                
                // Get preferences for locale
                <span class="cov0" title="0">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
                locale := "ru"
                if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{
                        locale = pref.Language
                }</span>
                
                // Map category name to ID
                <span class="cov0" title="0">categoryID, err := h.nameMapper.GetCategoryIDByName(ctx, sess.TenantID, sess.AccessToken, categoryName, domain.TransactionExpense, locale)
                if err != nil || categoryID == "" </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Категория не найдена"))
                        return
                }</span>
                
                <span class="cov0" title="0">id := uuid.NewString()
                if err := h.mappings.AddMapping(ctx, &amp;repository.CategoryMapping{ID: id, TenantID: sess.TenantID, Keyword: keyword, CategoryID: categoryID, Priority: 0}); err != nil </span><span class="cov0" title="0">{
                        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось сохранить сопоставление"))
                        return
                }</span>
                <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сопоставление сохранено"))
                return</span>
        }
        <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /map слово = название_категории"))</span>
}

func (h *Handler) handleUnmap(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        keyword := strings.TrimSpace(update.Message.CommandArguments())
        if keyword == "" </span><span class="cov8" title="1">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /unmap слово"))
                return
        }</span>
        <span class="cov8" title="1">sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov8" title="1">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        <span class="cov0" title="0">if err := h.mappings.RemoveMapping(ctx, sess.TenantID, keyword); err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось удалить сопоставление"))
                return
        }</span>
        <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сопоставление удалено"))</span>
}

func (h *Handler) handleCategories(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov8" title="1">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        <span class="cov8" title="1">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
        locale := ""
        if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov8" title="1">{ locale = pref.Language }</span>
        // Default to expense categories for /categories command
        <span class="cov8" title="1">list, err := h.categories.ListCategories(ctx, sess.TenantID, sess.AccessToken, domain.TransactionExpense, locale)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить категории"))
                return
        }</span>
        <span class="cov8" title="1">kb := ui.CreateCategoryKeyboard(list)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Выберите категорию")
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)</span>
}

func (h *Handler) handleLanguage(_ context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        kb := ui.CreateLanguageKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Выберите язык интерфейса")
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) handleCurrency(_ context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        kb := ui.CreateCurrencyKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Выберите валюту по умолчанию")
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) handleStats(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        h.logger.Debug("handleStats called", 
                zap.Int64("userID", update.Message.From.ID),
                zap.String("commandArgs", update.Message.CommandArguments()))
        
        sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("handleStats: no session found", 
                        zap.Int64("userID", update.Message.From.ID),
                        zap.Error(err))
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        
        <span class="cov0" title="0">h.logger.Debug("handleStats: session found", 
                zap.String("tenantID", sess.TenantID),
                zap.String("accessToken", sess.AccessToken[:10] + "..."))
        
        // Current month (overridden by optional arg)
        now := time.Now()
        from := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        to := from.AddDate(0, 1, -1)
        if arg := strings.TrimSpace(update.Message.CommandArguments()); arg != "" </span><span class="cov0" title="0">{
                if arg == "week" </span><span class="cov0" title="0">{
                        wd := int(now.Weekday())
                        if wd == 0 </span><span class="cov0" title="0">{ wd = 7 }</span>
                        <span class="cov0" title="0">from = time.Date(now.Year(), now.Month(), now.Day()-(wd-1), 0, 0, 0, 0, now.Location())
                        to = from.AddDate(0, 0, 6)</span>
                } else<span class="cov0" title="0"> if len(arg) == 7 </span><span class="cov0" title="0">{
                        var y, m int
                        if _, e := fmt.Sscanf(arg, "%d-%d", &amp;y, &amp;m); e == nil &amp;&amp; m &gt;= 1 &amp;&amp; m &lt;= 12 </span><span class="cov0" title="0">{
                                from = time.Date(y, time.Month(m), 1, 0, 0, 0, 0, now.Location())
                                to = from.AddDate(0, 1, -1)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">h.logger.Debug("handleStats: calling GetStats", 
                zap.Time("from", from),
                zap.Time("to", to))
        
        st, err := h.report.GetStats(ctx, sess.TenantID, from, to, sess.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("handleStats: GetStats failed", 
                        zap.String("tenantID", sess.TenantID),
                        zap.Time("from", from),
                        zap.Time("to", to),
                        zap.Error(err))
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить статистику"))
                return
        }</span>
        
        <span class="cov0" title="0">h.logger.Debug("handleStats: GetStats successful", 
                zap.String("period", st.Period),
                zap.Int64("totalIncome", st.TotalIncome),
                zap.Int64("totalExpense", st.TotalExpense),
                zap.String("currency", st.Currency))
        
        text := h.fmt.FormatStats(st)
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, text))</span>
}

func (h *Handler) handleTopCategories(ctx context.Context, update tgbotapi.Update) <span class="cov0" title="0">{
        sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        <span class="cov0" title="0">now := time.Now()
        from := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        to := from.AddDate(0, 1, -1)
        limit := 5
        if arg := strings.TrimSpace(update.Message.CommandArguments()); arg != "" </span><span class="cov0" title="0">{
                parts := strings.Fields(arg)
                for _, p := range parts </span><span class="cov0" title="0">{
                        if p == "week" </span><span class="cov0" title="0">{
                                wd := int(now.Weekday())
                                if wd == 0 </span><span class="cov0" title="0">{ wd = 7 }</span>
                                <span class="cov0" title="0">from = time.Date(now.Year(), now.Month(), now.Day()-(wd-1), 0, 0, 0, 0, now.Location())
                                to = from.AddDate(0, 0, 6)
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(p) == 7 </span><span class="cov0" title="0">{
                                var y, m int
                                if _, e := fmt.Sscanf(p, "%d-%d", &amp;y, &amp;m); e == nil &amp;&amp; m &gt;= 1 &amp;&amp; m &lt;= 12 </span><span class="cov0" title="0">{
                                        from = time.Date(y, time.Month(m), 1, 0, 0, 0, 0, now.Location())
                                        to = from.AddDate(0, 1, -1)
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if v, e := fmt.Sscanf(p, "%d", &amp;limit); e == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                // limit parsed via Sscanf above; ensure sensible bounds
                                if limit &lt;= 0 </span><span class="cov0" title="0">{ limit = 5 }</span>
                                <span class="cov0" title="0">if limit &gt; 50 </span><span class="cov0" title="0">{ limit = 50 }</span>
                        }
                }
        }
        <span class="cov0" title="0">items, err := h.report.TopCategories(ctx, sess.TenantID, from, to, limit, sess.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить топ категорий"))
                return
        }</span>
        <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Нет данных"))
                return
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        b.WriteString("Топ категорий:\n")
        for i, it := range items </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("%d) %s — %.2f %s\n", i+1, it.Name, float64(it.SumMinor)/100.0, it.Currency))
        }</span>
        <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, b.String()))</span>
}

func (h *Handler) handleRecent(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
        if err != nil </span><span class="cov8" title="1">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
                return
        }</span>
        <span class="cov0" title="0">limit := 10
        if arg := strings.TrimSpace(update.Message.CommandArguments()); arg != "" </span><span class="cov0" title="0">{
                var parsed int
                if _, e := fmt.Sscanf(arg, "%d", &amp;parsed); e == nil </span><span class="cov0" title="0">{
                        if parsed &gt; 0 &amp;&amp; parsed &lt;= 100 </span><span class="cov0" title="0">{ limit = parsed }</span>
                }
        }
        <span class="cov0" title="0">txs, err := h.txClient.ListRecent(ctx, sess.TenantID, limit, sess.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось получить последние транзакции"))
                return
        }</span>
        <span class="cov0" title="0">if len(txs) == 0 </span><span class="cov0" title="0">{
                _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Нет данных"))
                return
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        b.WriteString("Последние транзакции:\n")
        for _, t := range txs </span><span class="cov0" title="0">{
                sign := "-"
                if t.GetType() == pb.TransactionType_TRANSACTION_TYPE_INCOME </span><span class="cov0" title="0">{
                        sign = "+"
                }</span>
                <span class="cov0" title="0">amt := float64(t.GetAmount().GetMinorUnits()) / 100.0
                curr := t.GetAmount().GetCurrencyCode()
                b.WriteString(fmt.Sprintf("- %s%.2f %s %s\n", sign, amt, curr, t.GetComment()))</span>
        }
        <span class="cov0" title="0">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, b.String()))</span>
}

func (h *Handler) handleExport(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
    sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
        return
    }</span>
    // Export current month by default; supports args: YYYY-MM|week [limit]
    <span class="cov0" title="0">now := time.Now()
    from := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
    to := from.AddDate(0, 1, -1)
    limit := 100
    if arg := strings.TrimSpace(update.Message.CommandArguments()); arg != "" </span><span class="cov0" title="0">{
        parts := strings.Fields(arg)
        for _, p := range parts </span><span class="cov0" title="0">{
            if p == "week" </span><span class="cov0" title="0">{
                wd := int(now.Weekday())
                if wd == 0 </span><span class="cov0" title="0">{ wd = 7 }</span>
                <span class="cov0" title="0">from = time.Date(now.Year(), now.Month(), now.Day()-(wd-1), 0, 0, 0, 0, now.Location())
                to = from.AddDate(0, 0, 6)
                continue</span>
            }
            <span class="cov0" title="0">if len(p) == 7 </span><span class="cov0" title="0">{
                var y, m int
                if _, e := fmt.Sscanf(p, "%d-%d", &amp;y, &amp;m); e == nil &amp;&amp; m &gt;= 1 &amp;&amp; m &lt;= 12 </span><span class="cov0" title="0">{
                    from = time.Date(y, time.Month(m), 1, 0, 0, 0, 0, now.Location())
                    to = from.AddDate(0, 1, -1)
                    continue</span>
                }
            }
            <span class="cov0" title="0">var v int
            if _, e := fmt.Sscanf(p, "%d", &amp;v); e == nil </span><span class="cov0" title="0">{
                if v &gt; 0 &amp;&amp; v &lt;= 5000 </span><span class="cov0" title="0">{ limit = v }</span>
            }
        }
    }
    <span class="cov0" title="0">txs, err := h.txClient.ListForExport(ctx, sess.TenantID, from, to, limit, sess.AccessToken)
    if err != nil </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось выгрузить транзакции"))
        return
    }</span>
    <span class="cov0" title="0">var b strings.Builder
    b.WriteString("date,type,amount,currency,category_id,comment\n")
    for _, t := range txs </span><span class="cov0" title="0">{
        dt := t.GetOccurredAt().AsTime().Format("2006-01-02")
        typ := "expense"
        if t.GetType() == pb.TransactionType_TRANSACTION_TYPE_INCOME </span><span class="cov0" title="0">{ typ = "income" }</span>
        <span class="cov0" title="0">amt := float64(t.GetAmount().GetMinorUnits())/100.0
        curr := t.GetAmount().GetCurrencyCode()
        b.WriteString(fmt.Sprintf("%s,%s,%.2f,%s,%s,%s\n", dt, typ, amt, curr, t.GetCategoryId(), strings.ReplaceAll(t.GetComment(), ",", " ")))</span>
    }
    <span class="cov0" title="0">file := tgbotapi.FileBytes{Name: "export.csv", Bytes: []byte(b.String())}
    msg := tgbotapi.NewDocument(update.Message.Chat.ID, file)
    msg.Caption = "Экспорт за текущий месяц"
    _, _ = h.bot.Send(msg)</span>
}

func (h *Handler) handleProfile(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        sess, _ := h.auth.GetSession(ctx, update.Message.From.ID)
        pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
        var b strings.Builder
        b.WriteString("Профиль:\n")
        if sess != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("UserID: %s\nTenantID: %s\n", sess.UserID, sess.TenantID))
        }</span> else<span class="cov8" title="1"> {
                b.WriteString("Не авторизован\n")
        }</span>
        <span class="cov8" title="1">if pref != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("Язык: %s\nВалюта по умолчанию: %s\n", pref.Language, pref.DefaultCurrency))
        }</span>
        <span class="cov8" title="1">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, b.String()))</span>
}


func (h *Handler) handleCreateCategory(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
    sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
        return
    }</span>
    <span class="cov8" title="1">args := strings.TrimSpace(update.Message.CommandArguments())
    if args == "" </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /create_category code название"))
        return
    }</span>
    <span class="cov8" title="1">parts := strings.Fields(args)
    if len(parts) &lt; 2 </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /create_category code название"))
        return
    }</span>
    <span class="cov8" title="1">code := parts[0]
    name := strings.TrimSpace(strings.TrimPrefix(args, code))
    if name == "" </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Укажите название категории"))
        return
    }</span>
    <span class="cov8" title="1">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
    locale := ""
    if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{ locale = pref.Language }</span>
    <span class="cov8" title="1">cat, err := h.categories.CreateCategory(ctx, sess.AccessToken, code, name, locale)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось создать категорию (доступно в сборке withgrpc)"))
        return
    }</span>
    <span class="cov8" title="1">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, fmt.Sprintf("Категория создана: %s (%s)", cat.Name, cat.ID)))</span>
}

func (h *Handler) handleRenameCategory(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
    sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
        return
    }</span>
    <span class="cov8" title="1">args := strings.TrimSpace(update.Message.CommandArguments())
    parts := strings.Fields(args)
    if len(parts) &lt; 2 </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /rename_category category_id новое_название"))
        return
    }</span>
    <span class="cov8" title="1">id := parts[0]
    name := strings.TrimSpace(strings.TrimPrefix(args, id))
    if name == "" </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Укажите новое название"))
        return
    }</span>
    <span class="cov8" title="1">pref, _ := h.prefs.GetPreferences(ctx, update.Message.From.ID)
    locale := ""
    if pref != nil &amp;&amp; pref.Language != "" </span><span class="cov0" title="0">{ locale = pref.Language }</span>
    <span class="cov8" title="1">cat, err := h.categories.UpdateCategoryName(ctx, sess.AccessToken, id, name, locale)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось обновить категорию (доступно в сборке withgrpc)"))
        return
    }</span>
    <span class="cov8" title="1">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, fmt.Sprintf("Категория обновлена: %s (%s)", cat.Name, cat.ID)))</span>
}

func (h *Handler) handleDeleteCategory(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
    sess, err := h.auth.GetSession(ctx, update.Message.From.ID)
    if err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Сначала выполните вход: /login"))
        return
    }</span>
    <span class="cov8" title="1">id := strings.TrimSpace(update.Message.CommandArguments())
    if id == "" </span><span class="cov0" title="0">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Формат: /delete_category category_id"))
        return
    }</span>
    <span class="cov8" title="1">if err := h.categories.DeleteCategory(ctx, sess.AccessToken, id); err != nil </span><span class="cov8" title="1">{
        _, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Не удалось удалить категорию (доступно в сборке withgrpc)"))
        return
    }</span>
    <span class="cov8" title="1">_, _ = h.bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Категория удалена"))</span>
}

func (h *Handler) handleHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        args := strings.TrimSpace(update.Message.CommandArguments())
        
        h.logger.Debug("Help command called", 
                zap.String("text", update.Message.Text),
                zap.String("args", args),
                zap.Int("entities_count", len(update.Message.Entities)))
        
        switch args </span>{
        case "auth", "аутентификация":<span class="cov8" title="1">
                h.showAuthHelp(ctx, update)</span>
        case "transactions", "транзакции":<span class="cov8" title="1">
                h.showTransactionsHelp(ctx, update)</span>
        case "categories", "категории":<span class="cov8" title="1">
                h.showCategoriesHelp(ctx, update)</span>
        case "stats", "статистика":<span class="cov8" title="1">
                h.showStatsHelp(ctx, update)</span>
        case "settings", "настройки":<span class="cov8" title="1">
                h.showSettingsHelp(ctx, update)</span>
        case "admin", "админ":<span class="cov8" title="1">
                h.showAdminHelp(ctx, update)</span>
        default:<span class="cov8" title="1">
                h.showMainHelp(ctx, update)</span>
        }
}

func (h *Handler) showMainHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := "🤖 *Справка по командам бота*\n\n" +
                "Выберите раздел для получения подробной информации:\n\n" +
                "🔐 *Аутентификация* - `/help auth`\n" +
                "Вход, регистрация, управление профилем\n\n" +
                "💰 *Транзакции* - `/help transactions`\n" +
                "Добавление транзакций, форматы сообщений\n\n" +
                "🏷️ *Категории* - `/help categories`\n" +
                "Управление категориями и маппингами\n\n" +
                "📊 *Статистика* - `/help stats`\n" +
                "Отчеты и аналитика\n\n" +
                "⚙️ *Настройки* - `/help settings`\n" +
                "Язык, валюта, профиль\n\n" +
                "👨‍💼 *Админ* - `/help admin`\n" +
                "Управление категориями (только в сборке withgrpc)\n\n" +
                "💡 *Быстрый старт:*\n" +
                "1. /start - Начало работы\n" +
                "2. /login - Вход в систему\n" +
                "3. Отправьте транзакцию: \"1000 продукты\""

        kb := ui.CreateHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showAuthHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := `🔐 *Аутентификация и профиль*

/start - Начало работы
Приветственное сообщение с главным меню

/login - Вход в систему
Запускает OAuth аутентификацию через email

/register - Регистрация
Создание нового аккаунта через OAuth

/logout - Выход из системы
Завершение текущей сессии

/profile - Профиль пользователя
Информация о пользователе, настройки

/switch_tenant - Переключение организации
Выбор организации для работы

💡 *Для начала работы:*
1. /start
2. /login
3. Следуйте инструкциям для авторизации`

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showTransactionsHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := `💰 *Добавление транзакций*

Бот автоматически распознает сообщения в формате транзакций.

*Формат:* ` + "`[дата] [+]сумма[валюта] описание`" + `

*Примеры:*
• ` + "`1000 продукты`" + ` - Расход 1000 в валюте по умолчанию
• ` + "`+50000 зарплата`" + ` - Доход 50000
• ` + "`01.12 5000 подарок`" + ` - Расход с датой
• ` + "`вчера 100 кофе`" + ` - Расход за вчера
• ` + "`1000₽ продукты`" + ` - Расход в рублях
• ` + "`+50000$ зарплата`" + ` - Доход в долларах

*Поддерживаемые даты:*
• ` + "`сегодня`" + `, ` + "`вчера`" + `, ` + "`позавчера`" + `
• ` + "`DD.MM.YYYY`" + ` (например, ` + "`15.12.2023`" + `)
• ` + "`DD.MM`" + ` (например, ` + "`15.12`" + ` - текущий год)

*Поддерживаемые валюты:*
• Символы: ₽, $, €, £, ¥
• Коды: RUB, USD, EUR, GBP, JPY

*Процесс добавления:*
1. Отправьте транзакцию в нужном формате
2. Если категория не найдена автоматически, выберите из списка
3. Подтвердите сохранение`

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showCategoriesHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := "🏷️ *Управление категориями*\n\n" +
                "/categories - Список категорий\n" +
                "Показывает доступные категории для выбора\n\n" +
                "`/map слово = название_категории` - Добавить сопоставление\n" +
                "Создает связь между словом и категорией для автоматической категоризации\n\n" +
                "*Примеры маппингов:*\n" +
                "• `/map кофе = Питание`\n" +
                "• `/map такси = Транспорт`\n" +
                "• `/map продукты = Продукты`\n\n" +
                "`/map слово` - Показать сопоставление\n" +
                "Показывает текущее сопоставление для слова\n\n" +
                "`/map --all` - Показать все сопоставления\n" +
                "Список всех созданных сопоставлений\n\n" +
                "`/unmap слово` - Удалить сопоставление\n" +
                "Удаляет сопоставление для указанного слова\n\n" +
                "*Как работают маппинги:*\n" +
                "1. Бот ищет точные совпадения ключевых слов\n" +
                "2. Если не найдено, ищет частичные совпадения\n" +
                "3. При нескольких совпадениях выбирает с наивысшим приоритетом\n\n" +
                "💡 *Совет:* Создайте маппинги для часто используемых слов"

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showStatsHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := "📊 *Статистика и отчеты*\n\n" +
                "`/stats [период]` - Общая статистика\n" +
                "Показывает доходы и расходы за период\n\n" +
                "*Варианты периода:*\n" +
                "• /stats - Текущий месяц\n" +
                "• `/stats 2023-12` - Конкретный месяц (YYYY-MM)\n" +
                "• `/stats week` - Текущая неделя\n\n" +
                "`/top_categories [период] [лимит]` - Топ категорий\n" +
                "Показывает категории с наибольшими расходами\n\n" +
                "*Примеры:*\n" +
                "• /top_categories - Топ-5 за текущий месяц\n" +
                "• `/top_categories 2023-12` - Топ-5 за декабрь 2023\n" +
                "• `/top_categories week 10` - Топ-10 за неделю\n\n" +
                "`/recent [лимит]` - Последние транзакции\n" +
                "Показывает последние транзакции\n\n" +
                "*Примеры:*\n" +
                "• /recent - Последние 10 транзакций\n" +
                "• `/recent 20` - Последние 20 транзакций\n\n" +
                "`/export [период] [лимит]` - Экспорт данных\n" +
                "Экспортирует транзакции в CSV формат\n\n" +
                "*Примеры:*\n" +
                "• /export - Экспорт за текущий месяц\n" +
                "• `/export 2023-12` - Экспорт за декабрь 2023\n" +
                "• `/export week 100` - Экспорт 100 транзакций за неделю"

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showSettingsHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := `⚙️ *Настройки*

/language - Выбор языка
Показывает клавиатуру для выбора языка интерфейса
• 🇷🇺 Русский
• 🇺🇸 English

/currency - Настройка валюты
Показывает клавиатуру для выбора валюты по умолчанию
• ₽ RUB
• $ USD
• € EUR
• £ GBP
• ¥ JPY

/profile - Профиль пользователя
Показывает информацию о пользователе:
• UserID и TenantID
• Язык интерфейса
• Валюта по умолчанию
• Статус авторизации

/settings - Общие настройки
Аналогично /profile

💡 *Рекомендации:*
• Установите удобный язык интерфейса
• Выберите основную валюту для транзакций
• Регулярно проверяйте профиль`

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

func (h *Handler) showAdminHelp(ctx context.Context, update tgbotapi.Update) <span class="cov8" title="1">{
        text := "👨‍💼 *Административные команды*\n\n" +
                "*Доступно только в сборке withgrpc*\n\n" +
                "`/create_category code название` - Создать категорию\n" +
                "Создает новую категорию в системе\n\n" +
                "*Пример:*\n" +
                "• `/create_category cat-entertainment Развлечения`\n\n" +
                "`/rename_category category_id новое_название` - Переименовать категорию\n" +
                "Изменяет название существующей категории\n\n" +
                "*Пример:*\n" +
                "• `/rename_category cat-food Еда и напитки`\n\n" +
                "`/delete_category category_id` - Удалить категорию\n" +
                "Удаляет категорию из системы\n\n" +
                "*Пример:*\n" +
                "• `/delete_category cat-old-category`\n\n" +
                "⚠️ *Внимание:* Эти команды доступны только в специальной сборке бота с поддержкой gRPC.\n\n" +
                "💡 *Для обычных пользователей:*\n" +
                "Используйте команды /categories и /map для работы с категориями"

        kb := ui.CreateBackToHelpKeyboard()
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, text)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = kb
        _, _ = h.bot.Send(msg)
}</span>

</pre>
		
		<pre class="file" id="file8" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"
        "fmt"
        "time"

        pb "budget-bot/internal/pb/budget/v1"
        "budget-bot/internal/repository"
        grpcclient "budget-bot/internal/grpc"
        "go.uber.org/zap"
)



// OAuthManager coordinates OAuth flows and session persistence.
type OAuthManager struct {
        oauthClient  grpcclient.OAuthClient
        sessionRepo  repository.SessionRepository
        logger       *zap.Logger
        webBaseURL   string
}

// NewOAuthManager constructs an OAuthManager.
func NewOAuthManager(oauthClient grpcclient.OAuthClient, sessionRepo repository.SessionRepository, logger *zap.Logger, webBaseURL string) *OAuthManager <span class="cov8" title="1">{
        return &amp;OAuthManager{
                oauthClient: oauthClient,
                sessionRepo: sessionRepo,
                logger:      logger,
                webBaseURL:  webBaseURL,
        }
}</span>

// GenerateAuthLink generates an OAuth authorization link for the user.
func (om *OAuthManager) GenerateAuthLink(ctx context.Context, telegramID int64, email, userAgent, ipAddress string) (string, string, time.Time, error) <span class="cov8" title="1">{
        om.logger.Info("Generating OAuth auth link",
                zap.Int64("telegramID", telegramID),
                zap.String("email", email),
                zap.String("ipAddress", ipAddress))

        authURL, authToken, expiresAt, err := om.oauthClient.GenerateAuthLink(ctx, email, telegramID, userAgent, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to generate auth link",
                        zap.Int64("telegramID", telegramID),
                        zap.String("email", email),
                        zap.Error(err))
                return "", "", time.Time{}, fmt.Errorf("failed to generate auth link: %w", err)
        }</span>

        <span class="cov8" title="1">om.logger.Info("Auth link generated successfully",
                zap.Int64("telegramID", telegramID),
                zap.String("email", email),
                zap.Time("expiresAt", expiresAt))

        return authURL, authToken, expiresAt, nil</span>
}

// VerifyAuthCode verifies the OAuth verification code and creates a session.
func (om *OAuthManager) VerifyAuthCode(ctx context.Context, telegramID int64, authToken, verificationCode string) error <span class="cov8" title="1">{
        om.logger.Info("Verifying OAuth auth code",
                zap.Int64("telegramID", telegramID),
                zap.String("authToken", authToken),
                zap.String("verificationCode", verificationCode))

        result, err := om.oauthClient.VerifyAuthCode(ctx, authToken, verificationCode, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to verify auth code",
                        zap.Int64("telegramID", telegramID),
                        zap.String("authToken", authToken),
                        zap.String("verificationCode", verificationCode),
                        zap.Error(err))
                return fmt.Errorf("failed to verify auth code: %w", err)
        }</span>

        <span class="cov8" title="1">om.logger.Info("Received successful response from gRPC",
                zap.Int64("telegramID", telegramID),
                zap.String("sessionID", result.SessionID),
                zap.String("userID", result.User.Id),
                zap.String("accessToken", result.Tokens.AccessToken[:10]+"..."), // Логируем только первые 10 символов токена
                zap.String("refreshToken", result.Tokens.RefreshToken[:10]+"..."),
                zap.Int("membershipsCount", len(result.Memberships)))

        // Determine default tenant from memberships
        var defaultTenantID string
        if len(result.Memberships) &gt; 0 </span><span class="cov8" title="1">{
                defaultTenantID = result.Memberships[0].Tenant.Id
                om.logger.Info("Using default tenant from memberships",
                        zap.String("tenantID", defaultTenantID))
        }</span>

        // Save session to local database
        <span class="cov8" title="1">session := &amp;repository.UserSession{
                TelegramID:            telegramID,
                UserID:                result.User.Id,
                TenantID:              defaultTenantID,
                AccessToken:           result.Tokens.AccessToken,
                RefreshToken:          result.Tokens.RefreshToken,
                AccessTokenExpiresAt:  result.Tokens.AccessTokenExpiresAt.AsTime(),
                RefreshTokenExpiresAt: result.Tokens.RefreshTokenExpiresAt.AsTime(),
        }

        if err := om.sessionRepo.SaveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to save session",
                        zap.Int64("telegramID", telegramID),
                        zap.String("sessionID", result.SessionID),
                        zap.Error(err))
                return fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov8" title="1">om.logger.Info("Auth code verified successfully",
                zap.Int64("telegramID", telegramID),
                zap.String("sessionID", result.SessionID),
                zap.String("userID", result.User.Id),
                zap.String("tenantID", defaultTenantID))

        return nil</span>
}

// CancelAuth cancels the OAuth authorization process.
func (om *OAuthManager) CancelAuth(ctx context.Context, telegramID int64, authToken string) error <span class="cov0" title="0">{
        om.logger.Info("Cancelling OAuth auth",
                zap.Int64("telegramID", telegramID),
                zap.String("authToken", authToken))

        err := om.oauthClient.CancelAuth(ctx, authToken, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to cancel auth",
                        zap.Int64("telegramID", telegramID),
                        zap.String("authToken", authToken),
                        zap.Error(err))
                return fmt.Errorf("failed to cancel auth: %w", err)
        }</span>

        <span class="cov0" title="0">om.logger.Info("Auth cancelled successfully",
                zap.Int64("telegramID", telegramID))

        return nil</span>
}

// GetAuthStatus gets the status of an OAuth authorization.
func (om *OAuthManager) GetAuthStatus(ctx context.Context, authToken string) (string, string, time.Time, error) <span class="cov0" title="0">{
        status, email, expiresAt, err := om.oauthClient.GetAuthStatus(ctx, authToken)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to get auth status",
                        zap.String("authToken", authToken),
                        zap.Error(err))
                return "", "", time.Time{}, fmt.Errorf("failed to get auth status: %w", err)
        }</span>

        <span class="cov0" title="0">return status, email, expiresAt, nil</span>
}

// GetSession returns current session for a user.
func (om *OAuthManager) GetSession(ctx context.Context, telegramID int64) (*repository.UserSession, error) <span class="cov8" title="1">{
        session, err := om.sessionRepo.GetSession(ctx, telegramID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        

        
        <span class="cov8" title="1">return session, nil</span>
}



// Logout removes stored session for a user.
func (om *OAuthManager) Logout(ctx context.Context, telegramID int64) error <span class="cov8" title="1">{
        om.logger.Info("Logging out user",
                zap.Int64("telegramID", telegramID))

        err := om.sessionRepo.DeleteSession(ctx, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to delete session",
                        zap.Int64("telegramID", telegramID),
                        zap.Error(err))
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        <span class="cov8" title="1">om.logger.Info("User logged out successfully",
                zap.Int64("telegramID", telegramID))

        return nil</span>
}

// ListSessions lists all sessions for a user.
func (om *OAuthManager) ListSessions(ctx context.Context, telegramID int64) ([]*pb.TelegramSession, error) <span class="cov8" title="1">{
        sessions, err := om.oauthClient.ListTelegramSessions(ctx, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to list sessions",
                        zap.Int64("telegramID", telegramID),
                        zap.Error(err))
                return nil, fmt.Errorf("failed to list sessions: %w", err)
        }</span>

        <span class="cov8" title="1">return sessions, nil</span>
}

// RevokeSession revokes a specific session.
func (om *OAuthManager) RevokeSession(ctx context.Context, telegramID int64, sessionID string) error <span class="cov0" title="0">{
        om.logger.Info("Revoking session",
                zap.Int64("telegramID", telegramID),
                zap.String("sessionID", sessionID))

        err := om.oauthClient.RevokeTelegramSession(ctx, sessionID, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to revoke session",
                        zap.Int64("telegramID", telegramID),
                        zap.String("sessionID", sessionID),
                        zap.Error(err))
                return fmt.Errorf("failed to revoke session: %w", err)
        }</span>

        <span class="cov0" title="0">om.logger.Info("Session revoked successfully",
                zap.Int64("telegramID", telegramID),
                zap.String("sessionID", sessionID))

        return nil</span>
}

// GetAuthLogs gets authentication logs for a user.
func (om *OAuthManager) GetAuthLogs(ctx context.Context, telegramID int64, limit, offset int32) ([]*pb.AuthLogEntry, int32, error) <span class="cov8" title="1">{
        logs, totalCount, err := om.oauthClient.GetAuthLogs(ctx, telegramID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                om.logger.Error("Failed to get auth logs",
                        zap.Int64("telegramID", telegramID),
                        zap.Error(err))
                return nil, 0, fmt.Errorf("failed to get auth logs: %w", err)
        }</span>

        <span class="cov8" title="1">return logs, totalCount, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "budget-bot/internal/domain"
)

// MessageParser parses free-form text into structured transactions.
type MessageParser struct{ currency *CurrencyParser }

// ValidationError describes invalid user input.
type ValidationError struct {
        Field   string
        Message string
}

// ParsedTransaction is a result of parsing a message text.
type ParsedTransaction struct {
        Type        domain.TransactionType
        Amount      *domain.Money
        Currency    string
        Description string
        OccurredAt  *time.Time
        IsValid     bool
        Errors      []string
}

// NewMessageParser constructs a MessageParser with default currency parser.
func NewMessageParser() *MessageParser <span class="cov8" title="1">{ return &amp;MessageParser{currency: NewCurrencyParser()} }</span>

var (
        amountRe   = regexp.MustCompile(`(?i)([+\-]?\d+[\.,]?\d*)`)
        dateDDMMYY = regexp.MustCompile(`\b(\d{1,2})[\./](\d{1,2})(?:[\./](\d{2,4}))?\b`)
)

// ParseMessage converts input text into a ParsedTransaction.
func (p *MessageParser) ParseMessage(text string) (*ParsedTransaction, error) <span class="cov8" title="1">{
        original := strings.TrimSpace(text)
        result := &amp;ParsedTransaction{IsValid: false}
        if original == "" </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, "empty message")
                return result, nil
        }</span>

        // Date parsing: today/yesterday/day before yesterday
        <span class="cov8" title="1">lower := strings.ToLower(original)
        now := time.Now()
        if strings.Contains(lower, "сегодня") </span><span class="cov8" title="1">{
                localTime := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
                utcTime := localTime.UTC()
                result.OccurredAt = &amp;utcTime
                lower = strings.ReplaceAll(lower, "сегодня", "")
        }</span> else<span class="cov8" title="1"> if strings.Contains(lower, "вчера") </span><span class="cov8" title="1">{
                localTime := now.AddDate(0, 0, -1)
                localTime = time.Date(localTime.Year(), localTime.Month(), localTime.Day(), 0, 0, 0, 0, localTime.Location())
                utcTime := localTime.UTC()
                result.OccurredAt = &amp;utcTime
                lower = strings.ReplaceAll(lower, "вчера", "")
        }</span> else<span class="cov8" title="1"> if strings.Contains(lower, "позавчера") </span><span class="cov0" title="0">{
                localTime := now.AddDate(0, 0, -2)
                localTime = time.Date(localTime.Year(), localTime.Month(), localTime.Day(), 0, 0, 0, 0, localTime.Location())
                utcTime := localTime.UTC()
                result.OccurredAt = &amp;utcTime
                lower = strings.ReplaceAll(lower, "позавчера", "")
        }</span>

        // DD.MM(.YYYY)
        <span class="cov8" title="1">if m := dateDDMMYY.FindStringSubmatch(lower); len(m) &gt; 0 </span><span class="cov8" title="1">{
                day, _ := strconv.Atoi(m[1])
                mon, _ := strconv.Atoi(m[2])
                year := now.Year()
                if m[3] != "" </span><span class="cov8" title="1">{
                        y, _ := strconv.Atoi(m[3])
                        if y &lt; 100 </span><span class="cov0" title="0">{ // YY -&gt; 20YY heuristic
                                y = 2000 + y
                        }</span>
                        <span class="cov8" title="1">year = y</span>
                }
                <span class="cov8" title="1">if day &gt;= 1 &amp;&amp; day &lt;= 31 &amp;&amp; mon &gt;= 1 &amp;&amp; mon &lt;= 12 </span><span class="cov8" title="1">{
                        // Create time in local timezone first, then convert to UTC
                        // This ensures that "01.08" always means August 1st in user's timezone
                        localTime := time.Date(year, time.Month(mon), day, 0, 0, 0, 0, now.Location())
                        utcTime := localTime.UTC()
                        result.OccurredAt = &amp;utcTime
                        lower = strings.Replace(lower, m[0], "", 1)
                }</span>
        }

        // Currency (optional)
        <span class="cov8" title="1">if code, _, cleaned := p.currency.ParseCurrency(lower); code != "" </span><span class="cov8" title="1">{
                result.Currency = code
                lower = cleaned
        }</span>

        // Amount (+/-) and type inference from the matched token
        <span class="cov8" title="1">if m := amountRe.FindStringSubmatch(lower); len(m) &gt; 0 </span><span class="cov8" title="1">{
                token := strings.TrimSpace(m[1])
                var sign int64 = 1
                if strings.HasPrefix(token, "-") </span><span class="cov8" title="1">{
                        sign = -1
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(token, "+") </span><span class="cov8" title="1">{
                        sign = 1
                }</span>
                <span class="cov8" title="1">numeric := strings.ReplaceAll(token, ",", ".")
                numericAbs := strings.TrimLeft(numeric, "+-")
                if strings.Contains(numericAbs, ".") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(numericAbs, ".", 2)
                        wholeAbs, _ := strconv.ParseInt(parts[0], 10, 64)
                        frac := parts[1]
                        if len(frac) == 1 </span><span class="cov8" title="1">{
                                frac = frac + "0"
                        }</span>
                        <span class="cov8" title="1">if len(frac) &gt; 2 </span><span class="cov8" title="1">{
                                frac = frac[:2]
                        }</span>
                        <span class="cov8" title="1">minorAbs, _ := strconv.ParseInt(frac, 10, 64)
                        amountMinor := (wholeAbs*100)+minorAbs
                        result.Amount = domain.NewMoney(amountMinor, result.Currency)</span>
                } else<span class="cov8" title="1"> {
                        wholeAbs, _ := strconv.ParseInt(numericAbs, 10, 64)
                        result.Amount = domain.NewMoney(wholeAbs*100, result.Currency)
                }</span>
                <span class="cov8" title="1">lower = strings.Replace(lower, m[0], "", 1)

                // Determine type by sign; default to expense
                if sign &lt; 0 </span><span class="cov8" title="1">{
                        result.Type = domain.TransactionExpense
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(token, "+") </span><span class="cov8" title="1">{
                        result.Type = domain.TransactionIncome
                }</span> else<span class="cov8" title="1"> {
                        result.Type = domain.TransactionExpense
                }</span>
        }

        // Remaining text as description
        <span class="cov8" title="1">desc := strings.TrimSpace(lower)
        result.Description = desc

        // Validate
        verrs := p.Validate(result)
        if len(verrs) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range verrs </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, e.Field+": "+e.Message)
                }</span>
                <span class="cov8" title="1">result.IsValid = false</span>
        } else<span class="cov8" title="1"> {
                result.IsValid = true
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// Validate performs basic validation of the parsed transaction.
func (p *MessageParser) Validate(parsed *ParsedTransaction) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError
        if parsed == nil </span><span class="cov0" title="0">{
                return []ValidationError{{Field: "_", Message: "nil parsed transaction"}}
        }</span>
        <span class="cov8" title="1">if parsed.Amount == nil || parsed.Amount.AmountMinor == 0 </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{Field: "amount", Message: "not found"})
        }</span>
        <span class="cov8" title="1">if parsed.Currency != "" &amp;&amp; !p.currency.ValidateCurrency(parsed.Currency) </span><span class="cov0" title="0">{
                errs = append(errs, ValidationError{Field: "currency", Message: "invalid"})
        }</span>
        <span class="cov8" title="1">return errs</span>
}


</pre>
		
		<pre class="file" id="file10" style="display: none">// Package bot contains the core Telegram bot business logic.
package bot

import (
        "context"

        "budget-bot/internal/repository"
        "go.uber.org/zap"
)

// StateManager manages dialog states.
type StateManager struct {
        stateRepo repository.DialogStateRepository
        logger   *zap.Logger
}

// NewStateManager constructs a StateManager.
func NewStateManager(repo repository.DialogStateRepository, logger *zap.Logger) *StateManager <span class="cov8" title="1">{
        return &amp;StateManager{stateRepo: repo, logger: logger}
}</span>

// SetState sets a dialog state with optional context.
func (s *StateManager) SetState(ctx context.Context, telegramID int64, state repository.DialogState, context map[string]any) error <span class="cov8" title="1">{
        return s.stateRepo.SetState(ctx, telegramID, state, context, nil)
}</span>

// GetState returns current dialog state.
func (s *StateManager) GetState(ctx context.Context, telegramID int64) (*repository.DialogStateRecord, error) <span class="cov8" title="1">{
        return s.stateRepo.GetState(ctx, telegramID)
}</span>

// ClearState clears dialog state for a user.
func (s *StateManager) ClearState(ctx context.Context, telegramID int64) error <span class="cov8" title="1">{
        return s.stateRepo.ClearState(ctx, telegramID)
}</span>


</pre>
		
		<pre class="file" id="file11" style="display: none">package bot

import (
        "context"
        "time"

        grpcclient "budget-bot/internal/grpc"
        pb "budget-bot/internal/pb/budget/v1"
)

// TestOAuthClient is a fake OAuth client for testing
type TestOAuthClient struct{}

func (f *TestOAuthClient) GenerateAuthLink(ctx context.Context, email string, telegramUserID int64, userAgent, ipAddress string) (string, string, time.Time, error) <span class="cov8" title="1">{
        return "https://example.com/auth", "auth_token", time.Now().Add(5*time.Minute), nil
}</span>

func (f *TestOAuthClient) VerifyAuthCode(ctx context.Context, authToken, verificationCode string, telegramUserID int64) (*grpcclient.VerifyAuthCodeResult, error) <span class="cov8" title="1">{
        return &amp;grpcclient.VerifyAuthCodeResult{
                Tokens: &amp;pb.TokenPair{
                        AccessToken:           "access_token",
                        RefreshToken:          "refresh_token",
                        AccessTokenExpiresAt:  nil,
                        RefreshTokenExpiresAt: nil,
                        TokenType:             "Bearer",
                },
                SessionID: "session_id",
                User: &amp;pb.User{
                        Id:    "test_user_id",
                        Email: "test@example.com",
                },
                Memberships: []*pb.TenantMembership{
                        {
                                Tenant: &amp;pb.Tenant{
                                        Id: "test_tenant_id",
                                },
                                Role: pb.TenantRole_TENANT_ROLE_OWNER,
                        },
                },
        }, nil
}</span>

func (f *TestOAuthClient) CancelAuth(ctx context.Context, authToken string, telegramUserID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *TestOAuthClient) GetAuthStatus(ctx context.Context, authToken string) (string, string, time.Time, error) <span class="cov0" title="0">{
        return "completed", "test@example.com", time.Now().Add(5*time.Minute), nil
}</span>

func (f *TestOAuthClient) GetTelegramSession(ctx context.Context, sessionID string) (*pb.GetTelegramSessionResponse, error) <span class="cov0" title="0">{
        return &amp;pb.GetTelegramSessionResponse{
                Session: &amp;pb.TelegramSession{
                        SessionId:        sessionID,
                        UserId:           "user_id",
                        TelegramUserId:   "12345",
                        TenantId:         "tenant_id",
                        CreatedAt:        nil,
                        ExpiresAt:        nil,
                        IsActive:         true,
                },
                User:   nil,
                Tenant: nil,
        }, nil
}</span>

func (f *TestOAuthClient) RevokeTelegramSession(ctx context.Context, sessionID string, telegramUserID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *TestOAuthClient) ListTelegramSessions(ctx context.Context, telegramUserID int64) ([]*pb.TelegramSession, error) <span class="cov0" title="0">{
        return []*pb.TelegramSession{}, nil
}</span>

func (f *TestOAuthClient) GetAuthLogs(ctx context.Context, telegramUserID int64, limit, offset int32) ([]*pb.AuthLogEntry, int32, error) <span class="cov0" title="0">{
        return []*pb.AuthLogEntry{}, 0, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package ui contains helpers to build Telegram reply/inline keyboards.
package ui

import (
    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
    "budget-bot/internal/domain"
    grpcclient "budget-bot/internal/grpc"
)

// CreateCategoryKeyboard builds an inline keyboard for categories.
func CreateCategoryKeyboard(categories []*domain.Category) tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    var rows [][]tgbotapi.InlineKeyboardButton
    for _, c := range categories </span><span class="cov8" title="1">{
        btn := tgbotapi.NewInlineKeyboardButtonData(c.Emoji+" "+c.Name, "cat:"+c.Name)
        rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
    }</span>
    <span class="cov8" title="1">return tgbotapi.NewInlineKeyboardMarkup(rows...)</span>
}

// CreateConfirmationKeyboard builds Yes/No inline keyboard.
func CreateConfirmationKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    yes := tgbotapi.NewInlineKeyboardButtonData("✅ Подтвердить", "confirm:yes")
    no := tgbotapi.NewInlineKeyboardButtonData("❌ Отмена", "confirm:no")
    return tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(yes, no),
    )
}</span>

// CreateLanguageKeyboard builds language selection keyboard.
func CreateLanguageKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    ru := tgbotapi.NewInlineKeyboardButtonData("🇷🇺 Русский", "lang:ru")
    en := tgbotapi.NewInlineKeyboardButtonData("🇺🇸 English", "lang:en")
    return tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(ru, en))
}</span>

// CreateCurrencyKeyboard builds default currency selection keyboard.
func CreateCurrencyKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    rub := tgbotapi.NewInlineKeyboardButtonData("₽ RUB", "cur:RUB")
    usd := tgbotapi.NewInlineKeyboardButtonData("$ USD", "cur:USD")
    eur := tgbotapi.NewInlineKeyboardButtonData("€ EUR", "cur:EUR")
    gbp := tgbotapi.NewInlineKeyboardButtonData("£ GBP", "cur:GBP")
    jpy := tgbotapi.NewInlineKeyboardButtonData("¥ JPY", "cur:JPY")
    return tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(rub, usd, eur),
        tgbotapi.NewInlineKeyboardRow(gbp, jpy),
    )
}</span>

// CreateTenantKeyboard builds a tenant selection keyboard.
func CreateTenantKeyboard(items []*grpcclient.Tenant) tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    var rows [][]tgbotapi.InlineKeyboardButton
    for _, t := range items </span><span class="cov8" title="1">{
        btn := tgbotapi.NewInlineKeyboardButtonData(t.Name, "tenant:"+t.ID)
        rows = append(rows, tgbotapi.NewInlineKeyboardRow(btn))
    }</span>
    <span class="cov8" title="1">return tgbotapi.NewInlineKeyboardMarkup(rows...)</span>
}

// CreateMainMenuKeyboard builds the main menu keyboard.
func CreateMainMenuKeyboard() tgbotapi.ReplyKeyboardMarkup <span class="cov8" title="1">{
    row1 := tgbotapi.NewKeyboardButtonRow(
        tgbotapi.NewKeyboardButton("/stats"),
        tgbotapi.NewKeyboardButton("/recent"),
        tgbotapi.NewKeyboardButton("/top_categories"),
    )
    row2 := tgbotapi.NewKeyboardButtonRow(
        tgbotapi.NewKeyboardButton("/categories"),
        tgbotapi.NewKeyboardButton("/profile"),
        tgbotapi.NewKeyboardButton("/help"),
    )
    kb := tgbotapi.NewReplyKeyboard(row1, row2)
    kb.ResizeKeyboard = true
    kb.Selective = true
    return kb
}</span>

// CreateHelpKeyboard builds the main help menu keyboard.
func CreateHelpKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    auth := tgbotapi.NewInlineKeyboardButtonData("🔐 Аутентификация", "help:auth")
    transactions := tgbotapi.NewInlineKeyboardButtonData("💰 Транзакции", "help:transactions")
    categories := tgbotapi.NewInlineKeyboardButtonData("🏷️ Категории", "help:categories")
    stats := tgbotapi.NewInlineKeyboardButtonData("📊 Статистика", "help:stats")
    settings := tgbotapi.NewInlineKeyboardButtonData("⚙️ Настройки", "help:settings")
    admin := tgbotapi.NewInlineKeyboardButtonData("👨‍💼 Админ", "help:admin")
    
    return tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(auth, transactions),
        tgbotapi.NewInlineKeyboardRow(categories, stats),
        tgbotapi.NewInlineKeyboardRow(settings, admin),
    )
}</span>

// CreateBackToHelpKeyboard builds a keyboard with back button.
func CreateBackToHelpKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
    back := tgbotapi.NewInlineKeyboardButtonData("🔙 Назад к справке", "help:")
    
    return tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(back),
    )
}</span>


</pre>
		
		<pre class="file" id="file13" style="display: none">// Package ui contains helpers to format messages and build keyboards.
package ui

import (
        "fmt"

        "budget-bot/internal/domain"
)

// MessageFormatter provides helpers to format bot messages.
type MessageFormatter struct{}

// NewMessageFormatter constructs a MessageFormatter.
func NewMessageFormatter() *MessageFormatter <span class="cov8" title="1">{ return &amp;MessageFormatter{} }</span>

// FormatMoney renders money from minor units with currency code, e.g., 1234 RUB.
func (mf *MessageFormatter) FormatMoney(amountMinor int64, currency string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%.2f %s", float64(amountMinor)/100.0, currency)
}</span>

// FormatStats renders a compact stats summary.
func (mf *MessageFormatter) FormatStats(stats *domain.Stats) string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Статистика %s\nДоход: %s\nРасход: %s",
                stats.Period,
                mf.FormatMoney(stats.TotalIncome, stats.Currency),
                mf.FormatMoney(stats.TotalExpense, stats.Currency),
        )
}</span>

// FormatCategoriesList renders a simple categories list.
func (mf *MessageFormatter) FormatCategoriesList(categories []*domain.Category) string <span class="cov8" title="1">{
        if len(categories) == 0 </span><span class="cov0" title="0">{
                return "Категорий нет"
        }</span>
        <span class="cov8" title="1">result := "Категории:\n"
        for _, c := range categories </span><span class="cov8" title="1">{
                result += fmt.Sprintf("%s %s\n", c.Emoji, c.Name)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// FormatTransactionLine renders a one-line transaction entry.
func (mf *MessageFormatter) FormatTransactionLine(sign string, amountMinor int64, currency, comment string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %.2f %s %s", sign, float64(amountMinor)/100.0, currency, comment)
}</span>


</pre>
		
		<pre class="file" id="file14" style="display: none">package domain

// Money stores value in minor units (e.g., cents) with an associated ISO currency code.
type Money struct {
        AmountMinor  int64
        CurrencyCode string
}

// NewMoney constructs Money from minor units and ISO currency code.
func NewMoney(minor int64, code string) *Money <span class="cov0" title="0">{
        return &amp;Money{AmountMinor: minor, CurrencyCode: code}
}</span>


</pre>
		
		<pre class="file" id="file15" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
        "context"
        "time"

        pb "budget-bot/internal/pb/budget/v1"
        "go.uber.org/zap"
)

// AuthClient wraps the gRPC Auth service with helper methods.
type AuthClient struct {
        client pb.AuthServiceClient
        log    *zap.Logger
}

// NewAuthClient constructs an AuthClient.
func NewAuthClient(client pb.AuthServiceClient, log *zap.Logger) *AuthClient <span class="cov8" title="1">{
        return &amp;AuthClient{client: client, log: log}
}</span>

// Register registers a new user and returns ids and token expirations.
func (a *AuthClient) Register(ctx context.Context, email, password, name string) (string, string, string, string, time.Time, time.Time, error) <span class="cov8" title="1">{
        res, err := a.client.Register(ctx, &amp;pb.RegisterRequest{Email: email, Password: password, Name: name})
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", time.Time{}, time.Time{}, err
        }</span>
        <span class="cov8" title="1">userID := ""
        tenantID := ""
        if res.User != nil </span><span class="cov8" title="1">{
                userID = res.User.Id
        }</span>
        <span class="cov8" title="1">if res.Tenant != nil </span><span class="cov8" title="1">{
                tenantID = res.Tenant.Id
        }</span>
        <span class="cov8" title="1">tokens := res.Tokens
        return userID, tenantID, tokens.AccessToken, tokens.RefreshToken, tokens.AccessTokenExpiresAt.AsTime(), tokens.RefreshTokenExpiresAt.AsTime(), nil</span>
}

// Login authenticates and returns ids and token expirations.
func (a *AuthClient) Login(ctx context.Context, email, password string) (string, string, string, string, time.Time, time.Time, error) <span class="cov8" title="1">{
        res, err := a.client.Login(ctx, &amp;pb.LoginRequest{Email: email, Password: password})
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", time.Time{}, time.Time{}, err
        }</span>
        <span class="cov8" title="1">tokens := res.Tokens
        tenantID := ""
        for _, m := range res.Memberships </span><span class="cov8" title="1">{
                if m.IsDefault </span><span class="cov8" title="1">{
                        tenantID = m.Tenant.Id
                        break</span>
                }
        }
        <span class="cov8" title="1">if tenantID == "" &amp;&amp; len(res.Memberships) &gt; 0 </span><span class="cov0" title="0">{
                tenantID = res.Memberships[0].Tenant.Id
        }</span>
        <span class="cov8" title="1">return "", tenantID, tokens.AccessToken, tokens.RefreshToken, tokens.AccessTokenExpiresAt.AsTime(), tokens.RefreshTokenExpiresAt.AsTime(), nil</span>
}

// RefreshToken exchanges refresh token for a new access/refresh pair.
func (a *AuthClient) RefreshToken(ctx context.Context, refreshToken string) (string, string, time.Time, time.Time, error) <span class="cov8" title="1">{
        res, err := a.client.RefreshToken(ctx, &amp;pb.RefreshTokenRequest{RefreshToken: refreshToken})
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, time.Time{}, err
        }</span>
        <span class="cov8" title="1">tokens := res.Tokens
        return tokens.AccessToken, tokens.RefreshToken, tokens.AccessTokenExpiresAt.AsTime(), tokens.RefreshTokenExpiresAt.AsTime(), nil</span>
}


</pre>
		
		<pre class="file" id="file16" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
        "context"
        "fmt"
        "math"

        pb "budget-bot/internal/pb/budget/v1"
        "budget-bot/internal/domain"
        "google.golang.org/grpc/metadata"
        "go.uber.org/zap"
)

// CategoryClient exposes category operations.
type CategoryClient interface {
    ListCategories(ctx context.Context, tenantID string, accessToken string, transactionType domain.TransactionType, locale ...string) ([]*domain.Category, error)
    CreateCategory(ctx context.Context, accessToken string, code string, name string, locale string) (*domain.Category, error)
    UpdateCategoryName(ctx context.Context, accessToken string, id string, name string, locale string) (*domain.Category, error)
    DeleteCategory(ctx context.Context, accessToken string, id string) error
}

// StaticCategoryClient is a temporary implementation returning fixed categories.
// StaticCategoryClient is a temporary implementation returning fixed categories.
type StaticCategoryClient struct{}

// ListCategories returns a static list of categories.
func (s *StaticCategoryClient) ListCategories(_ context.Context, _ string, _ string, transactionType domain.TransactionType, _ ...string) ([]*domain.Category, error) <span class="cov0" title="0">{
    if transactionType == domain.TransactionIncome </span><span class="cov0" title="0">{
        return []*domain.Category{
            {ID: "cat-salary", Name: "Зарплата", Emoji: "💰"},
            {ID: "cat-bonus", Name: "Премия", Emoji: "🎁"},
            {ID: "cat-investment", Name: "Инвестиции", Emoji: "📈"},
            {ID: "cat-other-income", Name: "Другое", Emoji: "💵"},
        }, nil
    }</span>
    // Default to expense categories
    <span class="cov0" title="0">return []*domain.Category{
        {ID: "cat-food", Name: "Питание", Emoji: "🍽️"},
        {ID: "cat-transport", Name: "Транспорт", Emoji: "🚗"},
        {ID: "cat-home", Name: "Дом", Emoji: "🏠"},
        {ID: "cat-other", Name: "Другое", Emoji: "🎯"},
    }, nil</span>
}

// CreateCategory is unsupported in static client.
func (s *StaticCategoryClient) CreateCategory(_ context.Context, _ string, _ string, _ string, _ string) (*domain.Category, error) <span class="cov0" title="0">{
    return nil, fmt.Errorf("category creation not supported without gRPC")
}</span>

// UpdateCategoryName is unsupported in static client.
func (s *StaticCategoryClient) UpdateCategoryName(_ context.Context, _ string, _ string, _ string, _ string) (*domain.Category, error) <span class="cov0" title="0">{
    return nil, fmt.Errorf("category update not supported without gRPC")
}</span>

// DeleteCategory is unsupported in static client.
func (s *StaticCategoryClient) DeleteCategory(_ context.Context, _ string, _ string) error <span class="cov0" title="0">{
    return fmt.Errorf("category delete not supported without gRPC")
}</span>

// CategoryGRPCClient calls Category service via gRPC.
type CategoryGRPCClient struct{
    client pb.CategoryServiceClient
    logger *zap.Logger
}

// NewGRPCCategoryClient constructs a CategoryGRPCClient.
func NewGRPCCategoryClient(c pb.CategoryServiceClient, logger *zap.Logger) *CategoryGRPCClient <span class="cov8" title="1">{ 
    return &amp;CategoryGRPCClient{client: c, logger: logger} 
}</span>

// ListCategories returns categories with optional locale translation.
func (g *CategoryGRPCClient) ListCategories(ctx context.Context, _ string, accessToken string, transactionType domain.TransactionType, locale ...string) ([]*domain.Category, error) <span class="cov8" title="1">{
    g.logger.Debug("ListCategories request", 
        zap.String("transactionType", string(transactionType)),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."),
        zap.Strings("locale", locale))
    
    if accessToken != "" </span><span class="cov8" title="1">{
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken)
    }</span>
    
    // Determine category kind based on transaction type
    <span class="cov8" title="1">var kind pb.CategoryKind
    if transactionType == domain.TransactionIncome </span><span class="cov0" title="0">{
        kind = pb.CategoryKind_CATEGORY_KIND_INCOME
    }</span> else<span class="cov8" title="1"> {
        kind = pb.CategoryKind_CATEGORY_KIND_EXPENSE
    }</span>
    
    <span class="cov8" title="1">req := &amp;pb.ListCategoriesRequest{
        Kind: kind,
        IncludeInactive: false,
    }
    if len(locale) &gt; 0 &amp;&amp; locale[0] != "" </span><span class="cov8" title="1">{ req.Locale = locale[0] }</span>
    
    <span class="cov8" title="1">g.logger.Debug("ListCategories gRPC request", 
        zap.String("kind", kind.String()),
        zap.Bool("includeInactive", req.IncludeInactive),
        zap.String("locale", req.Locale))
    
    res, err := g.client.ListCategories(ctx, req)
    if err != nil </span><span class="cov8" title="1">{
        g.logger.Error("ListCategories gRPC call failed", zap.Error(err))
        return nil, err
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("ListCategories gRPC response", 
        zap.Int("categoriesCount", len(res.Categories)))
    
    var out []*domain.Category
    for _, c := range res.Categories </span><span class="cov8" title="1">{
        name := c.Code
        if len(c.Translations) &gt; 0 &amp;&amp; c.Translations[0].Name != "" </span><span class="cov8" title="1">{
            name = c.Translations[0].Name
        }</span>
        <span class="cov8" title="1">out = append(out, &amp;domain.Category{ID: c.Id, Name: name})</span>
    }
    
    <span class="cov8" title="1">g.logger.Debug("ListCategories processed", 
        zap.Int("categoriesReturned", len(out)))
    
    return out, nil</span>
}

// CreateCategory creates a new category.
func (g *CategoryGRPCClient) CreateCategory(ctx context.Context, accessToken string, code string, name string, locale string) (*domain.Category, error) <span class="cov8" title="1">{
    g.logger.Debug("CreateCategory request", 
        zap.String("code", code),
        zap.String("name", name),
        zap.String("locale", locale),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    <span class="cov8" title="1">if locale == "" </span><span class="cov0" title="0">{ locale = "ru" }</span>
    <span class="cov8" title="1">req := &amp;pb.CreateCategoryRequest{
        Kind:        pb.CategoryKind_CATEGORY_KIND_EXPENSE,
        Code:        code,
        IsActive:    true,
        Translations: []*pb.CategoryTranslation{{Locale: locale, Name: name}},
    }
    
    g.logger.Debug("CreateCategory gRPC request", 
        zap.String("kind", req.Kind.String()),
        zap.String("code", req.Code),
        zap.Bool("isActive", req.IsActive))
    
    res, err := g.client.CreateCategory(ctx, req)
    if err != nil </span><span class="cov0" title="0">{ 
        g.logger.Error("CreateCategory gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">cat := res.GetCategory()
    if cat == nil </span><span class="cov0" title="0">{ 
        g.logger.Error("CreateCategory empty response")
        return nil, fmt.Errorf("empty response") 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("CreateCategory gRPC response", 
        zap.String("categoryId", cat.GetId()))
    
    out := &amp;domain.Category{ID: cat.GetId(), Name: name}
    return out, nil</span>
}

// UpdateCategoryName updates category translation name.
func (g *CategoryGRPCClient) UpdateCategoryName(ctx context.Context, accessToken string, id string, name string, locale string) (*domain.Category, error) <span class="cov8" title="1">{
    g.logger.Debug("UpdateCategoryName request", 
        zap.String("id", id),
        zap.String("name", name),
        zap.String("locale", locale),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    <span class="cov8" title="1">if locale == "" </span><span class="cov0" title="0">{ locale = "ru" }</span>
    <span class="cov8" title="1">req := &amp;pb.UpdateCategoryRequest{
        Id:           id,
        Translations: []*pb.CategoryTranslation{{Locale: locale, Name: name}},
    }
    
    g.logger.Debug("UpdateCategoryName gRPC request", 
        zap.String("id", req.Id))
    
    res, err := g.client.UpdateCategory(ctx, req)
    if err != nil </span><span class="cov0" title="0">{ 
        g.logger.Error("UpdateCategoryName gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">cat := res.GetCategory()
    if cat == nil </span><span class="cov0" title="0">{ 
        g.logger.Error("UpdateCategoryName empty response")
        return nil, fmt.Errorf("empty response") 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("UpdateCategoryName gRPC response", 
        zap.String("categoryId", cat.GetId()))
    
    out := &amp;domain.Category{ID: cat.GetId(), Name: name}
    return out, nil</span>
}

// DeleteCategory deletes a category by id.
func (g *CategoryGRPCClient) DeleteCategory(ctx context.Context, accessToken string, id string) error <span class="cov8" title="1">{
    g.logger.Debug("DeleteCategory request", 
        zap.String("id", id),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    
    <span class="cov8" title="1">req := &amp;pb.DeleteCategoryRequest{Id: id}
    g.logger.Debug("DeleteCategory gRPC request", 
        zap.String("id", req.Id))
    
    _, err := g.client.DeleteCategory(ctx, req)
    if err != nil </span><span class="cov0" title="0">{
        g.logger.Error("DeleteCategory gRPC call failed", zap.Error(err))
    }</span> else<span class="cov8" title="1"> {
        g.logger.Debug("DeleteCategory gRPC call successful")
    }</span>
    <span class="cov8" title="1">return err</span>
}


</pre>
		
		<pre class="file" id="file17" style="display: none">package grpc

import (
        "crypto/tls"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
)

// DialOptions configures gRPC client dialing.
type DialOptions struct {
        Address  string
        Insecure bool
}

// Dial creates a gRPC client connection using a timeout and TLS/insecure creds.
func Dial(opts DialOptions) (*grpc.ClientConn, error) <span class="cov8" title="1">{
        var creds credentials.TransportCredentials
        if opts.Insecure </span><span class="cov8" title="1">{
                creds = insecure.NewCredentials()
        }</span> else<span class="cov0" title="0"> {
                creds = credentials.NewTLS(&amp;tls.Config{MinVersion: tls.VersionTLS12})
        }</span>
        <span class="cov8" title="1">return grpc.NewClient(
                opts.Address,
                grpc.WithTransportCredentials(creds),
                grpc.WithDefaultCallOptions(grpc.WaitForReady(true)),
        )</span>
}


</pre>
		
		<pre class="file" id="file18" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
        "context"
        "strconv"
        "time"

        pb "budget-bot/internal/pb/budget/v1"
        "google.golang.org/grpc/metadata"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// FxClient provides access to foreign exchange rates.
type FxClient interface {
        // GetRate returns a decimal exchange rate from -&gt; to at a given date.
        // If accessToken is non-empty, it will be attached as authorization metadata.
        GetRate(ctx context.Context, fromCurrency, toCurrency string, asOf time.Time, accessToken string) (float64, error)
}

// FakeFxClient is a stubbed client returning a 1.0 rate.
type FakeFxClient struct{}

// GetRate returns a decimal exchange rate; stubbed to 1.0 for now.
func (f *FakeFxClient) GetRate(_ context.Context, fromCurrency, toCurrency string, _ time.Time, _ string) (float64, error) <span class="cov8" title="1">{
        if fromCurrency == toCurrency </span><span class="cov8" title="1">{
                return 1.0, nil
        }</span>
        // Default placeholder rate
        <span class="cov8" title="1">return 1.0, nil</span>
}

// FxGRPCClient calls Fx service via gRPC.
type FxGRPCClient struct{ client pb.FxServiceClient }

// NewGRPCFxClient constructs a FxGRPCClient.
func NewGRPCFxClient(c pb.FxServiceClient) *FxGRPCClient <span class="cov8" title="1">{ return &amp;FxGRPCClient{client: c} }</span>

// GetRate returns a decimal exchange rate for given currencies/date.
func (g *FxGRPCClient) GetRate(ctx context.Context, fromCurrency, toCurrency string, asOf time.Time, accessToken string) (float64, error) <span class="cov8" title="1">{
        if accessToken != "" </span><span class="cov8" title="1">{
                ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken)
        }</span>
        <span class="cov8" title="1">res, err := g.client.GetRate(ctx, &amp;pb.GetRateRequest{
                FromCurrencyCode: fromCurrency,
                ToCurrencyCode:   toCurrency,
                AsOf:             timestamppb.New(asOf),
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">rateStr := "1"
        if res.GetRate() != nil &amp;&amp; res.GetRate().GetRateDecimal() != "" </span><span class="cov8" title="1">{
                rateStr = res.GetRate().GetRateDecimal()
        }</span>
        <span class="cov8" title="1">rate, err := strconv.ParseFloat(rateStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return rate, nil</span>
}


</pre>
		
		<pre class="file" id="file19" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
        "context"
        "fmt"
        "time"

        pb "budget-bot/internal/pb/budget/v1"
        "go.uber.org/zap"
)

// OAuthGRPCClient wraps the gRPC OAuth service with helper methods.
type OAuthGRPCClient struct {
        client pb.OAuthServiceClient
        log    *zap.Logger
}

// NewOAuthClient constructs an OAuthGRPCClient.
func NewOAuthClient(client pb.OAuthServiceClient, log *zap.Logger) OAuthClient <span class="cov8" title="1">{
        return &amp;OAuthGRPCClient{client: client, log: log}
}</span>

// GenerateAuthLink generates an OAuth authorization link.
func (o *OAuthGRPCClient) GenerateAuthLink(ctx context.Context, email string, telegramUserID int64, userAgent, ipAddress string) (string, string, time.Time, error) <span class="cov8" title="1">{
        res, err := o.client.GenerateAuthLink(ctx, &amp;pb.GenerateAuthLinkRequest{
                Email:          email,
                TelegramUserId: fmt.Sprintf("%d", telegramUserID),
                UserAgent:      userAgent,
                IpAddress:      ipAddress,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov8" title="1">return res.AuthUrl, res.AuthToken, res.ExpiresAt.AsTime(), nil</span>
}

// VerifyAuthCode verifies the OAuth verification code.
func (o *OAuthGRPCClient) VerifyAuthCode(ctx context.Context, authToken, verificationCode string, telegramUserID int64) (*VerifyAuthCodeResult, error) <span class="cov8" title="1">{
        o.log.Info("Sending VerifyAuthCode request to gRPC",
                zap.String("authToken", authToken),
                zap.String("verificationCode", verificationCode),
                zap.Int64("telegramUserID", telegramUserID))

        res, err := o.client.VerifyAuthCode(ctx, &amp;pb.VerifyAuthCodeRequest{
                AuthToken:        authToken,
                VerificationCode: verificationCode,
                TelegramUserId:   fmt.Sprintf("%d", telegramUserID),
        })
        if err != nil </span><span class="cov0" title="0">{
                o.log.Error("gRPC VerifyAuthCode failed",
                        zap.String("authToken", authToken),
                        zap.String("verificationCode", verificationCode),
                        zap.Int64("telegramUserID", telegramUserID),
                        zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">accessTokenLog := ""
        refreshTokenLog := ""
        if res.Tokens != nil </span><span class="cov8" title="1">{
                if len(res.Tokens.AccessToken) &gt; 10 </span><span class="cov8" title="1">{
                        accessTokenLog = res.Tokens.AccessToken[:10] + "..."
                }</span> else<span class="cov0" title="0"> {
                        accessTokenLog = res.Tokens.AccessToken
                }</span>
                <span class="cov8" title="1">if len(res.Tokens.RefreshToken) &gt; 10 </span><span class="cov8" title="1">{
                        refreshTokenLog = res.Tokens.RefreshToken[:10] + "..."
                }</span> else<span class="cov0" title="0"> {
                        refreshTokenLog = res.Tokens.RefreshToken
                }</span>
        }
        
        <span class="cov8" title="1">o.log.Info("gRPC VerifyAuthCode succeeded",
                zap.String("sessionID", res.SessionId),
                zap.String("accessToken", accessTokenLog),
                zap.String("refreshToken", refreshTokenLog),
                zap.String("userID", res.User.Id),
                zap.Int("membershipsCount", len(res.Memberships)))

        result := &amp;VerifyAuthCodeResult{
                Tokens:      res.Tokens,
                SessionID:   res.SessionId,
                User:        res.User,
                Memberships: res.Memberships,
        }

        return result, nil</span>
}

// CancelAuth cancels the OAuth authorization process.
func (o *OAuthGRPCClient) CancelAuth(ctx context.Context, authToken string, telegramUserID int64) error <span class="cov0" title="0">{
        _, err := o.client.CancelAuth(ctx, &amp;pb.CancelAuthRequest{
                AuthToken:      authToken,
                TelegramUserId: fmt.Sprintf("%d", telegramUserID),
        })
        return err
}</span>

// GetAuthStatus gets the status of an OAuth authorization.
func (o *OAuthGRPCClient) GetAuthStatus(ctx context.Context, authToken string) (string, string, time.Time, error) <span class="cov8" title="1">{
        res, err := o.client.GetAuthStatus(ctx, &amp;pb.GetAuthStatusRequest{
                AuthToken: authToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov8" title="1">return res.Status.String(), res.Email, res.ExpiresAt.AsTime(), nil</span>
}

// GetTelegramSession gets a Telegram session by session ID.
func (o *OAuthGRPCClient) GetTelegramSession(ctx context.Context, sessionID string) (*pb.GetTelegramSessionResponse, error) <span class="cov8" title="1">{
        return o.client.GetTelegramSession(ctx, &amp;pb.GetTelegramSessionRequest{
                SessionId: sessionID,
        })
}</span>

// RevokeTelegramSession revokes a Telegram session.
func (o *OAuthGRPCClient) RevokeTelegramSession(ctx context.Context, sessionID string, telegramUserID int64) error <span class="cov0" title="0">{
        _, err := o.client.RevokeTelegramSession(ctx, &amp;pb.RevokeTelegramSessionRequest{
                SessionId:      sessionID,
                TelegramUserId: fmt.Sprintf("%d", telegramUserID),
        })
        return err
}</span>

// ListTelegramSessions lists all Telegram sessions for a user.
func (o *OAuthGRPCClient) ListTelegramSessions(ctx context.Context, telegramUserID int64) ([]*pb.TelegramSession, error) <span class="cov8" title="1">{
        res, err := o.client.ListTelegramSessions(ctx, &amp;pb.ListTelegramSessionsRequest{
                TelegramUserId: fmt.Sprintf("%d", telegramUserID),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res.Sessions, nil</span>
}

// GetAuthLogs gets authentication logs for a user.
func (o *OAuthGRPCClient) GetAuthLogs(ctx context.Context, telegramUserID int64, limit, offset int32) ([]*pb.AuthLogEntry, int32, error) <span class="cov8" title="1">{
        res, err := o.client.GetAuthLogs(ctx, &amp;pb.GetAuthLogsRequest{
                TelegramUserId: fmt.Sprintf("%d", telegramUserID),
                Limit:          limit,
                Offset:         offset,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return res.Logs, res.TotalCount, nil</span>
}


</pre>
		
		<pre class="file" id="file20" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
    "context"
    "math"
    "time"
    "sort"

    pb "budget-bot/internal/pb/budget/v1"
    "budget-bot/internal/domain"
    "google.golang.org/grpc/metadata"
    "go.uber.org/zap"
)

// ReportClient exposes read-only reporting operations.
type ReportClient interface {
    GetStats(ctx context.Context, tenantID string, from, to time.Time, accessToken string) (*domain.Stats, error)
    TopCategories(ctx context.Context, tenantID string, from, to time.Time, limit int, accessToken string) ([]*domain.CategoryTotal, error)
    Recent(ctx context.Context, tenantID string, limit int, accessToken string) ([]string, error)
}

// FakeReportClient is a stubbed implementation for tests and local runs.
type FakeReportClient struct{}

// GetStats returns a fake stats response.
func (f *FakeReportClient) GetStats(_ context.Context, tenantID string, from, to time.Time, _ string) (*domain.Stats, error) <span class="cov0" title="0">{
    _ = tenantID
    return &amp;domain.Stats{Period: from.Format("2006-01-02") + ".." + to.Format("2006-01-02"), TotalIncome: 2500000, TotalExpense: 1750000, Currency: "RUB"}, nil
}</span>

// TopCategories returns fake top categories.
func (f *FakeReportClient) TopCategories(_ context.Context, tenantID string, from, to time.Time, limit int, _ string) ([]*domain.CategoryTotal, error) <span class="cov0" title="0">{
    _ = tenantID; _ = from; _ = to; _ = limit
    return []*domain.CategoryTotal{{CategoryID: "cat-food", Name: "Питание", SumMinor: 500000, Currency: "RUB"}, {CategoryID: "cat-transport", Name: "Транспорт", SumMinor: 300000, Currency: "RUB"}}, nil
}</span>

// Recent returns fake recent lines.
func (f *FakeReportClient) Recent(_ context.Context, tenantID string, limit int, _ string) ([]string, error) <span class="cov0" title="0">{
    _ = tenantID; _ = limit
    return []string{"-1000 продукты", "-300 такси", "+50000 зарплата"}, nil
}</span>

// ReportGRPCClient calls remote Report service via gRPC.
type ReportGRPCClient struct{ 
    client pb.ReportServiceClient 
    logger *zap.Logger
}

// NewGRPCReportClient constructs a GRPCReportClient.
func NewGRPCReportClient(c pb.ReportServiceClient, logger *zap.Logger) *ReportGRPCClient <span class="cov8" title="1">{ 
    return &amp;ReportGRPCClient{client: c, logger: logger} 
}</span>

// GetStats fetches monthly stats for a period.
func (g *ReportGRPCClient) GetStats(ctx context.Context, tenantID string, from, _ time.Time, accessToken string) (*domain.Stats, error) <span class="cov8" title="1">{
    g.logger.Debug("GetStats request", 
        zap.String("tenantID", tenantID),
        zap.Time("from", from),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ 
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) 
    }</span>
    
    // Calculate timezone offset in minutes (JS-style: minutes to add to local time to get UTC)
    <span class="cov8" title="1">_, offset := from.Zone()
    timezoneOffsetMinutes := int32(-offset / 60) // Negative because JS getTimezoneOffset() is opposite of Go
    
    req := &amp;pb.GetMonthlySummaryRequest{
        Year: int32(from.Year()), 
        Month: int32(from.Month()),
        TimezoneOffsetMinutes: timezoneOffsetMinutes,
    }
    g.logger.Debug("GetStats gRPC request", 
        zap.Int32("year", req.Year),
        zap.Int32("month", req.Month),
        zap.Int32("timezoneOffsetMinutes", req.TimezoneOffsetMinutes))
    
    res, err := g.client.GetMonthlySummary(ctx, req)
    if err != nil </span><span class="cov8" title="1">{ 
        g.logger.Error("GetStats gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("GetStats gRPC response", 
        zap.Int64("totalIncome", res.TotalIncome.MinorUnits),
        zap.Int64("totalExpense", res.TotalExpense.MinorUnits),
        zap.String("currency", res.TotalIncome.CurrencyCode))
    
    return &amp;domain.Stats{
        Period: from.Format("2006-01"), 
        TotalIncome: res.TotalIncome.MinorUnits, 
        TotalExpense: res.TotalExpense.MinorUnits, 
        Currency: res.TotalIncome.CurrencyCode,
    }, nil</span>
}

// TopCategories returns top expense categories for the period.
func (g *ReportGRPCClient) TopCategories(ctx context.Context, tenantID string, from, _ time.Time, limit int, accessToken string) ([]*domain.CategoryTotal, error) <span class="cov8" title="1">{
    g.logger.Debug("TopCategories request", 
        zap.String("tenantID", tenantID),
        zap.Time("from", from),
        zap.Int("limit", limit),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ 
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) 
    }</span>
    
    // Calculate timezone offset in minutes (JS-style: minutes to add to local time to get UTC)
    <span class="cov8" title="1">_, offset := from.Zone()
    timezoneOffsetMinutes := int32(-offset / 60) // Negative because JS getTimezoneOffset() is opposite of Go
    
    req := &amp;pb.GetMonthlySummaryRequest{
        Year: int32(from.Year()), 
        Month: int32(from.Month()),
        TimezoneOffsetMinutes: timezoneOffsetMinutes,
    }
    g.logger.Debug("TopCategories gRPC request", 
        zap.Int32("year", req.Year),
        zap.Int32("month", req.Month),
        zap.Int32("timezoneOffsetMinutes", req.TimezoneOffsetMinutes))
    
    res, err := g.client.GetMonthlySummary(ctx, req)
    if err != nil </span><span class="cov8" title="1">{ 
        g.logger.Error("TopCategories gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("TopCategories gRPC response", 
        zap.Int("itemsCount", len(res.GetItems())))
    
    // Collect only expense categories and sort by total desc
    items := res.GetItems()
    out := make([]*domain.CategoryTotal, 0, len(items))
    for _, it := range items </span><span class="cov8" title="1">{
        if it.GetType() != pb.TransactionType_TRANSACTION_TYPE_EXPENSE </span><span class="cov0" title="0">{ continue</span> }
        <span class="cov8" title="1">total := it.GetTotal()
        out = append(out, &amp;domain.CategoryTotal{CategoryID: it.GetCategoryId(), Name: it.GetCategoryName(), SumMinor: total.GetMinorUnits(), Currency: total.GetCurrencyCode()})</span>
    }
    // sort desc by SumMinor
    <span class="cov8" title="1">sort.Slice(out, func(i, j int) bool </span><span class="cov0" title="0">{ return out[i].SumMinor &gt; out[j].SumMinor }</span>)
    <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; len(out) &gt; limit </span><span class="cov0" title="0">{ out = out[:limit] }</span>
    
    <span class="cov8" title="1">g.logger.Debug("TopCategories processed", 
        zap.Int("expenseItems", len(out)),
        zap.Int("limit", limit))
    
    return out, nil</span>
}

// Recent returns recent transactions as strings (not implemented by backend).
func (g *ReportGRPCClient) Recent(ctx context.Context, _ string, _ int, accessToken string) ([]string, error) <span class="cov0" title="0">{
    g.logger.Debug("Recent request", 
        zap.String("accessToken", accessToken[:10] + "..."))
    
    // Not defined in proto; return empty for now (token attached for future use)
    if accessToken != "" </span><span class="cov0" title="0">{ 
        _ = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) 
    }</span>
    <span class="cov0" title="0">return []string{}, nil</span>
}


</pre>
		
		<pre class="file" id="file21" style="display: none">// Package grpc contains gRPC client facades used by the bot.
package grpc

import (
    "context"
    "math"

    pb "budget-bot/internal/pb/budget/v1"
    "google.golang.org/grpc/metadata"
    "go.uber.org/zap"
)

// Tenant represents a tenant returned by the backend.
type Tenant struct {
    ID   string
    Name string
}

// TenantClient exposes tenant operations.
type TenantClient interface {
    ListTenants(ctx context.Context, accessToken string) ([]*Tenant, error)
}

// FakeTenantClient is a temporary stub returning two tenants.
// FakeTenantClient is a temporary stub returning static tenants.
type FakeTenantClient struct{}

// ListTenants returns a static list of tenants.
func (f *FakeTenantClient) ListTenants(_ context.Context, _ string) ([]*Tenant, error) <span class="cov0" title="0">{
    return []*Tenant{{ID: "tenant-1", Name: "Личный"}, {ID: "tenant-2", Name: "Семья"}}, nil
}</span>

// TenantGRPCClient calls Tenant service via gRPC.
type TenantGRPCClient struct{ 
    client pb.TenantServiceClient 
    logger *zap.Logger
}

// NewGRPCTenantClient constructs a TenantGRPCClient.
func NewGRPCTenantClient(c pb.TenantServiceClient, logger *zap.Logger) *TenantGRPCClient <span class="cov8" title="1">{ 
    return &amp;TenantGRPCClient{client: c, logger: logger} 
}</span>

// ListTenants returns a list of tenants for current user.
func (g *TenantGRPCClient) ListTenants(ctx context.Context, accessToken string) ([]*Tenant, error) <span class="cov8" title="1">{
    g.logger.Debug("ListTenants request", 
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    
    <span class="cov8" title="1">req := &amp;pb.ListMyTenantsRequest{}
    g.logger.Debug("ListTenants gRPC request")
    
    res, err := g.client.ListMyTenants(ctx, req)
    if err != nil </span><span class="cov0" title="0">{ 
        g.logger.Error("ListTenants gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("ListTenants gRPC response", 
        zap.Int("membershipsCount", len(res.Memberships)))
    
    var out []*Tenant
    for _, m := range res.Memberships </span><span class="cov8" title="1">{
        out = append(out, &amp;Tenant{ID: m.Tenant.Id, Name: m.Tenant.Name})
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("ListTenants processed", 
        zap.Int("tenantsReturned", len(out)))
    
    return out, nil</span>
}


</pre>
		
		<pre class="file" id="file22" style="display: none">package grpc

import (
    "context"
    "math"
    "time"

    pb "budget-bot/internal/pb/budget/v1"
    "google.golang.org/grpc/metadata"
    "google.golang.org/protobuf/types/known/timestamppb"
    "go.uber.org/zap"
)

// CreateTransactionRequest is an app-level request to create a transaction.
type CreateTransactionRequest struct {
    TenantID    string
    Type        string
    AmountMinor int64
    Currency    string
    Description string
    CategoryID  string
    OccurredAt  time.Time
}

// TransactionClient exposes transaction operations.
type TransactionClient interface {
    CreateTransaction(ctx context.Context, req *CreateTransactionRequest, accessToken string) (string, error)
    ListRecent(ctx context.Context, tenantID string, limit int, accessToken string) ([]*pb.Transaction, error)
    ListForExport(ctx context.Context, tenantID string, from, to time.Time, limit int, accessToken string) ([]*pb.Transaction, error)
}

// FakeTransactionClient is a temporary stub.
// FakeTransactionClient is a stubbed client for tests/local runs.
type FakeTransactionClient struct{}

// CreateTransaction returns a fake transaction id.
func (f *FakeTransactionClient) CreateTransaction(_ context.Context, req *CreateTransactionRequest, _ string) (string, error) <span class="cov0" title="0">{
    return "tx-" + req.Description, nil
}</span>

// ListRecent returns an empty list in the fake client.
func (f *FakeTransactionClient) ListRecent(_ context.Context, _ string, _ int, _ string) ([]*pb.Transaction, error) <span class="cov0" title="0">{
    return []*pb.Transaction{}, nil
}</span>

// ListForExport returns an empty list in the fake client.
func (f *FakeTransactionClient) ListForExport(_ context.Context, _ string, _ , _ time.Time, _ int, _ string) ([]*pb.Transaction, error) <span class="cov0" title="0">{
    return []*pb.Transaction{}, nil
}</span>

// TransactionGRPCClient calls Transaction service via gRPC.
type TransactionGRPCClient struct{ 
    client pb.TransactionServiceClient 
    logger *zap.Logger
}

// NewGRPCTransactionClient constructs a TransactionGRPCClient.
func NewGRPCTransactionClient(c pb.TransactionServiceClient, logger *zap.Logger) *TransactionGRPCClient <span class="cov8" title="1">{ 
    return &amp;TransactionGRPCClient{client: c, logger: logger} 
}</span>

// CreateTransaction creates a transaction and returns its id.
func (g *TransactionGRPCClient) CreateTransaction(ctx context.Context, req *CreateTransactionRequest, accessToken string) (string, error) <span class="cov8" title="1">{
    g.logger.Debug("CreateTransaction request", 
        zap.String("tenantID", req.TenantID),
        zap.String("type", req.Type),
        zap.Int64("amountMinor", req.AmountMinor),
        zap.String("currency", req.Currency),
        zap.String("description", req.Description),
        zap.String("categoryID", req.CategoryID),
        zap.Time("occurredAt", req.OccurredAt),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    <span class="cov8" title="1">pbReq := &amp;pb.CreateTransactionRequest{
        Type:      mapType(req.Type),
        CategoryId: req.CategoryID,
        Amount:    &amp;pb.Money{CurrencyCode: req.Currency, MinorUnits: req.AmountMinor},
        OccurredAt: timestamppb.New(req.OccurredAt),
        Comment:   req.Description,
    }
    
    g.logger.Debug("CreateTransaction gRPC request", 
        zap.String("type", pbReq.Type.String()),
        zap.String("categoryId", pbReq.CategoryId),
        zap.String("currency", pbReq.Amount.CurrencyCode),
        zap.Int64("amountMinor", pbReq.Amount.MinorUnits),
        zap.String("comment", pbReq.Comment))
    
    res, err := g.client.CreateTransaction(ctx, pbReq)
    if err != nil </span><span class="cov8" title="1">{ 
        g.logger.Error("CreateTransaction gRPC call failed", zap.Error(err))
        return "", err 
    }</span>
    
    <span class="cov8" title="1">g.logger.Debug("CreateTransaction gRPC response", 
        zap.String("transactionId", res.Transaction.Id))
    
    return res.Transaction.Id, nil</span>
}

// ListRecent returns recent transactions.
func (g *TransactionGRPCClient) ListRecent(ctx context.Context, tenantID string, limit int, accessToken string) ([]*pb.Transaction, error) <span class="cov8" title="1">{
    g.logger.Debug("ListRecent request", 
        zap.String("tenantID", tenantID),
        zap.Int("limit", limit),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    _ = tenantID
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    <span class="cov8" title="1">if limit &lt;= 0 </span><span class="cov8" title="1">{ limit = 10 }</span>
    
    <span class="cov8" title="1">req := &amp;pb.ListTransactionsRequest{
        Page: &amp;pb.PageRequest{Page: 1, PageSize: int32(limit), Sort: "occurred_at desc"},
    }
    
    g.logger.Debug("ListRecent gRPC request", 
        zap.Int32("page", req.Page.Page),
        zap.Int32("pageSize", req.Page.PageSize),
        zap.String("sort", req.Page.Sort))
    
    res, err := g.client.ListTransactions(ctx, req)
    if err != nil </span><span class="cov0" title="0">{ 
        g.logger.Error("ListRecent gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">transactions := res.GetTransactions()
    g.logger.Debug("ListRecent gRPC response", 
        zap.Int("transactionsCount", len(transactions)))
    
    return transactions, nil</span>
}

// ListForExport returns transactions for a period.
func (g *TransactionGRPCClient) ListForExport(ctx context.Context, tenantID string, from, to time.Time, limit int, accessToken string) ([]*pb.Transaction, error) <span class="cov8" title="1">{
    g.logger.Debug("ListForExport request", 
        zap.String("tenantID", tenantID),
        zap.Time("from", from),
        zap.Time("to", to),
        zap.Int("limit", limit),
        zap.String("accessToken", accessToken[:int(math.Min(float64(len(accessToken)), 10))] + "..."))
    
    _ = tenantID
    if accessToken != "" </span><span class="cov8" title="1">{ ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+accessToken) }</span>
    <span class="cov8" title="1">pr := &amp;pb.PageRequest{Page: 1, PageSize: int32(limit)}
    if limit &lt;= 0 </span><span class="cov0" title="0">{ pr.PageSize = 100 }</span>
    <span class="cov8" title="1">dr := &amp;pb.DateRange{From: timestamppb.New(from), To: timestamppb.New(to)}
    
    req := &amp;pb.ListTransactionsRequest{Page: pr, DateRange: dr}
    
    g.logger.Debug("ListForExport gRPC request", 
        zap.Int32("page", req.Page.Page),
        zap.Int32("pageSize", req.Page.PageSize),
        zap.Time("dateFrom", from),
        zap.Time("dateTo", to))
    
    res, err := g.client.ListTransactions(ctx, req)
    if err != nil </span><span class="cov0" title="0">{ 
        g.logger.Error("ListForExport gRPC call failed", zap.Error(err))
        return nil, err 
    }</span>
    
    <span class="cov8" title="1">transactions := res.GetTransactions()
    g.logger.Debug("ListForExport gRPC response", 
        zap.Int("transactionsCount", len(transactions)))
    
    return transactions, nil</span>
}

func mapType(t string) pb.TransactionType <span class="cov8" title="1">{
    switch t </span>{
    case "income":<span class="cov8" title="1"> return pb.TransactionType_TRANSACTION_TYPE_INCOME</span>
    case "expense":<span class="cov8" title="1"> return pb.TransactionType_TRANSACTION_TYPE_EXPENSE</span>
    default:<span class="cov8" title="1"> return pb.TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
    }
}


</pre>
		
		<pre class="file" id="file23" style="display: none">//go:build !withgrpc
// +build !withgrpc

package grpc

import (
        "context"
        "fmt"
        "time"

        pb "budget-bot/internal/pb/budget/v1"
        "go.uber.org/zap"
)

// FakeOAuthClient implements OAuthClient for testing
type FakeOAuthClient struct{}

func (f *FakeOAuthClient) GenerateAuthLink(ctx context.Context, email string, telegramUserID int64, userAgent, ipAddress string) (string, string, time.Time, error) <span class="cov0" title="0">{
        return "https://example.com/auth?token=test", "auth_token_123", time.Now().Add(5*time.Minute), nil
}</span>

func (f *FakeOAuthClient) VerifyAuthCode(ctx context.Context, authToken, verificationCode string, telegramUserID int64) (*VerifyAuthCodeResult, error) <span class="cov0" title="0">{
        return &amp;VerifyAuthCodeResult{
                Tokens: &amp;pb.TokenPair{
                        AccessToken:           "access_token_123",
                        RefreshToken:          "refresh_token_123",
                        AccessTokenExpiresAt:  nil,
                        RefreshTokenExpiresAt: nil,
                        TokenType:             "Bearer",
                },
                SessionID: "session_123",
                User: &amp;pb.User{
                        Id:    "user_123",
                        Email: "test@example.com",
                },
                Memberships: []*pb.TenantMembership{
                        {
                                Tenant: &amp;pb.Tenant{
                                        Id: "tenant_123",
                                },
                                Role: pb.TenantRole_TENANT_ROLE_OWNER,
                        },
                },
        }, nil
}</span>

func (f *FakeOAuthClient) CancelAuth(ctx context.Context, authToken string, telegramUserID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *FakeOAuthClient) GetAuthStatus(ctx context.Context, authToken string) (string, string, time.Time, error) <span class="cov0" title="0">{
        return "pending", "test@example.com", time.Now().Add(5*time.Minute), nil
}</span>

func (f *FakeOAuthClient) GetTelegramSession(ctx context.Context, sessionID string) (*pb.GetTelegramSessionResponse, error) <span class="cov0" title="0">{
        return &amp;pb.GetTelegramSessionResponse{
                Session: &amp;pb.TelegramSession{
                        SessionId:        sessionID,
                        UserId:           "user_123",
                        TelegramUserId:   "12345",
                        TenantId:         "tenant_123",
                        CreatedAt:        nil,
                        ExpiresAt:        nil,
                        IsActive:         true,
                },
                User:   nil,
                Tenant: nil,
        }, nil
}</span>

func (f *FakeOAuthClient) RevokeTelegramSession(ctx context.Context, sessionID string, telegramUserID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *FakeOAuthClient) ListTelegramSessions(ctx context.Context, telegramUserID int64) ([]*pb.TelegramSession, error) <span class="cov0" title="0">{
        return []*pb.TelegramSession{
                {
                        SessionId:        "session_1",
                        UserId:           "user_123",
                        TelegramUserId:   fmt.Sprintf("%d", telegramUserID),
                        TenantId:         "tenant_123",
                        CreatedAt:        nil,
                        ExpiresAt:        nil,
                        IsActive:         true,
                },
        }, nil
}</span>

func (f *FakeOAuthClient) GetAuthLogs(ctx context.Context, telegramUserID int64, limit, offset int32) ([]*pb.AuthLogEntry, int32, error) <span class="cov0" title="0">{
        return []*pb.AuthLogEntry{
                {
                        Id:             "log_1",
                        Email:          "test@example.com",
                        TelegramUserId: fmt.Sprintf("%d", telegramUserID),
                        IpAddress:      "127.0.0.1",
                        UserAgent:      "TelegramBot/1.0",
                        Action:         "generate_link",
                        Status:         "success",
                        ErrorMessage:   "",
                        CreatedAt:      nil,
                },
        }, 1, nil
}</span>



// WireClients (default build) returns nil clients so the app uses fakes.
// To enable real clients, build with -tags withgrpc and ensure proto is generated.
func WireClients(_ *zap.Logger) (CategoryClient, ReportClient, TenantClient, TransactionClient, OAuthClient) <span class="cov0" title="0">{
    return nil, nil, nil, nil, &amp;FakeOAuthClient{}
}</span>


</pre>
		
		<pre class="file" id="file24" style="display: none">// Package metrics exposes Prometheus metrics handler.
package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        updatesTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "bot_updates_total",
                        Help: "Total number of Telegram updates processed",
                },
        )

        transactionsSaved = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "bot_transactions_saved_total",
                        Help: "Total number of transactions saved",
                },
                []string{"status"},
        )
)

func init() <span class="cov8" title="1">{
        prometheus.MustRegister(updatesTotal)
        prometheus.MustRegister(transactionsSaved)
}</span>

// IncUpdate increments updates counter.
func IncUpdate() <span class="cov8" title="1">{ updatesTotal.Inc() }</span>

// IncTransactionsSaved increments saved counter with a status label.
func IncTransactionsSaved(status string) <span class="cov8" title="1">{ transactionsSaved.WithLabelValues(status).Inc() }</span>

// Handler returns the HTTP handler for /metrics.
func Handler() http.Handler <span class="cov8" title="1">{ return promhttp.Handler() }</span>


</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/auth.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TokenPair struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken           string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken          string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        AccessTokenExpiresAt  *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=access_token_expires_at,json=accessTokenExpiresAt,proto3" json:"access_token_expires_at,omitempty"`
        RefreshTokenExpiresAt *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=refresh_token_expires_at,json=refreshTokenExpiresAt,proto3" json:"refresh_token_expires_at,omitempty"`
        TokenType             string                 `protobuf:"bytes,5,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"` // "Bearer"
}

func (x *TokenPair) Reset() <span class="cov0" title="0">{
        *x = TokenPair{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TokenPair) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TokenPair) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TokenPair) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TokenPair.ProtoReflect.Descriptor instead.
func (*TokenPair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *TokenPair) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenPair) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenPair) GetAccessTokenExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TokenPair) GetRefreshTokenExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TokenPair) GetTokenType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TokenType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email      string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password   string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        Name       string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        Locale     string `protobuf:"bytes,4,opt,name=locale,proto3" json:"locale,omitempty"`                           // preferred locale
        TenantName string `protobuf:"bytes,5,opt,name=tenant_name,json=tenantName,proto3" json:"tenant_name,omitempty"` // optional initial tenant name
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetTenantName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tokens *TokenPair `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
        User   *User      `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
        Tenant *Tenant    `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"` // initial tenant if created
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RegisterResponse) GetTokens() *TokenPair <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RegisterResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RegisterResponse) GetTenant() *Tenant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tokens      *TokenPair          `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
        Memberships []*TenantMembership `protobuf:"bytes,2,rep,name=memberships,proto3" json:"memberships,omitempty"`
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{4}
}</span>

func (x *LoginResponse) GetTokens() *TokenPair <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoginResponse) GetMemberships() []*TenantMembership <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Memberships
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RefreshTokenRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RefreshToken string `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (x *RefreshTokenRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{5}
}</span>

func (x *RefreshTokenRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshTokenResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tokens *TokenPair `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
}

func (x *RefreshTokenResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{6}
}</span>

func (x *RefreshTokenResponse) GetTokens() *TokenPair <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RequestPasswordResetRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *RequestPasswordResetRequest) Reset() <span class="cov0" title="0">{
        *x = RequestPasswordResetRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RequestPasswordResetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RequestPasswordResetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RequestPasswordResetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RequestPasswordResetRequest.ProtoReflect.Descriptor instead.
func (*RequestPasswordResetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{7}
}</span>

func (x *RequestPasswordResetRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RequestPasswordResetResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *RequestPasswordResetResponse) Reset() <span class="cov0" title="0">{
        *x = RequestPasswordResetResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RequestPasswordResetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RequestPasswordResetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RequestPasswordResetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RequestPasswordResetResponse.ProtoReflect.Descriptor instead.
func (*RequestPasswordResetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{8}
}</span>

type ResetPasswordRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ResetToken  string `protobuf:"bytes,1,opt,name=reset_token,json=resetToken,proto3" json:"reset_token,omitempty"`
        NewPassword string `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
}

func (x *ResetPasswordRequest) Reset() <span class="cov0" title="0">{
        *x = ResetPasswordRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ResetPasswordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResetPasswordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResetPasswordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResetPasswordRequest.ProtoReflect.Descriptor instead.
func (*ResetPasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ResetPasswordRequest) GetResetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ResetToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ResetPasswordRequest) GetNewPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ResetPasswordResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ResetPasswordResponse) Reset() <span class="cov0" title="0">{
        *x = ResetPasswordResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_auth_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ResetPasswordResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResetPasswordResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResetPasswordResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_auth_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResetPasswordResponse.ProtoReflect.Descriptor instead.
func (*ResetPasswordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_auth_proto_rawDescGZIP(), []int{10}
}</span>

var File_budget_v1_auth_proto protoreflect.FileDescriptor

var file_budget_v1_auth_proto_rawDesc = []byte{
        0x0a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73,
        0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2f, 0x76, 0x31, 0x2f, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0x9a, 0x02, 0x0a, 0x09, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x12, 0x21,
        0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65,
        0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b,
        0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73,
        0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x51, 0x0a, 0x17, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73,
        0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61,
        0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x14, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
        0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x53, 0x0a, 0x18, 0x72, 0x65, 0x66,
        0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x65, 0x78, 0x70, 0x69, 0x72,
        0x65, 0x73, 0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x15, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68,
        0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x1d,
        0x0a, 0x0a, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x09, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x22, 0x90, 0x01,
        0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
        0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x12,
        0x1f, 0x0a, 0x0b, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65,
        0x22, 0x90, 0x01, 0x0a, 0x10, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x52, 0x06, 0x74, 0x6f, 0x6b,
        0x65, 0x6e, 0x73, 0x12, 0x23, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73,
        0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x74, 0x65, 0x6e,
        0x61, 0x6e, 0x74, 0x22, 0x40, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x7c, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x52, 0x06, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x73, 0x12, 0x3d, 0x0a, 0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68,
        0x69, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62,
        0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x52, 0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68,
        0x69, 0x70, 0x73, 0x22, 0x3a, 0x0a, 0x13, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65,
        0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22,
        0x44, 0x0a, 0x14, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
        0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x52, 0x06, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x22, 0x33, 0x0a, 0x1b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x65, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x1e, 0x0a, 0x1c, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73,
        0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x5a, 0x0a, 0x14, 0x52, 0x65,
        0x73, 0x65, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x72, 0x65, 0x73, 0x65, 0x74, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x72, 0x65, 0x73, 0x65, 0x74, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x65, 0x77, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6e, 0x65, 0x77, 0x50, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x17, 0x0a, 0x15, 0x52, 0x65, 0x73, 0x65, 0x74, 0x50,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32,
        0x9c, 0x03, 0x0a, 0x0b, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
        0x43, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x12, 0x1a, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3a, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x17, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x4f, 0x0a, 0x0c, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
        0x12, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x66,
        0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x66,
        0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x67, 0x0a, 0x14, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73,
        0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x65, 0x74, 0x12, 0x26, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x27, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73,
        0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x52, 0x65,
        0x73, 0x65, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1f, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x74, 0x50, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x74, 0x50, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38,
        0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73,
        0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67,
        0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_auth_proto_rawDescOnce sync.Once
        file_budget_v1_auth_proto_rawDescData = file_budget_v1_auth_proto_rawDesc
)

func file_budget_v1_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_auth_proto_rawDescData</span>
}

var file_budget_v1_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_budget_v1_auth_proto_goTypes = []interface{}{
        (*TokenPair)(nil),                    // 0: budget.v1.TokenPair
        (*RegisterRequest)(nil),              // 1: budget.v1.RegisterRequest
        (*RegisterResponse)(nil),             // 2: budget.v1.RegisterResponse
        (*LoginRequest)(nil),                 // 3: budget.v1.LoginRequest
        (*LoginResponse)(nil),                // 4: budget.v1.LoginResponse
        (*RefreshTokenRequest)(nil),          // 5: budget.v1.RefreshTokenRequest
        (*RefreshTokenResponse)(nil),         // 6: budget.v1.RefreshTokenResponse
        (*RequestPasswordResetRequest)(nil),  // 7: budget.v1.RequestPasswordResetRequest
        (*RequestPasswordResetResponse)(nil), // 8: budget.v1.RequestPasswordResetResponse
        (*ResetPasswordRequest)(nil),         // 9: budget.v1.ResetPasswordRequest
        (*ResetPasswordResponse)(nil),        // 10: budget.v1.ResetPasswordResponse
        (*timestamppb.Timestamp)(nil),        // 11: google.protobuf.Timestamp
        (*User)(nil),                         // 12: budget.v1.User
        (*Tenant)(nil),                       // 13: budget.v1.Tenant
        (*TenantMembership)(nil),             // 14: budget.v1.TenantMembership
}
var file_budget_v1_auth_proto_depIdxs = []int32{
        11, // 0: budget.v1.TokenPair.access_token_expires_at:type_name -&gt; google.protobuf.Timestamp
        11, // 1: budget.v1.TokenPair.refresh_token_expires_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 2: budget.v1.RegisterResponse.tokens:type_name -&gt; budget.v1.TokenPair
        12, // 3: budget.v1.RegisterResponse.user:type_name -&gt; budget.v1.User
        13, // 4: budget.v1.RegisterResponse.tenant:type_name -&gt; budget.v1.Tenant
        0,  // 5: budget.v1.LoginResponse.tokens:type_name -&gt; budget.v1.TokenPair
        14, // 6: budget.v1.LoginResponse.memberships:type_name -&gt; budget.v1.TenantMembership
        0,  // 7: budget.v1.RefreshTokenResponse.tokens:type_name -&gt; budget.v1.TokenPair
        1,  // 8: budget.v1.AuthService.Register:input_type -&gt; budget.v1.RegisterRequest
        3,  // 9: budget.v1.AuthService.Login:input_type -&gt; budget.v1.LoginRequest
        5,  // 10: budget.v1.AuthService.RefreshToken:input_type -&gt; budget.v1.RefreshTokenRequest
        7,  // 11: budget.v1.AuthService.RequestPasswordReset:input_type -&gt; budget.v1.RequestPasswordResetRequest
        9,  // 12: budget.v1.AuthService.ResetPassword:input_type -&gt; budget.v1.ResetPasswordRequest
        2,  // 13: budget.v1.AuthService.Register:output_type -&gt; budget.v1.RegisterResponse
        4,  // 14: budget.v1.AuthService.Login:output_type -&gt; budget.v1.LoginResponse
        6,  // 15: budget.v1.AuthService.RefreshToken:output_type -&gt; budget.v1.RefreshTokenResponse
        8,  // 16: budget.v1.AuthService.RequestPasswordReset:output_type -&gt; budget.v1.RequestPasswordResetResponse
        10, // 17: budget.v1.AuthService.ResetPassword:output_type -&gt; budget.v1.ResetPasswordResponse
        13, // [13:18] is the sub-list for method output_type
        8,  // [8:13] is the sub-list for method input_type
        8,  // [8:8] is the sub-list for extension type_name
        8,  // [8:8] is the sub-list for extension extendee
        0,  // [0:8] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_auth_proto_init() }</span>
func file_budget_v1_auth_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_user_proto_init()
        file_budget_v1_tenant_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_auth_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TokenPair); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RequestPasswordResetRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RequestPasswordResetResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ResetPasswordRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_auth_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ResetPasswordResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_auth_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   11,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_auth_proto_goTypes,
                DependencyIndexes: file_budget_v1_auth_proto_depIdxs,
                MessageInfos:      file_budget_v1_auth_proto_msgTypes,
        }.Build()
        File_budget_v1_auth_proto = out.File
        file_budget_v1_auth_proto_rawDesc = nil
        file_budget_v1_auth_proto_goTypes = nil
        file_budget_v1_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/auth.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        AuthService_Register_FullMethodName             = "/budget.v1.AuthService/Register"
        AuthService_Login_FullMethodName                = "/budget.v1.AuthService/Login"
        AuthService_RefreshToken_FullMethodName         = "/budget.v1.AuthService/RefreshToken"
        AuthService_RequestPasswordReset_FullMethodName = "/budget.v1.AuthService/RequestPasswordReset"
        AuthService_ResetPassword_FullMethodName        = "/budget.v1.AuthService/ResetPassword"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
        RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*RequestPasswordResetResponse, error)
        ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        out := new(RefreshTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*RequestPasswordResetResponse, error) <span class="cov0" title="0">{
        out := new(RequestPasswordResetResponse)
        err := c.cc.Invoke(ctx, AuthService_RequestPasswordReset_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) <span class="cov0" title="0">{
        out := new(ResetPasswordResponse)
        err := c.cc.Invoke(ctx, AuthService_ResetPassword_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
        RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*RequestPasswordResetResponse, error)
        ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*RequestPasswordResetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RequestPasswordReset not implemented")
}</span>
func (UnimplementedAuthServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;AuthService_ServiceDesc, srv)
}</span>

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RefreshToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RequestPasswordResetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RequestPasswordReset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RequestPasswordReset_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RequestPasswordReset(ctx, req.(*RequestPasswordResetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ResetPasswordRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ResetPassword(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ResetPassword_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _AuthService_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "RefreshToken",
                        Handler:    _AuthService_RefreshToken_Handler,
                },
                {
                        MethodName: "RequestPasswordReset",
                        Handler:    _AuthService_RequestPasswordReset_Handler,
                },
                {
                        MethodName: "ResetPassword",
                        Handler:    _AuthService_ResetPassword_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/auth.proto",
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/category.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CategoryTranslation struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Locale      string `protobuf:"bytes,1,opt,name=locale,proto3" json:"locale,omitempty"` // e.g. "en", "ru"
        Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *CategoryTranslation) Reset() <span class="cov0" title="0">{
        *x = CategoryTranslation{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CategoryTranslation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CategoryTranslation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CategoryTranslation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CategoryTranslation.ProtoReflect.Descriptor instead.
func (*CategoryTranslation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CategoryTranslation) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CategoryTranslation) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CategoryTranslation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Category struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id           string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                  // UUID
        TenantId     string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`      // UUID
        Kind         CategoryKind           `protobuf:"varint,3,opt,name=kind,proto3,enum=budget.v1.CategoryKind" json:"kind,omitempty"` // income / expense
        Code         string                 `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`                              // unique per tenant+kind
        ParentId     string                 `protobuf:"bytes,5,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`      // optional (for hierarchy)
        IsActive     bool                   `protobuf:"varint,6,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        CreatedAt    *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        Translations []*CategoryTranslation `protobuf:"bytes,8,rep,name=translations,proto3" json:"translations,omitempty"`
}

func (x *Category) Reset() <span class="cov0" title="0">{
        *x = Category{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Category) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Category) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Category) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Category.ProtoReflect.Descriptor instead.
func (*Category) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Category) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Category) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Category) GetKind() CategoryKind <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return CategoryKind_CATEGORY_KIND_UNSPECIFIED</span>
}

func (x *Category) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Category) GetParentId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ParentId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Category) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Category) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Category) GetTranslations() []*CategoryTranslation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Translations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Kind         CategoryKind           `protobuf:"varint,1,opt,name=kind,proto3,enum=budget.v1.CategoryKind" json:"kind,omitempty"`
        Code         string                 `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
        ParentId     string                 `protobuf:"bytes,3,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
        IsActive     bool                   `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        Translations []*CategoryTranslation `protobuf:"bytes,5,rep,name=translations,proto3" json:"translations,omitempty"`
}

func (x *CreateCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = CreateCategoryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCategoryRequest.ProtoReflect.Descriptor instead.
func (*CreateCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateCategoryRequest) GetKind() CategoryKind <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return CategoryKind_CATEGORY_KIND_UNSPECIFIED</span>
}

func (x *CreateCategoryRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateCategoryRequest) GetParentId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ParentId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateCategoryRequest) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *CreateCategoryRequest) GetTranslations() []*CategoryTranslation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Translations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateCategoryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Category *Category `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *CreateCategoryResponse) Reset() <span class="cov0" title="0">{
        *x = CreateCategoryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateCategoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCategoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCategoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCategoryResponse.ProtoReflect.Descriptor instead.
func (*CreateCategoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreateCategoryResponse) GetCategory() *Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id           string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Code         string                 `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
        ParentId     string                 `protobuf:"bytes,3,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
        IsActive     bool                   `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        Translations []*CategoryTranslation `protobuf:"bytes,5,rep,name=translations,proto3" json:"translations,omitempty"`
}

func (x *UpdateCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateCategoryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateCategoryRequest.ProtoReflect.Descriptor instead.
func (*UpdateCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UpdateCategoryRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateCategoryRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateCategoryRequest) GetParentId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ParentId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateCategoryRequest) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateCategoryRequest) GetTranslations() []*CategoryTranslation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Translations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateCategoryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Category *Category `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *UpdateCategoryResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateCategoryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateCategoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateCategoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateCategoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateCategoryResponse.ProtoReflect.Descriptor instead.
func (*UpdateCategoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UpdateCategoryResponse) GetCategory() *Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteCategoryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteCategoryRequest.ProtoReflect.Descriptor instead.
func (*DeleteCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{6}
}</span>

func (x *DeleteCategoryRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteCategoryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *DeleteCategoryResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteCategoryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteCategoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteCategoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteCategoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteCategoryResponse.ProtoReflect.Descriptor instead.
func (*DeleteCategoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{7}
}</span>

type GetCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Locale string `protobuf:"bytes,2,opt,name=locale,proto3" json:"locale,omitempty"`
}

func (x *GetCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = GetCategoryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCategoryRequest.ProtoReflect.Descriptor instead.
func (*GetCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetCategoryRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetCategoryRequest) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetCategoryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Category *Category `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *GetCategoryResponse) Reset() <span class="cov0" title="0">{
        *x = GetCategoryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetCategoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCategoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCategoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCategoryResponse.ProtoReflect.Descriptor instead.
func (*GetCategoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetCategoryResponse) GetCategory() *Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCategoriesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Kind            CategoryKind `protobuf:"varint,1,opt,name=kind,proto3,enum=budget.v1.CategoryKind" json:"kind,omitempty"`
        IncludeInactive bool         `protobuf:"varint,2,opt,name=include_inactive,json=includeInactive,proto3" json:"include_inactive,omitempty"`
        Locale          string       `protobuf:"bytes,3,opt,name=locale,proto3" json:"locale,omitempty"` // preferred translation
}

func (x *ListCategoriesRequest) Reset() <span class="cov0" title="0">{
        *x = ListCategoriesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListCategoriesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCategoriesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCategoriesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCategoriesRequest.ProtoReflect.Descriptor instead.
func (*ListCategoriesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListCategoriesRequest) GetKind() CategoryKind <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return CategoryKind_CATEGORY_KIND_UNSPECIFIED</span>
}

func (x *ListCategoriesRequest) GetIncludeInactive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IncludeInactive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ListCategoriesRequest) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListCategoriesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Categories []*Category `protobuf:"bytes,1,rep,name=categories,proto3" json:"categories,omitempty"`
}

func (x *ListCategoriesResponse) Reset() <span class="cov0" title="0">{
        *x = ListCategoriesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_category_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListCategoriesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCategoriesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCategoriesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_category_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCategoriesResponse.ProtoReflect.Descriptor instead.
func (*ListCategoriesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_category_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ListCategoriesResponse) GetCategories() []*Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Categories
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_budget_v1_category_proto protoreflect.FileDescriptor

var file_budget_v1_category_proto_rawDesc = []byte{
        0x0a, 0x18, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76,
        0x31, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x63,
        0x0a, 0x13, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6c,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x22, 0xb1, 0x02, 0x0a, 0x08, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x2b, 0x0a,
        0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
        0x4b, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f,
        0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x1b,
        0x0a, 0x09, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x08, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69,
        0x73, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
        0x69, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x41, 0x74, 0x12, 0x42, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73,
        0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xd6, 0x01, 0x0a, 0x15, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x2b, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
        0x17, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x4b, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x12, 0x12,
        0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f,
        0x64, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12,
        0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x42, 0x0a, 0x0c,
        0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x22, 0x49, 0x0a, 0x16, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x08, 0x63, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x79, 0x52, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x22, 0xb9, 0x01, 0x0a, 0x15,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x72,
        0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61,
        0x72, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61, 0x63, 0x74,
        0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41, 0x63, 0x74,
        0x69, 0x76, 0x65, 0x12, 0x42, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73,
        0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x49, 0x0a, 0x16, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x2f, 0x0a, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x79, 0x22, 0x27, 0x0a, 0x15, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x18, 0x0a, 0x16, 0x44,
        0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x3c, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6c,
        0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x63,
        0x61, 0x6c, 0x65, 0x22, 0x46, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x08, 0x63, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x79, 0x52, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x22, 0x87, 0x01, 0x0a, 0x15,
        0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2b, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x4b, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x6b, 0x69,
        0x6e, 0x64, 0x12, 0x29, 0x0a, 0x10, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x6e,
        0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x69, 0x6e,
        0x63, 0x6c, 0x75, 0x64, 0x65, 0x49, 0x6e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x16, 0x0a,
        0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c,
        0x6f, 0x63, 0x61, 0x6c, 0x65, 0x22, 0x4d, 0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x33, 0x0a, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x69, 0x65, 0x73, 0x32, 0xbb, 0x03, 0x0a, 0x0f, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x55, 0x0a, 0x0e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x79, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
        0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c, 0x0a,
        0x0b, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x1d, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x4c,
        0x69, 0x73, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x12, 0x20, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74,
        0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_category_proto_rawDescOnce sync.Once
        file_budget_v1_category_proto_rawDescData = file_budget_v1_category_proto_rawDesc
)

func file_budget_v1_category_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_category_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_category_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_category_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_category_proto_rawDescData</span>
}

var file_budget_v1_category_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_budget_v1_category_proto_goTypes = []interface{}{
        (*CategoryTranslation)(nil),    // 0: budget.v1.CategoryTranslation
        (*Category)(nil),               // 1: budget.v1.Category
        (*CreateCategoryRequest)(nil),  // 2: budget.v1.CreateCategoryRequest
        (*CreateCategoryResponse)(nil), // 3: budget.v1.CreateCategoryResponse
        (*UpdateCategoryRequest)(nil),  // 4: budget.v1.UpdateCategoryRequest
        (*UpdateCategoryResponse)(nil), // 5: budget.v1.UpdateCategoryResponse
        (*DeleteCategoryRequest)(nil),  // 6: budget.v1.DeleteCategoryRequest
        (*DeleteCategoryResponse)(nil), // 7: budget.v1.DeleteCategoryResponse
        (*GetCategoryRequest)(nil),     // 8: budget.v1.GetCategoryRequest
        (*GetCategoryResponse)(nil),    // 9: budget.v1.GetCategoryResponse
        (*ListCategoriesRequest)(nil),  // 10: budget.v1.ListCategoriesRequest
        (*ListCategoriesResponse)(nil), // 11: budget.v1.ListCategoriesResponse
        (CategoryKind)(0),              // 12: budget.v1.CategoryKind
        (*timestamppb.Timestamp)(nil),  // 13: google.protobuf.Timestamp
}
var file_budget_v1_category_proto_depIdxs = []int32{
        12, // 0: budget.v1.Category.kind:type_name -&gt; budget.v1.CategoryKind
        13, // 1: budget.v1.Category.created_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 2: budget.v1.Category.translations:type_name -&gt; budget.v1.CategoryTranslation
        12, // 3: budget.v1.CreateCategoryRequest.kind:type_name -&gt; budget.v1.CategoryKind
        0,  // 4: budget.v1.CreateCategoryRequest.translations:type_name -&gt; budget.v1.CategoryTranslation
        1,  // 5: budget.v1.CreateCategoryResponse.category:type_name -&gt; budget.v1.Category
        0,  // 6: budget.v1.UpdateCategoryRequest.translations:type_name -&gt; budget.v1.CategoryTranslation
        1,  // 7: budget.v1.UpdateCategoryResponse.category:type_name -&gt; budget.v1.Category
        1,  // 8: budget.v1.GetCategoryResponse.category:type_name -&gt; budget.v1.Category
        12, // 9: budget.v1.ListCategoriesRequest.kind:type_name -&gt; budget.v1.CategoryKind
        1,  // 10: budget.v1.ListCategoriesResponse.categories:type_name -&gt; budget.v1.Category
        2,  // 11: budget.v1.CategoryService.CreateCategory:input_type -&gt; budget.v1.CreateCategoryRequest
        4,  // 12: budget.v1.CategoryService.UpdateCategory:input_type -&gt; budget.v1.UpdateCategoryRequest
        6,  // 13: budget.v1.CategoryService.DeleteCategory:input_type -&gt; budget.v1.DeleteCategoryRequest
        8,  // 14: budget.v1.CategoryService.GetCategory:input_type -&gt; budget.v1.GetCategoryRequest
        10, // 15: budget.v1.CategoryService.ListCategories:input_type -&gt; budget.v1.ListCategoriesRequest
        3,  // 16: budget.v1.CategoryService.CreateCategory:output_type -&gt; budget.v1.CreateCategoryResponse
        5,  // 17: budget.v1.CategoryService.UpdateCategory:output_type -&gt; budget.v1.UpdateCategoryResponse
        7,  // 18: budget.v1.CategoryService.DeleteCategory:output_type -&gt; budget.v1.DeleteCategoryResponse
        9,  // 19: budget.v1.CategoryService.GetCategory:output_type -&gt; budget.v1.GetCategoryResponse
        11, // 20: budget.v1.CategoryService.ListCategories:output_type -&gt; budget.v1.ListCategoriesResponse
        16, // [16:21] is the sub-list for method output_type
        11, // [11:16] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_category_proto_init() }</span>
func file_budget_v1_category_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_category_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_category_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CategoryTranslation); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Category); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateCategoryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateCategoryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateCategoryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateCategoryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteCategoryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteCategoryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetCategoryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetCategoryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListCategoriesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_category_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListCategoriesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_category_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   12,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_category_proto_goTypes,
                DependencyIndexes: file_budget_v1_category_proto_depIdxs,
                MessageInfos:      file_budget_v1_category_proto_msgTypes,
        }.Build()
        File_budget_v1_category_proto = out.File
        file_budget_v1_category_proto_rawDesc = nil
        file_budget_v1_category_proto_goTypes = nil
        file_budget_v1_category_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/category.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        CategoryService_CreateCategory_FullMethodName = "/budget.v1.CategoryService/CreateCategory"
        CategoryService_UpdateCategory_FullMethodName = "/budget.v1.CategoryService/UpdateCategory"
        CategoryService_DeleteCategory_FullMethodName = "/budget.v1.CategoryService/DeleteCategory"
        CategoryService_GetCategory_FullMethodName    = "/budget.v1.CategoryService/GetCategory"
        CategoryService_ListCategories_FullMethodName = "/budget.v1.CategoryService/ListCategories"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryServiceClient interface {
        CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error)
        UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error)
        DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*DeleteCategoryResponse, error)
        GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*GetCategoryResponse, error)
        ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
}

type categoryServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient <span class="cov0" title="0">{
        return &amp;categoryServiceClient{cc}
}</span>

func (c *categoryServiceClient) CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error) <span class="cov0" title="0">{
        out := new(CreateCategoryResponse)
        err := c.cc.Invoke(ctx, CategoryService_CreateCategory_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *categoryServiceClient) UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error) <span class="cov0" title="0">{
        out := new(UpdateCategoryResponse)
        err := c.cc.Invoke(ctx, CategoryService_UpdateCategory_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*DeleteCategoryResponse, error) <span class="cov0" title="0">{
        out := new(DeleteCategoryResponse)
        err := c.cc.Invoke(ctx, CategoryService_DeleteCategory_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *categoryServiceClient) GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*GetCategoryResponse, error) <span class="cov0" title="0">{
        out := new(GetCategoryResponse)
        err := c.cc.Invoke(ctx, CategoryService_GetCategory_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *categoryServiceClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) <span class="cov0" title="0">{
        out := new(ListCategoriesResponse)
        err := c.cc.Invoke(ctx, CategoryService_ListCategories_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility
type CategoryServiceServer interface {
        CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error)
        UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error)
        DeleteCategory(context.Context, *DeleteCategoryRequest) (*DeleteCategoryResponse, error)
        GetCategory(context.Context, *GetCategoryRequest) (*GetCategoryResponse, error)
        ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
        mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCategoryServiceServer struct {
}

func (UnimplementedCategoryServiceServer) CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}</span>
func (UnimplementedCategoryServiceServer) UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateCategory not implemented")
}</span>
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *DeleteCategoryRequest) (*DeleteCategoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}</span>
func (UnimplementedCategoryServiceServer) GetCategory(context.Context, *GetCategoryRequest) (*GetCategoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCategory not implemented")
}</span>
func (UnimplementedCategoryServiceServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCategories not implemented")
}</span>
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
        mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;CategoryService_ServiceDesc, srv)
}</span>

func _CategoryService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).CreateCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CategoryService_CreateCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).CreateCategory(ctx, req.(*CreateCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CategoryService_UpdateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).UpdateCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CategoryService_UpdateCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).UpdateCategory(ctx, req.(*UpdateCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CategoryService_DeleteCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*DeleteCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CategoryService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).GetCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CategoryService_GetCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).GetCategory(ctx, req.(*GetCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CategoryService_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListCategoriesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).ListCategories(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CategoryService_ListCategories_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoryServiceServer).ListCategories(ctx, req.(*ListCategoriesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.CategoryService",
        HandlerType: (*CategoryServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateCategory",
                        Handler:    _CategoryService_CreateCategory_Handler,
                },
                {
                        MethodName: "UpdateCategory",
                        Handler:    _CategoryService_UpdateCategory_Handler,
                },
                {
                        MethodName: "DeleteCategory",
                        Handler:    _CategoryService_DeleteCategory_Handler,
                },
                {
                        MethodName: "GetCategory",
                        Handler:    _CategoryService_GetCategory_Handler,
                },
                {
                        MethodName: "ListCategories",
                        Handler:    _CategoryService_ListCategories_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/category.proto",
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/common.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TransactionType int32

const (
        TransactionType_TRANSACTION_TYPE_UNSPECIFIED TransactionType = 0
        TransactionType_TRANSACTION_TYPE_INCOME      TransactionType = 1
        TransactionType_TRANSACTION_TYPE_EXPENSE     TransactionType = 2
)

// Enum value maps for TransactionType.
var (
        TransactionType_name = map[int32]string{
                0: "TRANSACTION_TYPE_UNSPECIFIED",
                1: "TRANSACTION_TYPE_INCOME",
                2: "TRANSACTION_TYPE_EXPENSE",
        }
        TransactionType_value = map[string]int32{
                "TRANSACTION_TYPE_UNSPECIFIED": 0,
                "TRANSACTION_TYPE_INCOME":      1,
                "TRANSACTION_TYPE_EXPENSE":     2,
        }
)

func (x TransactionType) Enum() *TransactionType <span class="cov0" title="0">{
        p := new(TransactionType)
        *p = x
        return p
}</span>

func (x TransactionType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TransactionType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_budget_v1_common_proto_enumTypes[0].Descriptor()
}</span>

func (TransactionType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_budget_v1_common_proto_enumTypes[0]
}</span>

func (x TransactionType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TransactionType.Descriptor instead.
func (TransactionType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{0}
}</span>

type CategoryKind int32

const (
        CategoryKind_CATEGORY_KIND_UNSPECIFIED CategoryKind = 0
        CategoryKind_CATEGORY_KIND_INCOME      CategoryKind = 1
        CategoryKind_CATEGORY_KIND_EXPENSE     CategoryKind = 2
)

// Enum value maps for CategoryKind.
var (
        CategoryKind_name = map[int32]string{
                0: "CATEGORY_KIND_UNSPECIFIED",
                1: "CATEGORY_KIND_INCOME",
                2: "CATEGORY_KIND_EXPENSE",
        }
        CategoryKind_value = map[string]int32{
                "CATEGORY_KIND_UNSPECIFIED": 0,
                "CATEGORY_KIND_INCOME":      1,
                "CATEGORY_KIND_EXPENSE":     2,
        }
)

func (x CategoryKind) Enum() *CategoryKind <span class="cov0" title="0">{
        p := new(CategoryKind)
        *p = x
        return p
}</span>

func (x CategoryKind) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (CategoryKind) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_budget_v1_common_proto_enumTypes[1].Descriptor()
}</span>

func (CategoryKind) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_budget_v1_common_proto_enumTypes[1]
}</span>

func (x CategoryKind) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use CategoryKind.Descriptor instead.
func (CategoryKind) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{1}
}</span>

// Generic money representation using minor currency units (e.g., cents)
type Money struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CurrencyCode string `protobuf:"bytes,1,opt,name=currency_code,json=currencyCode,proto3" json:"currency_code,omitempty"` // ISO 4217, e.g. "USD", "EUR", "RUB"
        MinorUnits   int64  `protobuf:"varint,2,opt,name=minor_units,json=minorUnits,proto3" json:"minor_units,omitempty"`      // integer number of minor units (cents/kopecks)
}

func (x *Money) Reset() <span class="cov0" title="0">{
        *x = Money{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_common_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Money) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Money) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Money) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_common_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Money.ProtoReflect.Descriptor instead.
func (*Money) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Money) GetCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Money) GetMinorUnits() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinorUnits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Foreign exchange info applied to a conversion at a specific date
// Semantics: to_amount = from_amount * rate_decimal
type FxInfo struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FromCurrencyCode string                 `protobuf:"bytes,1,opt,name=from_currency_code,json=fromCurrencyCode,proto3" json:"from_currency_code,omitempty"` // original currency
        ToCurrencyCode   string                 `protobuf:"bytes,2,opt,name=to_currency_code,json=toCurrencyCode,proto3" json:"to_currency_code,omitempty"`       // target/base currency
        RateDecimal      string                 `protobuf:"bytes,3,opt,name=rate_decimal,json=rateDecimal,proto3" json:"rate_decimal,omitempty"`                  // decimal string, e.g. "92.3456"
        AsOf             *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`                                       // date/time the rate was taken for
        Provider         string                 `protobuf:"bytes,5,opt,name=provider,proto3" json:"provider,omitempty"`                                           // e.g. "ecb", "cbr", "manual"
}

func (x *FxInfo) Reset() <span class="cov0" title="0">{
        *x = FxInfo{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_common_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FxInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FxInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FxInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_common_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FxInfo.ProtoReflect.Descriptor instead.
func (*FxInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FxInfo) GetFromCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxInfo) GetToCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxInfo) GetRateDecimal() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RateDecimal
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxInfo) GetAsOf() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AsOf
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FxInfo) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PageRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Page     int32  `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`                         // 1-based
        PageSize int32  `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"` // max enforced server-side
        Sort     string `protobuf:"bytes,3,opt,name=sort,proto3" json:"sort,omitempty"`                          // e.g. "occurred_at desc"
}

func (x *PageRequest) Reset() <span class="cov0" title="0">{
        *x = PageRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_common_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PageRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PageRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PageRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_common_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PageRequest.ProtoReflect.Descriptor instead.
func (*PageRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{2}
}</span>

func (x *PageRequest) GetPage() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PageRequest) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PageRequest) GetSort() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PageResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Page       int32 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
        PageSize   int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
        TotalItems int64 `protobuf:"varint,3,opt,name=total_items,json=totalItems,proto3" json:"total_items,omitempty"`
        TotalPages int32 `protobuf:"varint,4,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
}

func (x *PageResponse) Reset() <span class="cov0" title="0">{
        *x = PageResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_common_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PageResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PageResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PageResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_common_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PageResponse.ProtoReflect.Descriptor instead.
func (*PageResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{3}
}</span>

func (x *PageResponse) GetPage() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PageResponse) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PageResponse) GetTotalItems() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PageResponse) GetTotalPages() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalPages
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DateRange struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        From *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
        To   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (x *DateRange) Reset() <span class="cov0" title="0">{
        *x = DateRange{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_common_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DateRange) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DateRange) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DateRange) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_common_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DateRange.ProtoReflect.Descriptor instead.
func (*DateRange) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_common_proto_rawDescGZIP(), []int{4}
}</span>

func (x *DateRange) GetFrom() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.From
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DateRange) GetTo() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.To
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_budget_v1_common_proto protoreflect.FileDescriptor

var file_budget_v1_common_proto_rawDesc = []byte{
        0x0a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
        0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x22, 0x4d, 0x0a, 0x05, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x12, 0x23, 0x0a,
        0x0d, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f,
        0x64, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x75, 0x6e, 0x69, 0x74,
        0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x55, 0x6e,
        0x69, 0x74, 0x73, 0x22, 0xd0, 0x01, 0x0a, 0x06, 0x46, 0x78, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c,
        0x0a, 0x12, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f,
        0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x66, 0x72, 0x6f, 0x6d,
        0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10,
        0x74, 0x6f, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e,
        0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x64,
        0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x72, 0x61,
        0x74, 0x65, 0x44, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x12, 0x2f, 0x0a, 0x05, 0x61, 0x73, 0x5f,
        0x6f, 0x66, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x61, 0x73, 0x4f, 0x66, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x22, 0x52, 0x0a, 0x0b, 0x50, 0x61, 0x67, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x67,
        0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70, 0x61,
        0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x22, 0x81, 0x01, 0x0a, 0x0c, 0x50,
        0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x70,
        0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x61, 0x67, 0x65, 0x12,
        0x1b, 0x0a, 0x09, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x08, 0x70, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x1f, 0x0a, 0x0b,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x03, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x1f, 0x0a,
        0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61, 0x67, 0x65, 0x73, 0x22, 0x67,
        0x0a, 0x09, 0x44, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x2e, 0x0a, 0x04, 0x66,
        0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x2a, 0x0a, 0x02, 0x74,
        0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x02, 0x74, 0x6f, 0x2a, 0x6e, 0x0a, 0x0f, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x54, 0x52,
        0x41, 0x4e, 0x53, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55,
        0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17,
        0x54, 0x52, 0x41, 0x4e, 0x53, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45,
        0x5f, 0x49, 0x4e, 0x43, 0x4f, 0x4d, 0x45, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x54, 0x52, 0x41,
        0x4e, 0x53, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x45, 0x58,
        0x50, 0x45, 0x4e, 0x53, 0x45, 0x10, 0x02, 0x2a, 0x62, 0x0a, 0x0c, 0x43, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x79, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0x1d, 0x0a, 0x19, 0x43, 0x41, 0x54, 0x45, 0x47,
        0x4f, 0x52, 0x59, 0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49,
        0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x41, 0x54, 0x45, 0x47, 0x4f,
        0x52, 0x59, 0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f, 0x49, 0x4e, 0x43, 0x4f, 0x4d, 0x45, 0x10, 0x01,
        0x12, 0x19, 0x0a, 0x15, 0x43, 0x41, 0x54, 0x45, 0x47, 0x4f, 0x52, 0x59, 0x5f, 0x4b, 0x49, 0x4e,
        0x44, 0x5f, 0x45, 0x58, 0x50, 0x45, 0x4e, 0x53, 0x45, 0x10, 0x02, 0x42, 0x38, 0x5a, 0x36, 0x67,
        0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72,
        0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f,
        0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_common_proto_rawDescOnce sync.Once
        file_budget_v1_common_proto_rawDescData = file_budget_v1_common_proto_rawDesc
)

func file_budget_v1_common_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_common_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_common_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_common_proto_rawDescData</span>
}

var file_budget_v1_common_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_budget_v1_common_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_budget_v1_common_proto_goTypes = []interface{}{
        (TransactionType)(0),          // 0: budget.v1.TransactionType
        (CategoryKind)(0),             // 1: budget.v1.CategoryKind
        (*Money)(nil),                 // 2: budget.v1.Money
        (*FxInfo)(nil),                // 3: budget.v1.FxInfo
        (*PageRequest)(nil),           // 4: budget.v1.PageRequest
        (*PageResponse)(nil),          // 5: budget.v1.PageResponse
        (*DateRange)(nil),             // 6: budget.v1.DateRange
        (*timestamppb.Timestamp)(nil), // 7: google.protobuf.Timestamp
}
var file_budget_v1_common_proto_depIdxs = []int32{
        7, // 0: budget.v1.FxInfo.as_of:type_name -&gt; google.protobuf.Timestamp
        7, // 1: budget.v1.DateRange.from:type_name -&gt; google.protobuf.Timestamp
        7, // 2: budget.v1.DateRange.to:type_name -&gt; google.protobuf.Timestamp
        3, // [3:3] is the sub-list for method output_type
        3, // [3:3] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_common_proto_init() }</span>
func file_budget_v1_common_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_common_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_common_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Money); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_common_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FxInfo); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_common_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PageRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_common_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PageResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_common_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DateRange); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_common_proto_rawDesc,
                        NumEnums:      2,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_budget_v1_common_proto_goTypes,
                DependencyIndexes: file_budget_v1_common_proto_depIdxs,
                EnumInfos:         file_budget_v1_common_proto_enumTypes,
                MessageInfos:      file_budget_v1_common_proto_msgTypes,
        }.Build()
        File_budget_v1_common_proto = out.File
        file_budget_v1_common_proto_rawDesc = nil
        file_budget_v1_common_proto_goTypes = nil
        file_budget_v1_common_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/fx.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents a single FX rate quote (from → to) as of specific date/time
type FxRate struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FromCurrencyCode string                 `protobuf:"bytes,1,opt,name=from_currency_code,json=fromCurrencyCode,proto3" json:"from_currency_code,omitempty"` // e.g. "USD"
        ToCurrencyCode   string                 `protobuf:"bytes,2,opt,name=to_currency_code,json=toCurrencyCode,proto3" json:"to_currency_code,omitempty"`       // e.g. "RUB"
        RateDecimal      string                 `protobuf:"bytes,3,opt,name=rate_decimal,json=rateDecimal,proto3" json:"rate_decimal,omitempty"`                  // e.g. "92.3456"
        AsOf             *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`
        Provider         string                 `protobuf:"bytes,5,opt,name=provider,proto3" json:"provider,omitempty"` // e.g. "ecb", "cbr", "manual"
}

func (x *FxRate) Reset() <span class="cov0" title="0">{
        *x = FxRate{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FxRate) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FxRate) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FxRate) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FxRate.ProtoReflect.Descriptor instead.
func (*FxRate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FxRate) GetFromCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxRate) GetToCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxRate) GetRateDecimal() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RateDecimal
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FxRate) GetAsOf() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AsOf
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FxRate) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRateRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FromCurrencyCode string                 `protobuf:"bytes,1,opt,name=from_currency_code,json=fromCurrencyCode,proto3" json:"from_currency_code,omitempty"`
        ToCurrencyCode   string                 `protobuf:"bytes,2,opt,name=to_currency_code,json=toCurrencyCode,proto3" json:"to_currency_code,omitempty"`
        AsOf             *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"` // date at which to get the rate (truncate to day server-side if needed)
}

func (x *GetRateRequest) Reset() <span class="cov0" title="0">{
        *x = GetRateRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetRateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRateRequest.ProtoReflect.Descriptor instead.
func (*GetRateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetRateRequest) GetFromCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetRateRequest) GetToCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetRateRequest) GetAsOf() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AsOf
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetRateResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rate *FxRate `protobuf:"bytes,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (x *GetRateResponse) Reset() <span class="cov0" title="0">{
        *x = GetRateResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetRateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRateResponse.ProtoReflect.Descriptor instead.
func (*GetRateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetRateResponse) GetRate() *FxRate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpsertRateRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rate *FxRate `protobuf:"bytes,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (x *UpsertRateRequest) Reset() <span class="cov0" title="0">{
        *x = UpsertRateRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpsertRateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpsertRateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpsertRateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpsertRateRequest.ProtoReflect.Descriptor instead.
func (*UpsertRateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UpsertRateRequest) GetRate() *FxRate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpsertRateResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rate *FxRate `protobuf:"bytes,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (x *UpsertRateResponse) Reset() <span class="cov0" title="0">{
        *x = UpsertRateResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpsertRateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpsertRateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpsertRateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpsertRateResponse.ProtoReflect.Descriptor instead.
func (*UpsertRateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UpsertRateResponse) GetRate() *FxRate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchGetRatesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FromCurrencyCodes []string               `protobuf:"bytes,1,rep,name=from_currency_codes,json=fromCurrencyCodes,proto3" json:"from_currency_codes,omitempty"`
        ToCurrencyCode    string                 `protobuf:"bytes,2,opt,name=to_currency_code,json=toCurrencyCode,proto3" json:"to_currency_code,omitempty"`
        AsOf              *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`
}

func (x *BatchGetRatesRequest) Reset() <span class="cov0" title="0">{
        *x = BatchGetRatesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BatchGetRatesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchGetRatesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchGetRatesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchGetRatesRequest.ProtoReflect.Descriptor instead.
func (*BatchGetRatesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{5}
}</span>

func (x *BatchGetRatesRequest) GetFromCurrencyCodes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromCurrencyCodes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BatchGetRatesRequest) GetToCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchGetRatesRequest) GetAsOf() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AsOf
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchGetRatesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rates []*FxRate `protobuf:"bytes,1,rep,name=rates,proto3" json:"rates,omitempty"`
}

func (x *BatchGetRatesResponse) Reset() <span class="cov0" title="0">{
        *x = BatchGetRatesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_fx_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BatchGetRatesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchGetRatesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchGetRatesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_fx_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchGetRatesResponse.ProtoReflect.Descriptor instead.
func (*BatchGetRatesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_fx_proto_rawDescGZIP(), []int{6}
}</span>

func (x *BatchGetRatesResponse) GetRates() []*FxRate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rates
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_budget_v1_fx_proto protoreflect.FileDescriptor

var file_budget_v1_fx_proto_rawDesc = []byte{
        0x0a, 0x12, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x66, 0x78, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x1a,
        0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0xd0, 0x01, 0x0a, 0x06, 0x46, 0x78, 0x52, 0x61, 0x74, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x66,
        0x72, 0x6f, 0x6d, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x75, 0x72,
        0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x6f, 0x5f,
        0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43,
        0x6f, 0x64, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x63, 0x69,
        0x6d, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x72, 0x61, 0x74, 0x65, 0x44,
        0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x12, 0x2f, 0x0a, 0x05, 0x61, 0x73, 0x5f, 0x6f, 0x66, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x52, 0x04, 0x61, 0x73, 0x4f, 0x66, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x22, 0x99, 0x01, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74, 0x65, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2c, 0x0a, 0x12, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x63,
        0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x10, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
        0x43, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x6f, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65,
        0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,
        0x74, 0x6f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x2f,
        0x0a, 0x05, 0x61, 0x73, 0x5f, 0x6f, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x61, 0x73, 0x4f, 0x66, 0x22,
        0x38, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x25, 0x0a, 0x04, 0x72, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x78, 0x52,
        0x61, 0x74, 0x65, 0x52, 0x04, 0x72, 0x61, 0x74, 0x65, 0x22, 0x3a, 0x0a, 0x11, 0x55, 0x70, 0x73,
        0x65, 0x72, 0x74, 0x52, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25,
        0x0a, 0x04, 0x72, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x78, 0x52, 0x61, 0x74, 0x65, 0x52,
        0x04, 0x72, 0x61, 0x74, 0x65, 0x22, 0x3b, 0x0a, 0x12, 0x55, 0x70, 0x73, 0x65, 0x72, 0x74, 0x52,
        0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x04, 0x72,
        0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x78, 0x52, 0x61, 0x74, 0x65, 0x52, 0x04, 0x72, 0x61,
        0x74, 0x65, 0x22, 0xa1, 0x01, 0x0a, 0x14, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x52,
        0x61, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2e, 0x0a, 0x13, 0x66,
        0x72, 0x6f, 0x6d, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64,
        0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x75,
        0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x74,
        0x6f, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63,
        0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x2f, 0x0a, 0x05, 0x61, 0x73, 0x5f, 0x6f, 0x66, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x04, 0x61, 0x73, 0x4f, 0x66, 0x22, 0x40, 0x0a, 0x15, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47,
        0x65, 0x74, 0x52, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x27, 0x0a, 0x05, 0x72, 0x61, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x78, 0x52, 0x61, 0x74,
        0x65, 0x52, 0x05, 0x72, 0x61, 0x74, 0x65, 0x73, 0x32, 0xec, 0x01, 0x0a, 0x09, 0x46, 0x78, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x40, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74,
        0x65, 0x12, 0x19, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65,
        0x74, 0x52, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x49, 0x0a, 0x0a, 0x55, 0x70, 0x73, 0x65,
        0x72, 0x74, 0x52, 0x61, 0x74, 0x65, 0x12, 0x1c, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x55, 0x70, 0x73, 0x65, 0x72, 0x74, 0x52, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x55, 0x70, 0x73, 0x65, 0x72, 0x74, 0x52, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x52,
        0x61, 0x74, 0x65, 0x73, 0x12, 0x1f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x52, 0x61, 0x74, 0x65, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38,
        0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76,
        0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_fx_proto_rawDescOnce sync.Once
        file_budget_v1_fx_proto_rawDescData = file_budget_v1_fx_proto_rawDesc
)

func file_budget_v1_fx_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_fx_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_fx_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_fx_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_fx_proto_rawDescData</span>
}

var file_budget_v1_fx_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_budget_v1_fx_proto_goTypes = []interface{}{
        (*FxRate)(nil),                // 0: budget.v1.FxRate
        (*GetRateRequest)(nil),        // 1: budget.v1.GetRateRequest
        (*GetRateResponse)(nil),       // 2: budget.v1.GetRateResponse
        (*UpsertRateRequest)(nil),     // 3: budget.v1.UpsertRateRequest
        (*UpsertRateResponse)(nil),    // 4: budget.v1.UpsertRateResponse
        (*BatchGetRatesRequest)(nil),  // 5: budget.v1.BatchGetRatesRequest
        (*BatchGetRatesResponse)(nil), // 6: budget.v1.BatchGetRatesResponse
        (*timestamppb.Timestamp)(nil), // 7: google.protobuf.Timestamp
}
var file_budget_v1_fx_proto_depIdxs = []int32{
        7,  // 0: budget.v1.FxRate.as_of:type_name -&gt; google.protobuf.Timestamp
        7,  // 1: budget.v1.GetRateRequest.as_of:type_name -&gt; google.protobuf.Timestamp
        0,  // 2: budget.v1.GetRateResponse.rate:type_name -&gt; budget.v1.FxRate
        0,  // 3: budget.v1.UpsertRateRequest.rate:type_name -&gt; budget.v1.FxRate
        0,  // 4: budget.v1.UpsertRateResponse.rate:type_name -&gt; budget.v1.FxRate
        7,  // 5: budget.v1.BatchGetRatesRequest.as_of:type_name -&gt; google.protobuf.Timestamp
        0,  // 6: budget.v1.BatchGetRatesResponse.rates:type_name -&gt; budget.v1.FxRate
        1,  // 7: budget.v1.FxService.GetRate:input_type -&gt; budget.v1.GetRateRequest
        3,  // 8: budget.v1.FxService.UpsertRate:input_type -&gt; budget.v1.UpsertRateRequest
        5,  // 9: budget.v1.FxService.BatchGetRates:input_type -&gt; budget.v1.BatchGetRatesRequest
        2,  // 10: budget.v1.FxService.GetRate:output_type -&gt; budget.v1.GetRateResponse
        4,  // 11: budget.v1.FxService.UpsertRate:output_type -&gt; budget.v1.UpsertRateResponse
        6,  // 12: budget.v1.FxService.BatchGetRates:output_type -&gt; budget.v1.BatchGetRatesResponse
        10, // [10:13] is the sub-list for method output_type
        7,  // [7:10] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_fx_proto_init() }</span>
func file_budget_v1_fx_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_fx_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_fx_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FxRate); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetRateRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetRateResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpsertRateRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpsertRateResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BatchGetRatesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_fx_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BatchGetRatesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_fx_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   7,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_fx_proto_goTypes,
                DependencyIndexes: file_budget_v1_fx_proto_depIdxs,
                MessageInfos:      file_budget_v1_fx_proto_msgTypes,
        }.Build()
        File_budget_v1_fx_proto = out.File
        file_budget_v1_fx_proto_rawDesc = nil
        file_budget_v1_fx_proto_goTypes = nil
        file_budget_v1_fx_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/fx.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        FxService_GetRate_FullMethodName       = "/budget.v1.FxService/GetRate"
        FxService_UpsertRate_FullMethodName    = "/budget.v1.FxService/UpsertRate"
        FxService_BatchGetRates_FullMethodName = "/budget.v1.FxService/BatchGetRates"
)

// FxServiceClient is the client API for FxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FxServiceClient interface {
        // Returns a rate from one currency to another as of date
        GetRate(ctx context.Context, in *GetRateRequest, opts ...grpc.CallOption) (*GetRateResponse, error)
        // Administrative/manual override of a rate
        UpsertRate(ctx context.Context, in *UpsertRateRequest, opts ...grpc.CallOption) (*UpsertRateResponse, error)
        // Batch query for multiple currencies to the same target
        BatchGetRates(ctx context.Context, in *BatchGetRatesRequest, opts ...grpc.CallOption) (*BatchGetRatesResponse, error)
}

type fxServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewFxServiceClient(cc grpc.ClientConnInterface) FxServiceClient <span class="cov0" title="0">{
        return &amp;fxServiceClient{cc}
}</span>

func (c *fxServiceClient) GetRate(ctx context.Context, in *GetRateRequest, opts ...grpc.CallOption) (*GetRateResponse, error) <span class="cov0" title="0">{
        out := new(GetRateResponse)
        err := c.cc.Invoke(ctx, FxService_GetRate_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *fxServiceClient) UpsertRate(ctx context.Context, in *UpsertRateRequest, opts ...grpc.CallOption) (*UpsertRateResponse, error) <span class="cov0" title="0">{
        out := new(UpsertRateResponse)
        err := c.cc.Invoke(ctx, FxService_UpsertRate_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *fxServiceClient) BatchGetRates(ctx context.Context, in *BatchGetRatesRequest, opts ...grpc.CallOption) (*BatchGetRatesResponse, error) <span class="cov0" title="0">{
        out := new(BatchGetRatesResponse)
        err := c.cc.Invoke(ctx, FxService_BatchGetRates_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// FxServiceServer is the server API for FxService service.
// All implementations must embed UnimplementedFxServiceServer
// for forward compatibility
type FxServiceServer interface {
        // Returns a rate from one currency to another as of date
        GetRate(context.Context, *GetRateRequest) (*GetRateResponse, error)
        // Administrative/manual override of a rate
        UpsertRate(context.Context, *UpsertRateRequest) (*UpsertRateResponse, error)
        // Batch query for multiple currencies to the same target
        BatchGetRates(context.Context, *BatchGetRatesRequest) (*BatchGetRatesResponse, error)
        mustEmbedUnimplementedFxServiceServer()
}

// UnimplementedFxServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFxServiceServer struct {
}

func (UnimplementedFxServiceServer) GetRate(context.Context, *GetRateRequest) (*GetRateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetRate not implemented")
}</span>
func (UnimplementedFxServiceServer) UpsertRate(context.Context, *UpsertRateRequest) (*UpsertRateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpsertRate not implemented")
}</span>
func (UnimplementedFxServiceServer) BatchGetRates(context.Context, *BatchGetRatesRequest) (*BatchGetRatesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchGetRates not implemented")
}</span>
func (UnimplementedFxServiceServer) mustEmbedUnimplementedFxServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeFxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FxServiceServer will
// result in compilation errors.
type UnsafeFxServiceServer interface {
        mustEmbedUnimplementedFxServiceServer()
}

func RegisterFxServiceServer(s grpc.ServiceRegistrar, srv FxServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;FxService_ServiceDesc, srv)
}</span>

func _FxService_GetRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetRateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).GetRate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FxService_GetRate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).GetRate(ctx, req.(*GetRateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _FxService_UpsertRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpsertRateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).UpsertRate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FxService_UpsertRate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).UpsertRate(ctx, req.(*UpsertRateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _FxService_BatchGetRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BatchGetRatesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).BatchGetRates(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FxService_BatchGetRates_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FxServiceServer).BatchGetRates(ctx, req.(*BatchGetRatesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// FxService_ServiceDesc is the grpc.ServiceDesc for FxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FxService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.FxService",
        HandlerType: (*FxServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetRate",
                        Handler:    _FxService_GetRate_Handler,
                },
                {
                        MethodName: "UpsertRate",
                        Handler:    _FxService_UpsertRate_Handler,
                },
                {
                        MethodName: "BatchGetRates",
                        Handler:    _FxService_BatchGetRates_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/fx.proto",
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/import.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StartCsvImportRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Filename  string `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
        Delimiter string `protobuf:"bytes,2,opt,name=delimiter,proto3" json:"delimiter,omitempty"` // default ","
        Quote     string `protobuf:"bytes,3,opt,name=quote,proto3" json:"quote,omitempty"`         // default '"'
        Encoding  string `protobuf:"bytes,4,opt,name=encoding,proto3" json:"encoding,omitempty"`   // default "utf-8"
}

func (x *StartCsvImportRequest) Reset() <span class="cov0" title="0">{
        *x = StartCsvImportRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StartCsvImportRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartCsvImportRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartCsvImportRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartCsvImportRequest.ProtoReflect.Descriptor instead.
func (*StartCsvImportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{0}
}</span>

func (x *StartCsvImportRequest) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StartCsvImportRequest) GetDelimiter() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Delimiter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StartCsvImportRequest) GetQuote() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Quote
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StartCsvImportRequest) GetEncoding() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Encoding
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StartCsvImportResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ImportId string `protobuf:"bytes,1,opt,name=import_id,json=importId,proto3" json:"import_id,omitempty"`
}

func (x *StartCsvImportResponse) Reset() <span class="cov0" title="0">{
        *x = StartCsvImportResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StartCsvImportResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartCsvImportResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartCsvImportResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartCsvImportResponse.ProtoReflect.Descriptor instead.
func (*StartCsvImportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{1}
}</span>

func (x *StartCsvImportResponse) GetImportId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImportId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadCsvChunkRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ImportId string `protobuf:"bytes,1,opt,name=import_id,json=importId,proto3" json:"import_id,omitempty"`
        Chunk    []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
        Last     bool   `protobuf:"varint,3,opt,name=last,proto3" json:"last,omitempty"`
}

func (x *UploadCsvChunkRequest) Reset() <span class="cov0" title="0">{
        *x = UploadCsvChunkRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UploadCsvChunkRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadCsvChunkRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadCsvChunkRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadCsvChunkRequest.ProtoReflect.Descriptor instead.
func (*UploadCsvChunkRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UploadCsvChunkRequest) GetImportId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImportId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UploadCsvChunkRequest) GetChunk() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Chunk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadCsvChunkRequest) GetLast() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Last
        }</span>
        <span class="cov0" title="0">return false</span>
}

type UploadCsvChunkResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ReceivedBytes int64 `protobuf:"varint,1,opt,name=received_bytes,json=receivedBytes,proto3" json:"received_bytes,omitempty"`
}

func (x *UploadCsvChunkResponse) Reset() <span class="cov0" title="0">{
        *x = UploadCsvChunkResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UploadCsvChunkResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadCsvChunkResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadCsvChunkResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadCsvChunkResponse.ProtoReflect.Descriptor instead.
func (*UploadCsvChunkResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UploadCsvChunkResponse) GetReceivedBytes() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReceivedBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CsvColumnMapping struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        DateColumn         string `protobuf:"bytes,1,opt,name=date_column,json=dateColumn,proto3" json:"date_column,omitempty"`
        AmountColumn       string `protobuf:"bytes,2,opt,name=amount_column,json=amountColumn,proto3" json:"amount_column,omitempty"`
        CurrencyCodeColumn string `protobuf:"bytes,3,opt,name=currency_code_column,json=currencyCodeColumn,proto3" json:"currency_code_column,omitempty"` // optional
        TypeColumn         string `protobuf:"bytes,4,opt,name=type_column,json=typeColumn,proto3" json:"type_column,omitempty"`                           // income/expense or signed amounts
        CategoryColumn     string `protobuf:"bytes,5,opt,name=category_column,json=categoryColumn,proto3" json:"category_column,omitempty"`               // to map names → category_ids
        CommentColumn      string `protobuf:"bytes,6,opt,name=comment_column,json=commentColumn,proto3" json:"comment_column,omitempty"`
}

func (x *CsvColumnMapping) Reset() <span class="cov0" title="0">{
        *x = CsvColumnMapping{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CsvColumnMapping) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CsvColumnMapping) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CsvColumnMapping) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CsvColumnMapping.ProtoReflect.Descriptor instead.
func (*CsvColumnMapping) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CsvColumnMapping) GetDateColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CsvColumnMapping) GetAmountColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AmountColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CsvColumnMapping) GetCurrencyCodeColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrencyCodeColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CsvColumnMapping) GetTypeColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TypeColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CsvColumnMapping) GetCategoryColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CsvColumnMapping) GetCommentColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConfigureCsvMappingRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ImportId string            `protobuf:"bytes,1,opt,name=import_id,json=importId,proto3" json:"import_id,omitempty"`
        Mapping  *CsvColumnMapping `protobuf:"bytes,2,opt,name=mapping,proto3" json:"mapping,omitempty"`
}

func (x *ConfigureCsvMappingRequest) Reset() <span class="cov0" title="0">{
        *x = ConfigureCsvMappingRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConfigureCsvMappingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConfigureCsvMappingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConfigureCsvMappingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConfigureCsvMappingRequest.ProtoReflect.Descriptor instead.
func (*ConfigureCsvMappingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ConfigureCsvMappingRequest) GetImportId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImportId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConfigureCsvMappingRequest) GetMapping() *CsvColumnMapping <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Mapping
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConfigureCsvMappingResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ConfigureCsvMappingResponse) Reset() <span class="cov0" title="0">{
        *x = ConfigureCsvMappingResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConfigureCsvMappingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConfigureCsvMappingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConfigureCsvMappingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConfigureCsvMappingResponse.ProtoReflect.Descriptor instead.
func (*ConfigureCsvMappingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{6}
}</span>

type PreviewCsvImportRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ImportId string `protobuf:"bytes,1,opt,name=import_id,json=importId,proto3" json:"import_id,omitempty"`
        Limit    int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *PreviewCsvImportRequest) Reset() <span class="cov0" title="0">{
        *x = PreviewCsvImportRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PreviewCsvImportRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PreviewCsvImportRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PreviewCsvImportRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PreviewCsvImportRequest.ProtoReflect.Descriptor instead.
func (*PreviewCsvImportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{7}
}</span>

func (x *PreviewCsvImportRequest) GetImportId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImportId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PreviewCsvImportRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PreviewCsvImportResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TotalRows   int32 `protobuf:"varint,1,opt,name=total_rows,json=totalRows,proto3" json:"total_rows,omitempty"`
        ValidRows   int32 `protobuf:"varint,2,opt,name=valid_rows,json=validRows,proto3" json:"valid_rows,omitempty"`
        InvalidRows int32 `protobuf:"varint,3,opt,name=invalid_rows,json=invalidRows,proto3" json:"invalid_rows,omitempty"`
}

func (x *PreviewCsvImportResponse) Reset() <span class="cov0" title="0">{
        *x = PreviewCsvImportResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PreviewCsvImportResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PreviewCsvImportResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PreviewCsvImportResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PreviewCsvImportResponse.ProtoReflect.Descriptor instead.
func (*PreviewCsvImportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{8}
}</span>

func (x *PreviewCsvImportResponse) GetTotalRows() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PreviewCsvImportResponse) GetValidRows() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValidRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PreviewCsvImportResponse) GetInvalidRows() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InvalidRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CommitCsvImportRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ImportId string `protobuf:"bytes,1,opt,name=import_id,json=importId,proto3" json:"import_id,omitempty"`
        DryRun   bool   `protobuf:"varint,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (x *CommitCsvImportRequest) Reset() <span class="cov0" title="0">{
        *x = CommitCsvImportRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommitCsvImportRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommitCsvImportRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommitCsvImportRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommitCsvImportRequest.ProtoReflect.Descriptor instead.
func (*CommitCsvImportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{9}
}</span>

func (x *CommitCsvImportRequest) GetImportId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImportId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CommitCsvImportRequest) GetDryRun() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DryRun
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CommitCsvImportResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Inserted int32 `protobuf:"varint,1,opt,name=inserted,proto3" json:"inserted,omitempty"`
        Failed   int32 `protobuf:"varint,2,opt,name=failed,proto3" json:"failed,omitempty"`
}

func (x *CommitCsvImportResponse) Reset() <span class="cov0" title="0">{
        *x = CommitCsvImportResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_import_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommitCsvImportResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommitCsvImportResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommitCsvImportResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_import_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommitCsvImportResponse.ProtoReflect.Descriptor instead.
func (*CommitCsvImportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_import_proto_rawDescGZIP(), []int{10}
}</span>

func (x *CommitCsvImportResponse) GetInserted() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Inserted
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CommitCsvImportResponse) GetFailed() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Failed
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_budget_v1_import_proto protoreflect.FileDescriptor

var file_budget_v1_import_proto_rawDesc = []byte{
        0x0a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x69, 0x6d, 0x70, 0x6f,
        0x72, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x22, 0x83, 0x01, 0x0a, 0x15, 0x53, 0x74, 0x61, 0x72, 0x74, 0x43, 0x73, 0x76,
        0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a,
        0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x64, 0x65, 0x6c,
        0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x65,
        0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x6f, 0x74, 0x65,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x6f, 0x74, 0x65, 0x12, 0x1a, 0x0a,
        0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x22, 0x35, 0x0a, 0x16, 0x53, 0x74, 0x61,
        0x72, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x64,
        0x22, 0x5e, 0x0a, 0x15, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x73, 0x76, 0x43, 0x68, 0x75,
        0x6e, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x6d, 0x70,
        0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x69, 0x6d,
        0x70, 0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x12, 0x0a, 0x04,
        0x6c, 0x61, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x04, 0x6c, 0x61, 0x73, 0x74,
        0x22, 0x3f, 0x0a, 0x16, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x73, 0x76, 0x43, 0x68, 0x75,
        0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x72, 0x65,
        0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x03, 0x52, 0x0d, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x42, 0x79, 0x74, 0x65,
        0x73, 0x22, 0xfb, 0x01, 0x0a, 0x10, 0x43, 0x73, 0x76, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x4d,
        0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x63,
        0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x61, 0x74,
        0x65, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
        0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
        0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x30, 0x0a, 0x14,
        0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x63, 0x6f,
        0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x63, 0x75, 0x72, 0x72,
        0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x1f,
        0x0a, 0x0b, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x79, 0x70, 0x65, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12,
        0x27, 0x0a, 0x0f, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x6c, 0x75,
        0x6d, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x79, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x6d,
        0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x22,
        0x70, 0x0a, 0x1a, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x43, 0x73, 0x76, 0x4d,
        0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a,
        0x09, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x35, 0x0a, 0x07, 0x6d, 0x61,
        0x70, 0x70, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x73, 0x76, 0x43, 0x6f, 0x6c, 0x75, 0x6d,
        0x6e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e,
        0x67, 0x22, 0x1d, 0x0a, 0x1b, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x43, 0x73,
        0x76, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x22, 0x4c, 0x0a, 0x17, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x43, 0x73, 0x76, 0x49, 0x6d,
        0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69,
        0x6d, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
        0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x7b,
        0x0a, 0x18, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f,
        0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x74, 0x6f,
        0x74, 0x61, 0x6c, 0x5f, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x5f, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x76,
        0x61, 0x6c, 0x69, 0x64, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x6e, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x5f, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b,
        0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x52, 0x6f, 0x77, 0x73, 0x22, 0x4e, 0x0a, 0x16, 0x43,
        0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
        0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x22, 0x4d, 0x0a, 0x17, 0x43,
        0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x69, 0x6e, 0x73, 0x65, 0x72, 0x74,
        0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x69, 0x6e, 0x73, 0x65, 0x72, 0x74,
        0x65, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x32, 0xda, 0x03, 0x0a, 0x0d, 0x49,
        0x6d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x55, 0x0a, 0x0e,
        0x53, 0x74, 0x61, 0x72, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x20,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x72, 0x74,
        0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61,
        0x72, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x73, 0x76,
        0x43, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x73, 0x76, 0x43, 0x68, 0x75, 0x6e, 0x6b,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x73, 0x76, 0x43, 0x68, 0x75,
        0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x64, 0x0a, 0x13, 0x43, 0x6f,
        0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x43, 0x73, 0x76, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e,
        0x67, 0x12, 0x25, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
        0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x43, 0x73, 0x76, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e,
        0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x43, 0x73,
        0x76, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x5b, 0x0a, 0x10, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x43, 0x73, 0x76, 0x49, 0x6d,
        0x70, 0x6f, 0x72, 0x74, 0x12, 0x22, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x43, 0x73, 0x76, 0x49,
        0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x58, 0x0a,
        0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74,
        0x12, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d,
        0x6d, 0x69, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x43, 0x73, 0x76, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38,
        0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76,
        0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_import_proto_rawDescOnce sync.Once
        file_budget_v1_import_proto_rawDescData = file_budget_v1_import_proto_rawDesc
)

func file_budget_v1_import_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_import_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_import_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_import_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_import_proto_rawDescData</span>
}

var file_budget_v1_import_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_budget_v1_import_proto_goTypes = []interface{}{
        (*StartCsvImportRequest)(nil),       // 0: budget.v1.StartCsvImportRequest
        (*StartCsvImportResponse)(nil),      // 1: budget.v1.StartCsvImportResponse
        (*UploadCsvChunkRequest)(nil),       // 2: budget.v1.UploadCsvChunkRequest
        (*UploadCsvChunkResponse)(nil),      // 3: budget.v1.UploadCsvChunkResponse
        (*CsvColumnMapping)(nil),            // 4: budget.v1.CsvColumnMapping
        (*ConfigureCsvMappingRequest)(nil),  // 5: budget.v1.ConfigureCsvMappingRequest
        (*ConfigureCsvMappingResponse)(nil), // 6: budget.v1.ConfigureCsvMappingResponse
        (*PreviewCsvImportRequest)(nil),     // 7: budget.v1.PreviewCsvImportRequest
        (*PreviewCsvImportResponse)(nil),    // 8: budget.v1.PreviewCsvImportResponse
        (*CommitCsvImportRequest)(nil),      // 9: budget.v1.CommitCsvImportRequest
        (*CommitCsvImportResponse)(nil),     // 10: budget.v1.CommitCsvImportResponse
}
var file_budget_v1_import_proto_depIdxs = []int32{
        4,  // 0: budget.v1.ConfigureCsvMappingRequest.mapping:type_name -&gt; budget.v1.CsvColumnMapping
        0,  // 1: budget.v1.ImportService.StartCsvImport:input_type -&gt; budget.v1.StartCsvImportRequest
        2,  // 2: budget.v1.ImportService.UploadCsvChunk:input_type -&gt; budget.v1.UploadCsvChunkRequest
        5,  // 3: budget.v1.ImportService.ConfigureCsvMapping:input_type -&gt; budget.v1.ConfigureCsvMappingRequest
        7,  // 4: budget.v1.ImportService.PreviewCsvImport:input_type -&gt; budget.v1.PreviewCsvImportRequest
        9,  // 5: budget.v1.ImportService.CommitCsvImport:input_type -&gt; budget.v1.CommitCsvImportRequest
        1,  // 6: budget.v1.ImportService.StartCsvImport:output_type -&gt; budget.v1.StartCsvImportResponse
        3,  // 7: budget.v1.ImportService.UploadCsvChunk:output_type -&gt; budget.v1.UploadCsvChunkResponse
        6,  // 8: budget.v1.ImportService.ConfigureCsvMapping:output_type -&gt; budget.v1.ConfigureCsvMappingResponse
        8,  // 9: budget.v1.ImportService.PreviewCsvImport:output_type -&gt; budget.v1.PreviewCsvImportResponse
        10, // 10: budget.v1.ImportService.CommitCsvImport:output_type -&gt; budget.v1.CommitCsvImportResponse
        6,  // [6:11] is the sub-list for method output_type
        1,  // [1:6] is the sub-list for method input_type
        1,  // [1:1] is the sub-list for extension type_name
        1,  // [1:1] is the sub-list for extension extendee
        0,  // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_import_proto_init() }</span>
func file_budget_v1_import_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_import_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_import_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StartCsvImportRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StartCsvImportResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UploadCsvChunkRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UploadCsvChunkResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CsvColumnMapping); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ConfigureCsvMappingRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ConfigureCsvMappingResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PreviewCsvImportRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PreviewCsvImportResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CommitCsvImportRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_import_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CommitCsvImportResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_import_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   11,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_import_proto_goTypes,
                DependencyIndexes: file_budget_v1_import_proto_depIdxs,
                MessageInfos:      file_budget_v1_import_proto_msgTypes,
        }.Build()
        File_budget_v1_import_proto = out.File
        file_budget_v1_import_proto_rawDesc = nil
        file_budget_v1_import_proto_goTypes = nil
        file_budget_v1_import_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/import.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        ImportService_StartCsvImport_FullMethodName      = "/budget.v1.ImportService/StartCsvImport"
        ImportService_UploadCsvChunk_FullMethodName      = "/budget.v1.ImportService/UploadCsvChunk"
        ImportService_ConfigureCsvMapping_FullMethodName = "/budget.v1.ImportService/ConfigureCsvMapping"
        ImportService_PreviewCsvImport_FullMethodName    = "/budget.v1.ImportService/PreviewCsvImport"
        ImportService_CommitCsvImport_FullMethodName     = "/budget.v1.ImportService/CommitCsvImport"
)

// ImportServiceClient is the client API for ImportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImportServiceClient interface {
        StartCsvImport(ctx context.Context, in *StartCsvImportRequest, opts ...grpc.CallOption) (*StartCsvImportResponse, error)
        UploadCsvChunk(ctx context.Context, in *UploadCsvChunkRequest, opts ...grpc.CallOption) (*UploadCsvChunkResponse, error)
        ConfigureCsvMapping(ctx context.Context, in *ConfigureCsvMappingRequest, opts ...grpc.CallOption) (*ConfigureCsvMappingResponse, error)
        PreviewCsvImport(ctx context.Context, in *PreviewCsvImportRequest, opts ...grpc.CallOption) (*PreviewCsvImportResponse, error)
        CommitCsvImport(ctx context.Context, in *CommitCsvImportRequest, opts ...grpc.CallOption) (*CommitCsvImportResponse, error)
}

type importServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewImportServiceClient(cc grpc.ClientConnInterface) ImportServiceClient <span class="cov0" title="0">{
        return &amp;importServiceClient{cc}
}</span>

func (c *importServiceClient) StartCsvImport(ctx context.Context, in *StartCsvImportRequest, opts ...grpc.CallOption) (*StartCsvImportResponse, error) <span class="cov0" title="0">{
        out := new(StartCsvImportResponse)
        err := c.cc.Invoke(ctx, ImportService_StartCsvImport_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *importServiceClient) UploadCsvChunk(ctx context.Context, in *UploadCsvChunkRequest, opts ...grpc.CallOption) (*UploadCsvChunkResponse, error) <span class="cov0" title="0">{
        out := new(UploadCsvChunkResponse)
        err := c.cc.Invoke(ctx, ImportService_UploadCsvChunk_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *importServiceClient) ConfigureCsvMapping(ctx context.Context, in *ConfigureCsvMappingRequest, opts ...grpc.CallOption) (*ConfigureCsvMappingResponse, error) <span class="cov0" title="0">{
        out := new(ConfigureCsvMappingResponse)
        err := c.cc.Invoke(ctx, ImportService_ConfigureCsvMapping_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *importServiceClient) PreviewCsvImport(ctx context.Context, in *PreviewCsvImportRequest, opts ...grpc.CallOption) (*PreviewCsvImportResponse, error) <span class="cov0" title="0">{
        out := new(PreviewCsvImportResponse)
        err := c.cc.Invoke(ctx, ImportService_PreviewCsvImport_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *importServiceClient) CommitCsvImport(ctx context.Context, in *CommitCsvImportRequest, opts ...grpc.CallOption) (*CommitCsvImportResponse, error) <span class="cov0" title="0">{
        out := new(CommitCsvImportResponse)
        err := c.cc.Invoke(ctx, ImportService_CommitCsvImport_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ImportServiceServer is the server API for ImportService service.
// All implementations must embed UnimplementedImportServiceServer
// for forward compatibility
type ImportServiceServer interface {
        StartCsvImport(context.Context, *StartCsvImportRequest) (*StartCsvImportResponse, error)
        UploadCsvChunk(context.Context, *UploadCsvChunkRequest) (*UploadCsvChunkResponse, error)
        ConfigureCsvMapping(context.Context, *ConfigureCsvMappingRequest) (*ConfigureCsvMappingResponse, error)
        PreviewCsvImport(context.Context, *PreviewCsvImportRequest) (*PreviewCsvImportResponse, error)
        CommitCsvImport(context.Context, *CommitCsvImportRequest) (*CommitCsvImportResponse, error)
        mustEmbedUnimplementedImportServiceServer()
}

// UnimplementedImportServiceServer must be embedded to have forward compatible implementations.
type UnimplementedImportServiceServer struct {
}

func (UnimplementedImportServiceServer) StartCsvImport(context.Context, *StartCsvImportRequest) (*StartCsvImportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartCsvImport not implemented")
}</span>
func (UnimplementedImportServiceServer) UploadCsvChunk(context.Context, *UploadCsvChunkRequest) (*UploadCsvChunkResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UploadCsvChunk not implemented")
}</span>
func (UnimplementedImportServiceServer) ConfigureCsvMapping(context.Context, *ConfigureCsvMappingRequest) (*ConfigureCsvMappingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ConfigureCsvMapping not implemented")
}</span>
func (UnimplementedImportServiceServer) PreviewCsvImport(context.Context, *PreviewCsvImportRequest) (*PreviewCsvImportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method PreviewCsvImport not implemented")
}</span>
func (UnimplementedImportServiceServer) CommitCsvImport(context.Context, *CommitCsvImportRequest) (*CommitCsvImportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CommitCsvImport not implemented")
}</span>
func (UnimplementedImportServiceServer) mustEmbedUnimplementedImportServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeImportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImportServiceServer will
// result in compilation errors.
type UnsafeImportServiceServer interface {
        mustEmbedUnimplementedImportServiceServer()
}

func RegisterImportServiceServer(s grpc.ServiceRegistrar, srv ImportServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;ImportService_ServiceDesc, srv)
}</span>

func _ImportService_StartCsvImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StartCsvImportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).StartCsvImport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImportService_StartCsvImport_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).StartCsvImport(ctx, req.(*StartCsvImportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ImportService_UploadCsvChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UploadCsvChunkRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).UploadCsvChunk(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImportService_UploadCsvChunk_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).UploadCsvChunk(ctx, req.(*UploadCsvChunkRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ImportService_ConfigureCsvMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ConfigureCsvMappingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).ConfigureCsvMapping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImportService_ConfigureCsvMapping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).ConfigureCsvMapping(ctx, req.(*ConfigureCsvMappingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ImportService_PreviewCsvImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PreviewCsvImportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).PreviewCsvImport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImportService_PreviewCsvImport_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).PreviewCsvImport(ctx, req.(*PreviewCsvImportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ImportService_CommitCsvImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CommitCsvImportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).CommitCsvImport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImportService_CommitCsvImport_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImportServiceServer).CommitCsvImport(ctx, req.(*CommitCsvImportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ImportService_ServiceDesc is the grpc.ServiceDesc for ImportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImportService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.ImportService",
        HandlerType: (*ImportServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "StartCsvImport",
                        Handler:    _ImportService_StartCsvImport_Handler,
                },
                {
                        MethodName: "UploadCsvChunk",
                        Handler:    _ImportService_UploadCsvChunk_Handler,
                },
                {
                        MethodName: "ConfigureCsvMapping",
                        Handler:    _ImportService_ConfigureCsvMapping_Handler,
                },
                {
                        MethodName: "PreviewCsvImport",
                        Handler:    _ImportService_PreviewCsvImport_Handler,
                },
                {
                        MethodName: "CommitCsvImport",
                        Handler:    _ImportService_CommitCsvImport_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/import.proto",
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/oauth.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetAuthStatusResponse_Status int32

const (
        GetAuthStatusResponse_STATUS_UNSPECIFIED GetAuthStatusResponse_Status = 0
        GetAuthStatusResponse_STATUS_PENDING     GetAuthStatusResponse_Status = 1 // Ожидает авторизации в браузере
        GetAuthStatusResponse_STATUS_COMPLETED   GetAuthStatusResponse_Status = 2 // Авторизация завершена
        GetAuthStatusResponse_STATUS_EXPIRED     GetAuthStatusResponse_Status = 3 // Ссылка истекла
        GetAuthStatusResponse_STATUS_CANCELLED   GetAuthStatusResponse_Status = 4 // Отменена пользователем
)

// Enum value maps for GetAuthStatusResponse_Status.
var (
        GetAuthStatusResponse_Status_name = map[int32]string{
                0: "STATUS_UNSPECIFIED",
                1: "STATUS_PENDING",
                2: "STATUS_COMPLETED",
                3: "STATUS_EXPIRED",
                4: "STATUS_CANCELLED",
        }
        GetAuthStatusResponse_Status_value = map[string]int32{
                "STATUS_UNSPECIFIED": 0,
                "STATUS_PENDING":     1,
                "STATUS_COMPLETED":   2,
                "STATUS_EXPIRED":     3,
                "STATUS_CANCELLED":   4,
        }
)

func (x GetAuthStatusResponse_Status) Enum() *GetAuthStatusResponse_Status <span class="cov0" title="0">{
        p := new(GetAuthStatusResponse_Status)
        *p = x
        return p
}</span>

func (x GetAuthStatusResponse_Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (GetAuthStatusResponse_Status) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_enumTypes[0].Descriptor()
}</span>

func (GetAuthStatusResponse_Status) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_budget_v1_oauth_proto_enumTypes[0]
}</span>

func (x GetAuthStatusResponse_Status) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use GetAuthStatusResponse_Status.Descriptor instead.
func (GetAuthStatusResponse_Status) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{7, 0}
}</span>

type GenerateAuthLinkRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email          string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        TelegramUserId string `protobuf:"bytes,2,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"` // ID пользователя в Telegram
        UserAgent      string `protobuf:"bytes,3,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`                  // User-Agent для логирования
        IpAddress      string `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`                  // IP адрес для логирования
}

func (x *GenerateAuthLinkRequest) Reset() <span class="cov0" title="0">{
        *x = GenerateAuthLinkRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GenerateAuthLinkRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GenerateAuthLinkRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GenerateAuthLinkRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GenerateAuthLinkRequest.ProtoReflect.Descriptor instead.
func (*GenerateAuthLinkRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GenerateAuthLinkRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GenerateAuthLinkRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GenerateAuthLinkRequest) GetUserAgent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserAgent
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GenerateAuthLinkRequest) GetIpAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GenerateAuthLinkResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AuthUrl   string                 `protobuf:"bytes,1,opt,name=auth_url,json=authUrl,proto3" json:"auth_url,omitempty"`       // URL для авторизации в браузере
        AuthToken string                 `protobuf:"bytes,2,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"` // Временный токен для верификации
        ExpiresAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Время истечения ссылки
}

func (x *GenerateAuthLinkResponse) Reset() <span class="cov0" title="0">{
        *x = GenerateAuthLinkResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GenerateAuthLinkResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GenerateAuthLinkResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GenerateAuthLinkResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GenerateAuthLinkResponse.ProtoReflect.Descriptor instead.
func (*GenerateAuthLinkResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GenerateAuthLinkResponse) GetAuthUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GenerateAuthLinkResponse) GetAuthToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GenerateAuthLinkResponse) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VerifyAuthCodeRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AuthToken        string `protobuf:"bytes,1,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`                      // Временный токен из GenerateAuthLink
        VerificationCode string `protobuf:"bytes,2,opt,name=verification_code,json=verificationCode,proto3" json:"verification_code,omitempty"` // 6-значный код подтверждения
        TelegramUserId   string `protobuf:"bytes,3,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`     // ID пользователя в Telegram
}

func (x *VerifyAuthCodeRequest) Reset() <span class="cov0" title="0">{
        *x = VerifyAuthCodeRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VerifyAuthCodeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VerifyAuthCodeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VerifyAuthCodeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VerifyAuthCodeRequest.ProtoReflect.Descriptor instead.
func (*VerifyAuthCodeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *VerifyAuthCodeRequest) GetAuthToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VerifyAuthCodeRequest) GetVerificationCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VerificationCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VerifyAuthCodeRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VerifyAuthCodeResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tokens      *TokenPair          `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
        User        *User               `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
        Memberships []*TenantMembership `protobuf:"bytes,3,rep,name=memberships,proto3" json:"memberships,omitempty"`
        SessionId   string              `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // ID сессии для Telegram бота
}

func (x *VerifyAuthCodeResponse) Reset() <span class="cov0" title="0">{
        *x = VerifyAuthCodeResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VerifyAuthCodeResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VerifyAuthCodeResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VerifyAuthCodeResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VerifyAuthCodeResponse.ProtoReflect.Descriptor instead.
func (*VerifyAuthCodeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *VerifyAuthCodeResponse) GetTokens() *TokenPair <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *VerifyAuthCodeResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *VerifyAuthCodeResponse) GetMemberships() []*TenantMembership <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Memberships
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *VerifyAuthCodeResponse) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CancelAuthRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AuthToken      string `protobuf:"bytes,1,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
        TelegramUserId string `protobuf:"bytes,2,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
}

func (x *CancelAuthRequest) Reset() <span class="cov0" title="0">{
        *x = CancelAuthRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CancelAuthRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CancelAuthRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CancelAuthRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CancelAuthRequest.ProtoReflect.Descriptor instead.
func (*CancelAuthRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CancelAuthRequest) GetAuthToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CancelAuthRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CancelAuthResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *CancelAuthResponse) Reset() <span class="cov0" title="0">{
        *x = CancelAuthResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CancelAuthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CancelAuthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CancelAuthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CancelAuthResponse.ProtoReflect.Descriptor instead.
func (*CancelAuthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{5}
}</span>

type GetAuthStatusRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AuthToken string `protobuf:"bytes,1,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
}

func (x *GetAuthStatusRequest) Reset() <span class="cov0" title="0">{
        *x = GetAuthStatusRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetAuthStatusRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAuthStatusRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAuthStatusRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAuthStatusRequest.ProtoReflect.Descriptor instead.
func (*GetAuthStatusRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetAuthStatusRequest) GetAuthToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetAuthStatusResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status    GetAuthStatusResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=budget.v1.GetAuthStatusResponse_Status" json:"status,omitempty"`
        CreatedAt *timestamppb.Timestamp       `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        ExpiresAt *timestamppb.Timestamp       `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        Email     string                       `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *GetAuthStatusResponse) Reset() <span class="cov0" title="0">{
        *x = GetAuthStatusResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetAuthStatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAuthStatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAuthStatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAuthStatusResponse.ProtoReflect.Descriptor instead.
func (*GetAuthStatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetAuthStatusResponse) GetStatus() GetAuthStatusResponse_Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return GetAuthStatusResponse_STATUS_UNSPECIFIED</span>
}

func (x *GetAuthStatusResponse) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetAuthStatusResponse) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetAuthStatusResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TelegramSession struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SessionId      string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        UserId         string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        TelegramUserId string                 `protobuf:"bytes,3,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
        TenantId       string                 `protobuf:"bytes,4,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
        CreatedAt      *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        ExpiresAt      *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        IsActive       bool                   `protobuf:"varint,7,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (x *TelegramSession) Reset() <span class="cov0" title="0">{
        *x = TelegramSession{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TelegramSession) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TelegramSession) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TelegramSession) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TelegramSession.ProtoReflect.Descriptor instead.
func (*TelegramSession) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{8}
}</span>

func (x *TelegramSession) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelegramSession) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelegramSession) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelegramSession) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelegramSession) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TelegramSession) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TelegramSession) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetTelegramSessionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (x *GetTelegramSessionRequest) Reset() <span class="cov0" title="0">{
        *x = GetTelegramSessionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTelegramSessionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTelegramSessionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTelegramSessionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTelegramSessionRequest.ProtoReflect.Descriptor instead.
func (*GetTelegramSessionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetTelegramSessionRequest) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTelegramSessionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Session *TelegramSession `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
        User    *User            `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
        Tenant  *Tenant          `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (x *GetTelegramSessionResponse) Reset() <span class="cov0" title="0">{
        *x = GetTelegramSessionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTelegramSessionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTelegramSessionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTelegramSessionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTelegramSessionResponse.ProtoReflect.Descriptor instead.
func (*GetTelegramSessionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetTelegramSessionResponse) GetSession() *TelegramSession <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Session
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTelegramSessionResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTelegramSessionResponse) GetTenant() *Tenant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RevokeTelegramSessionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SessionId      string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        TelegramUserId string `protobuf:"bytes,2,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
}

func (x *RevokeTelegramSessionRequest) Reset() <span class="cov0" title="0">{
        *x = RevokeTelegramSessionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RevokeTelegramSessionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RevokeTelegramSessionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RevokeTelegramSessionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RevokeTelegramSessionRequest.ProtoReflect.Descriptor instead.
func (*RevokeTelegramSessionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{11}
}</span>

func (x *RevokeTelegramSessionRequest) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RevokeTelegramSessionRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RevokeTelegramSessionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *RevokeTelegramSessionResponse) Reset() <span class="cov0" title="0">{
        *x = RevokeTelegramSessionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RevokeTelegramSessionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RevokeTelegramSessionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RevokeTelegramSessionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RevokeTelegramSessionResponse.ProtoReflect.Descriptor instead.
func (*RevokeTelegramSessionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{12}
}</span>

type ListTelegramSessionsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TelegramUserId string `protobuf:"bytes,1,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
}

func (x *ListTelegramSessionsRequest) Reset() <span class="cov0" title="0">{
        *x = ListTelegramSessionsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListTelegramSessionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTelegramSessionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTelegramSessionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTelegramSessionsRequest.ProtoReflect.Descriptor instead.
func (*ListTelegramSessionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{13}
}</span>

func (x *ListTelegramSessionsRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListTelegramSessionsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Sessions []*TelegramSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
}

func (x *ListTelegramSessionsResponse) Reset() <span class="cov0" title="0">{
        *x = ListTelegramSessionsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListTelegramSessionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTelegramSessionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTelegramSessionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTelegramSessionsResponse.ProtoReflect.Descriptor instead.
func (*ListTelegramSessionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{14}
}</span>

func (x *ListTelegramSessionsResponse) GetSessions() []*TelegramSession <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sessions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Логирование безопасности
type AuthLogEntry struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Email          string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        TelegramUserId string                 `protobuf:"bytes,3,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
        IpAddress      string                 `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
        UserAgent      string                 `protobuf:"bytes,5,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
        Action         string                 `protobuf:"bytes,6,opt,name=action,proto3" json:"action,omitempty"` // "generate_link", "verify_code", "cancel", "revoke_session"
        Status         string                 `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"` // "success", "failed", "expired"
        ErrorMessage   string                 `protobuf:"bytes,8,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
        CreatedAt      *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *AuthLogEntry) Reset() <span class="cov0" title="0">{
        *x = AuthLogEntry{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AuthLogEntry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthLogEntry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthLogEntry) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthLogEntry.ProtoReflect.Descriptor instead.
func (*AuthLogEntry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{15}
}</span>

func (x *AuthLogEntry) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetIpAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetUserAgent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserAgent
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetAction() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Action
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetErrorMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ErrorMessage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthLogEntry) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetAuthLogsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TelegramUserId string `protobuf:"bytes,1,opt,name=telegram_user_id,json=telegramUserId,proto3" json:"telegram_user_id,omitempty"`
        Limit          int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset         int32  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetAuthLogsRequest) Reset() <span class="cov0" title="0">{
        *x = GetAuthLogsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetAuthLogsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAuthLogsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAuthLogsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAuthLogsRequest.ProtoReflect.Descriptor instead.
func (*GetAuthLogsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetAuthLogsRequest) GetTelegramUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TelegramUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetAuthLogsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetAuthLogsRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetAuthLogsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Logs       []*AuthLogEntry `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
        TotalCount int32           `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (x *GetAuthLogsResponse) Reset() <span class="cov0" title="0">{
        *x = GetAuthLogsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_oauth_proto_msgTypes[17]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetAuthLogsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAuthLogsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAuthLogsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_oauth_proto_msgTypes[17]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAuthLogsResponse.ProtoReflect.Descriptor instead.
func (*GetAuthLogsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_oauth_proto_rawDescGZIP(), []int{17}
}</span>

func (x *GetAuthLogsResponse) GetLogs() []*AuthLogEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Logs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetAuthLogsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_budget_v1_oauth_proto protoreflect.FileDescriptor

var file_budget_v1_oauth_proto_rawDesc = []byte{
        0x0a, 0x15, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x6f, 0x61, 0x75, 0x74,
        0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x75,
        0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x75, 0x74,
        0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x97, 0x01, 0x0a, 0x17, 0x47, 0x65, 0x6e, 0x65,
        0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c,
        0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x61, 0x67, 0x65, 0x6e,
        0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x73, 0x65, 0x72, 0x41, 0x67, 0x65,
        0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
        0x73, 0x22, 0x8f, 0x01, 0x0a, 0x18, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75,
        0x74, 0x68, 0x4c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19,
        0x0a, 0x08, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x61, 0x75, 0x74, 0x68, 0x55, 0x72, 0x6c, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x75, 0x74,
        0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61,
        0x75, 0x74, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x39, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69,
        0x72, 0x65, 0x73, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65,
        0x73, 0x41, 0x74, 0x22, 0x8d, 0x01, 0x0a, 0x15, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x41, 0x75,
        0x74, 0x68, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
        0x0a, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x2b, 0x0a, 0x11,
        0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x64,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c,
        0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x22, 0xc9, 0x01, 0x0a, 0x16, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x41, 0x75,
        0x74, 0x68, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c,
        0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
        0x50, 0x61, 0x69, 0x72, 0x52, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x12, 0x23, 0x0a, 0x04,
        0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65,
        0x72, 0x12, 0x3d, 0x0a, 0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73,
        0x68, 0x69, 0x70, 0x52, 0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x73,
        0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22,
        0x5c, 0x0a, 0x11, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b,
        0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f,
        0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74,
        0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x14, 0x0a,
        0x12, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x35, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x53, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x61,
        0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x61, 0x75, 0x74, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0xda, 0x02, 0x0a, 0x15, 0x47,
        0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73,
        0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
        0x5f, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
        0x12, 0x39, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x74, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65,
        0x6d, 0x61, 0x69, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69,
        0x6c, 0x22, 0x74, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x12, 0x53,
        0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
        0x44, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x50, 0x45,
        0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x54, 0x41, 0x54, 0x55,
        0x53, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x02, 0x12, 0x12, 0x0a,
        0x0e, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x45, 0x58, 0x50, 0x49, 0x52, 0x45, 0x44, 0x10,
        0x03, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x43, 0x41, 0x4e, 0x43,
        0x45, 0x4c, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x22, 0xa3, 0x02, 0x0a, 0x0f, 0x54, 0x65, 0x6c, 0x65,
        0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x73,
        0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73,
        0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f,
        0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74,
        0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1b, 0x0a,
        0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73,
        0x5f, 0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74,
        0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x07, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x22, 0x3a, 0x0a,
        0x19, 0x47, 0x65, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73,
        0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xa2, 0x01, 0x0a, 0x1a, 0x47, 0x65,
        0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73,
        0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x23,
        0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75,
        0x73, 0x65, 0x72, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x22, 0x67,
        0x0a, 0x1c, 0x52, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d,
        0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d,
        0x0a, 0x0a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x09, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x28, 0x0a,
        0x10, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69,
        0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61,
        0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x1f, 0x0a, 0x1d, 0x52, 0x65, 0x76, 0x6f, 0x6b,
        0x65, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x47, 0x0a, 0x1b, 0x4c, 0x69, 0x73, 0x74,
        0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c, 0x65, 0x67,
        0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49,
        0x64, 0x22, 0x56, 0x0a, 0x1c, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61,
        0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x36, 0x0a, 0x08, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52,
        0x08, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xac, 0x02, 0x0a, 0x0c, 0x41, 0x75,
        0x74, 0x68, 0x4c, 0x6f, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d,
        0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
        0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65,
        0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65,
        0x67, 0x72, 0x61, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x70,
        0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65,
        0x72, 0x5f, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75,
        0x73, 0x65, 0x72, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x72, 0x72, 0x6f,
        0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x39, 0x0a,
        0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x6c, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x41,
        0x75, 0x74, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28,
        0x0a, 0x10, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x6c, 0x65, 0x67, 0x72,
        0x61, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16,
        0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06,
        0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x63, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74,
        0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a,
        0x04, 0x6c, 0x6f, 0x67, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x6f, 0x67, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x6c, 0x6f, 0x67, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f,
        0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x32, 0xe7, 0x05, 0x0a, 0x0c,
        0x4f, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x5b, 0x0a, 0x10,
        0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x6e, 0x6b,
        0x12, 0x22, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x6e,
        0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x6e, 0x6b, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x6e,
        0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x56, 0x65, 0x72,
        0x69, 0x66, 0x79, 0x41, 0x75, 0x74, 0x68, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x20, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x41, 0x75,
        0x74, 0x68, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79,
        0x41, 0x75, 0x74, 0x68, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x49, 0x0a, 0x0a, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x41, 0x75, 0x74, 0x68, 0x12, 0x1c,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6e, 0x63, 0x65,
        0x6c, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x41,
        0x75, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x47,
        0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1f, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68,
        0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74,
        0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x61, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73,
        0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67,
        0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x6a, 0x0a, 0x15, 0x52, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x54, 0x65, 0x6c, 0x65,
        0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x54, 0x65,
        0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x52, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53,
        0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x67,
        0x0a, 0x14, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x26, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53,
        0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x27,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x54,
        0x65, 0x6c, 0x65, 0x67, 0x72, 0x61, 0x6d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x41, 0x75,
        0x74, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x12, 0x1d, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76, 0x31, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_oauth_proto_rawDescOnce sync.Once
        file_budget_v1_oauth_proto_rawDescData = file_budget_v1_oauth_proto_rawDesc
)

func file_budget_v1_oauth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_oauth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_oauth_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_oauth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_oauth_proto_rawDescData</span>
}

var file_budget_v1_oauth_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_budget_v1_oauth_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_budget_v1_oauth_proto_goTypes = []interface{}{
        (GetAuthStatusResponse_Status)(0),     // 0: budget.v1.GetAuthStatusResponse.Status
        (*GenerateAuthLinkRequest)(nil),       // 1: budget.v1.GenerateAuthLinkRequest
        (*GenerateAuthLinkResponse)(nil),      // 2: budget.v1.GenerateAuthLinkResponse
        (*VerifyAuthCodeRequest)(nil),         // 3: budget.v1.VerifyAuthCodeRequest
        (*VerifyAuthCodeResponse)(nil),        // 4: budget.v1.VerifyAuthCodeResponse
        (*CancelAuthRequest)(nil),             // 5: budget.v1.CancelAuthRequest
        (*CancelAuthResponse)(nil),            // 6: budget.v1.CancelAuthResponse
        (*GetAuthStatusRequest)(nil),          // 7: budget.v1.GetAuthStatusRequest
        (*GetAuthStatusResponse)(nil),         // 8: budget.v1.GetAuthStatusResponse
        (*TelegramSession)(nil),               // 9: budget.v1.TelegramSession
        (*GetTelegramSessionRequest)(nil),     // 10: budget.v1.GetTelegramSessionRequest
        (*GetTelegramSessionResponse)(nil),    // 11: budget.v1.GetTelegramSessionResponse
        (*RevokeTelegramSessionRequest)(nil),  // 12: budget.v1.RevokeTelegramSessionRequest
        (*RevokeTelegramSessionResponse)(nil), // 13: budget.v1.RevokeTelegramSessionResponse
        (*ListTelegramSessionsRequest)(nil),   // 14: budget.v1.ListTelegramSessionsRequest
        (*ListTelegramSessionsResponse)(nil),  // 15: budget.v1.ListTelegramSessionsResponse
        (*AuthLogEntry)(nil),                  // 16: budget.v1.AuthLogEntry
        (*GetAuthLogsRequest)(nil),            // 17: budget.v1.GetAuthLogsRequest
        (*GetAuthLogsResponse)(nil),           // 18: budget.v1.GetAuthLogsResponse
        (*timestamppb.Timestamp)(nil),         // 19: google.protobuf.Timestamp
        (*TokenPair)(nil),                     // 20: budget.v1.TokenPair
        (*User)(nil),                          // 21: budget.v1.User
        (*TenantMembership)(nil),              // 22: budget.v1.TenantMembership
        (*Tenant)(nil),                        // 23: budget.v1.Tenant
}
var file_budget_v1_oauth_proto_depIdxs = []int32{
        19, // 0: budget.v1.GenerateAuthLinkResponse.expires_at:type_name -&gt; google.protobuf.Timestamp
        20, // 1: budget.v1.VerifyAuthCodeResponse.tokens:type_name -&gt; budget.v1.TokenPair
        21, // 2: budget.v1.VerifyAuthCodeResponse.user:type_name -&gt; budget.v1.User
        22, // 3: budget.v1.VerifyAuthCodeResponse.memberships:type_name -&gt; budget.v1.TenantMembership
        0,  // 4: budget.v1.GetAuthStatusResponse.status:type_name -&gt; budget.v1.GetAuthStatusResponse.Status
        19, // 5: budget.v1.GetAuthStatusResponse.created_at:type_name -&gt; google.protobuf.Timestamp
        19, // 6: budget.v1.GetAuthStatusResponse.expires_at:type_name -&gt; google.protobuf.Timestamp
        19, // 7: budget.v1.TelegramSession.created_at:type_name -&gt; google.protobuf.Timestamp
        19, // 8: budget.v1.TelegramSession.expires_at:type_name -&gt; google.protobuf.Timestamp
        9,  // 9: budget.v1.GetTelegramSessionResponse.session:type_name -&gt; budget.v1.TelegramSession
        21, // 10: budget.v1.GetTelegramSessionResponse.user:type_name -&gt; budget.v1.User
        23, // 11: budget.v1.GetTelegramSessionResponse.tenant:type_name -&gt; budget.v1.Tenant
        9,  // 12: budget.v1.ListTelegramSessionsResponse.sessions:type_name -&gt; budget.v1.TelegramSession
        19, // 13: budget.v1.AuthLogEntry.created_at:type_name -&gt; google.protobuf.Timestamp
        16, // 14: budget.v1.GetAuthLogsResponse.logs:type_name -&gt; budget.v1.AuthLogEntry
        1,  // 15: budget.v1.OAuthService.GenerateAuthLink:input_type -&gt; budget.v1.GenerateAuthLinkRequest
        3,  // 16: budget.v1.OAuthService.VerifyAuthCode:input_type -&gt; budget.v1.VerifyAuthCodeRequest
        5,  // 17: budget.v1.OAuthService.CancelAuth:input_type -&gt; budget.v1.CancelAuthRequest
        7,  // 18: budget.v1.OAuthService.GetAuthStatus:input_type -&gt; budget.v1.GetAuthStatusRequest
        10, // 19: budget.v1.OAuthService.GetTelegramSession:input_type -&gt; budget.v1.GetTelegramSessionRequest
        12, // 20: budget.v1.OAuthService.RevokeTelegramSession:input_type -&gt; budget.v1.RevokeTelegramSessionRequest
        14, // 21: budget.v1.OAuthService.ListTelegramSessions:input_type -&gt; budget.v1.ListTelegramSessionsRequest
        17, // 22: budget.v1.OAuthService.GetAuthLogs:input_type -&gt; budget.v1.GetAuthLogsRequest
        2,  // 23: budget.v1.OAuthService.GenerateAuthLink:output_type -&gt; budget.v1.GenerateAuthLinkResponse
        4,  // 24: budget.v1.OAuthService.VerifyAuthCode:output_type -&gt; budget.v1.VerifyAuthCodeResponse
        6,  // 25: budget.v1.OAuthService.CancelAuth:output_type -&gt; budget.v1.CancelAuthResponse
        8,  // 26: budget.v1.OAuthService.GetAuthStatus:output_type -&gt; budget.v1.GetAuthStatusResponse
        11, // 27: budget.v1.OAuthService.GetTelegramSession:output_type -&gt; budget.v1.GetTelegramSessionResponse
        13, // 28: budget.v1.OAuthService.RevokeTelegramSession:output_type -&gt; budget.v1.RevokeTelegramSessionResponse
        15, // 29: budget.v1.OAuthService.ListTelegramSessions:output_type -&gt; budget.v1.ListTelegramSessionsResponse
        18, // 30: budget.v1.OAuthService.GetAuthLogs:output_type -&gt; budget.v1.GetAuthLogsResponse
        23, // [23:31] is the sub-list for method output_type
        15, // [15:23] is the sub-list for method input_type
        15, // [15:15] is the sub-list for extension type_name
        15, // [15:15] is the sub-list for extension extendee
        0,  // [0:15] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_oauth_proto_init() }</span>
func file_budget_v1_oauth_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_oauth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_user_proto_init()
        file_budget_v1_tenant_proto_init()
        file_budget_v1_auth_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_oauth_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GenerateAuthLinkRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GenerateAuthLinkResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VerifyAuthCodeRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*VerifyAuthCodeResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CancelAuthRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CancelAuthResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetAuthStatusRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetAuthStatusResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TelegramSession); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTelegramSessionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTelegramSessionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RevokeTelegramSessionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RevokeTelegramSessionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListTelegramSessionsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListTelegramSessionsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AuthLogEntry); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetAuthLogsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_oauth_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetAuthLogsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_oauth_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   18,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_oauth_proto_goTypes,
                DependencyIndexes: file_budget_v1_oauth_proto_depIdxs,
                EnumInfos:         file_budget_v1_oauth_proto_enumTypes,
                MessageInfos:      file_budget_v1_oauth_proto_msgTypes,
        }.Build()
        File_budget_v1_oauth_proto = out.File
        file_budget_v1_oauth_proto_rawDesc = nil
        file_budget_v1_oauth_proto_goTypes = nil
        file_budget_v1_oauth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/oauth.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        OAuthService_GenerateAuthLink_FullMethodName      = "/budget.v1.OAuthService/GenerateAuthLink"
        OAuthService_VerifyAuthCode_FullMethodName        = "/budget.v1.OAuthService/VerifyAuthCode"
        OAuthService_CancelAuth_FullMethodName            = "/budget.v1.OAuthService/CancelAuth"
        OAuthService_GetAuthStatus_FullMethodName         = "/budget.v1.OAuthService/GetAuthStatus"
        OAuthService_GetTelegramSession_FullMethodName    = "/budget.v1.OAuthService/GetTelegramSession"
        OAuthService_RevokeTelegramSession_FullMethodName = "/budget.v1.OAuthService/RevokeTelegramSession"
        OAuthService_ListTelegramSessions_FullMethodName  = "/budget.v1.OAuthService/ListTelegramSessions"
        OAuthService_GetAuthLogs_FullMethodName           = "/budget.v1.OAuthService/GetAuthLogs"
)

// OAuthServiceClient is the client API for OAuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OAuthServiceClient interface {
        // Основные методы OAuth2 flow
        GenerateAuthLink(ctx context.Context, in *GenerateAuthLinkRequest, opts ...grpc.CallOption) (*GenerateAuthLinkResponse, error)
        VerifyAuthCode(ctx context.Context, in *VerifyAuthCodeRequest, opts ...grpc.CallOption) (*VerifyAuthCodeResponse, error)
        CancelAuth(ctx context.Context, in *CancelAuthRequest, opts ...grpc.CallOption) (*CancelAuthResponse, error)
        GetAuthStatus(ctx context.Context, in *GetAuthStatusRequest, opts ...grpc.CallOption) (*GetAuthStatusResponse, error)
        // Управление сессиями Telegram
        GetTelegramSession(ctx context.Context, in *GetTelegramSessionRequest, opts ...grpc.CallOption) (*GetTelegramSessionResponse, error)
        RevokeTelegramSession(ctx context.Context, in *RevokeTelegramSessionRequest, opts ...grpc.CallOption) (*RevokeTelegramSessionResponse, error)
        ListTelegramSessions(ctx context.Context, in *ListTelegramSessionsRequest, opts ...grpc.CallOption) (*ListTelegramSessionsResponse, error)
        // Логирование безопасности
        GetAuthLogs(ctx context.Context, in *GetAuthLogsRequest, opts ...grpc.CallOption) (*GetAuthLogsResponse, error)
}

type oAuthServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewOAuthServiceClient(cc grpc.ClientConnInterface) OAuthServiceClient <span class="cov0" title="0">{
        return &amp;oAuthServiceClient{cc}
}</span>

func (c *oAuthServiceClient) GenerateAuthLink(ctx context.Context, in *GenerateAuthLinkRequest, opts ...grpc.CallOption) (*GenerateAuthLinkResponse, error) <span class="cov0" title="0">{
        out := new(GenerateAuthLinkResponse)
        err := c.cc.Invoke(ctx, OAuthService_GenerateAuthLink_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) VerifyAuthCode(ctx context.Context, in *VerifyAuthCodeRequest, opts ...grpc.CallOption) (*VerifyAuthCodeResponse, error) <span class="cov0" title="0">{
        out := new(VerifyAuthCodeResponse)
        err := c.cc.Invoke(ctx, OAuthService_VerifyAuthCode_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) CancelAuth(ctx context.Context, in *CancelAuthRequest, opts ...grpc.CallOption) (*CancelAuthResponse, error) <span class="cov0" title="0">{
        out := new(CancelAuthResponse)
        err := c.cc.Invoke(ctx, OAuthService_CancelAuth_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) GetAuthStatus(ctx context.Context, in *GetAuthStatusRequest, opts ...grpc.CallOption) (*GetAuthStatusResponse, error) <span class="cov0" title="0">{
        out := new(GetAuthStatusResponse)
        err := c.cc.Invoke(ctx, OAuthService_GetAuthStatus_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) GetTelegramSession(ctx context.Context, in *GetTelegramSessionRequest, opts ...grpc.CallOption) (*GetTelegramSessionResponse, error) <span class="cov0" title="0">{
        out := new(GetTelegramSessionResponse)
        err := c.cc.Invoke(ctx, OAuthService_GetTelegramSession_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) RevokeTelegramSession(ctx context.Context, in *RevokeTelegramSessionRequest, opts ...grpc.CallOption) (*RevokeTelegramSessionResponse, error) <span class="cov0" title="0">{
        out := new(RevokeTelegramSessionResponse)
        err := c.cc.Invoke(ctx, OAuthService_RevokeTelegramSession_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) ListTelegramSessions(ctx context.Context, in *ListTelegramSessionsRequest, opts ...grpc.CallOption) (*ListTelegramSessionsResponse, error) <span class="cov0" title="0">{
        out := new(ListTelegramSessionsResponse)
        err := c.cc.Invoke(ctx, OAuthService_ListTelegramSessions_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthServiceClient) GetAuthLogs(ctx context.Context, in *GetAuthLogsRequest, opts ...grpc.CallOption) (*GetAuthLogsResponse, error) <span class="cov0" title="0">{
        out := new(GetAuthLogsResponse)
        err := c.cc.Invoke(ctx, OAuthService_GetAuthLogs_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OAuthServiceServer is the server API for OAuthService service.
// All implementations must embed UnimplementedOAuthServiceServer
// for forward compatibility
type OAuthServiceServer interface {
        // Основные методы OAuth2 flow
        GenerateAuthLink(context.Context, *GenerateAuthLinkRequest) (*GenerateAuthLinkResponse, error)
        VerifyAuthCode(context.Context, *VerifyAuthCodeRequest) (*VerifyAuthCodeResponse, error)
        CancelAuth(context.Context, *CancelAuthRequest) (*CancelAuthResponse, error)
        GetAuthStatus(context.Context, *GetAuthStatusRequest) (*GetAuthStatusResponse, error)
        // Управление сессиями Telegram
        GetTelegramSession(context.Context, *GetTelegramSessionRequest) (*GetTelegramSessionResponse, error)
        RevokeTelegramSession(context.Context, *RevokeTelegramSessionRequest) (*RevokeTelegramSessionResponse, error)
        ListTelegramSessions(context.Context, *ListTelegramSessionsRequest) (*ListTelegramSessionsResponse, error)
        // Логирование безопасности
        GetAuthLogs(context.Context, *GetAuthLogsRequest) (*GetAuthLogsResponse, error)
        mustEmbedUnimplementedOAuthServiceServer()
}

// UnimplementedOAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOAuthServiceServer struct {
}

func (UnimplementedOAuthServiceServer) GenerateAuthLink(context.Context, *GenerateAuthLinkRequest) (*GenerateAuthLinkResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GenerateAuthLink not implemented")
}</span>
func (UnimplementedOAuthServiceServer) VerifyAuthCode(context.Context, *VerifyAuthCodeRequest) (*VerifyAuthCodeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method VerifyAuthCode not implemented")
}</span>
func (UnimplementedOAuthServiceServer) CancelAuth(context.Context, *CancelAuthRequest) (*CancelAuthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CancelAuth not implemented")
}</span>
func (UnimplementedOAuthServiceServer) GetAuthStatus(context.Context, *GetAuthStatusRequest) (*GetAuthStatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAuthStatus not implemented")
}</span>
func (UnimplementedOAuthServiceServer) GetTelegramSession(context.Context, *GetTelegramSessionRequest) (*GetTelegramSessionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTelegramSession not implemented")
}</span>
func (UnimplementedOAuthServiceServer) RevokeTelegramSession(context.Context, *RevokeTelegramSessionRequest) (*RevokeTelegramSessionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RevokeTelegramSession not implemented")
}</span>
func (UnimplementedOAuthServiceServer) ListTelegramSessions(context.Context, *ListTelegramSessionsRequest) (*ListTelegramSessionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListTelegramSessions not implemented")
}</span>
func (UnimplementedOAuthServiceServer) GetAuthLogs(context.Context, *GetAuthLogsRequest) (*GetAuthLogsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAuthLogs not implemented")
}</span>
func (UnimplementedOAuthServiceServer) mustEmbedUnimplementedOAuthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeOAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OAuthServiceServer will
// result in compilation errors.
type UnsafeOAuthServiceServer interface {
        mustEmbedUnimplementedOAuthServiceServer()
}

func RegisterOAuthServiceServer(s grpc.ServiceRegistrar, srv OAuthServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;OAuthService_ServiceDesc, srv)
}</span>

func _OAuthService_GenerateAuthLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GenerateAuthLinkRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GenerateAuthLink(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_GenerateAuthLink_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GenerateAuthLink(ctx, req.(*GenerateAuthLinkRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_VerifyAuthCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(VerifyAuthCodeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).VerifyAuthCode(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_VerifyAuthCode_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).VerifyAuthCode(ctx, req.(*VerifyAuthCodeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_CancelAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CancelAuthRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).CancelAuth(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_CancelAuth_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).CancelAuth(ctx, req.(*CancelAuthRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_GetAuthStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetAuthStatusRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetAuthStatus(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_GetAuthStatus_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetAuthStatus(ctx, req.(*GetAuthStatusRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_GetTelegramSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTelegramSessionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetTelegramSession(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_GetTelegramSession_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetTelegramSession(ctx, req.(*GetTelegramSessionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_RevokeTelegramSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RevokeTelegramSessionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).RevokeTelegramSession(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_RevokeTelegramSession_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).RevokeTelegramSession(ctx, req.(*RevokeTelegramSessionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_ListTelegramSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListTelegramSessionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).ListTelegramSessions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_ListTelegramSessions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).ListTelegramSessions(ctx, req.(*ListTelegramSessionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OAuthService_GetAuthLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetAuthLogsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetAuthLogs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OAuthService_GetAuthLogs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OAuthServiceServer).GetAuthLogs(ctx, req.(*GetAuthLogsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OAuthService_ServiceDesc is the grpc.ServiceDesc for OAuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OAuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.OAuthService",
        HandlerType: (*OAuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GenerateAuthLink",
                        Handler:    _OAuthService_GenerateAuthLink_Handler,
                },
                {
                        MethodName: "VerifyAuthCode",
                        Handler:    _OAuthService_VerifyAuthCode_Handler,
                },
                {
                        MethodName: "CancelAuth",
                        Handler:    _OAuthService_CancelAuth_Handler,
                },
                {
                        MethodName: "GetAuthStatus",
                        Handler:    _OAuthService_GetAuthStatus_Handler,
                },
                {
                        MethodName: "GetTelegramSession",
                        Handler:    _OAuthService_GetTelegramSession_Handler,
                },
                {
                        MethodName: "RevokeTelegramSession",
                        Handler:    _OAuthService_RevokeTelegramSession_Handler,
                },
                {
                        MethodName: "ListTelegramSessions",
                        Handler:    _OAuthService_ListTelegramSessions_Handler,
                },
                {
                        MethodName: "GetAuthLogs",
                        Handler:    _OAuthService_GetAuthLogs_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/oauth.proto",
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/report.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type MonthlyCategorySummaryItem struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CategoryId   string          `protobuf:"bytes,1,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        CategoryName string          `protobuf:"bytes,2,opt,name=category_name,json=categoryName,proto3" json:"category_name,omitempty"` // localized best-effort
        Type         TransactionType `protobuf:"varint,3,opt,name=type,proto3,enum=budget.v1.TransactionType" json:"type,omitempty"`     // income / expense
        Total        *Money          `protobuf:"bytes,4,opt,name=total,proto3" json:"total,omitempty"`                                   // in target currency
}

func (x *MonthlyCategorySummaryItem) Reset() <span class="cov0" title="0">{
        *x = MonthlyCategorySummaryItem{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_report_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MonthlyCategorySummaryItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MonthlyCategorySummaryItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MonthlyCategorySummaryItem) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_report_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MonthlyCategorySummaryItem.ProtoReflect.Descriptor instead.
func (*MonthlyCategorySummaryItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_report_proto_rawDescGZIP(), []int{0}
}</span>

func (x *MonthlyCategorySummaryItem) GetCategoryId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MonthlyCategorySummaryItem) GetCategoryName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MonthlyCategorySummaryItem) GetType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
}

func (x *MonthlyCategorySummaryItem) GetTotal() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetMonthlySummaryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Year                  int32  `protobuf:"varint,1,opt,name=year,proto3" json:"year,omitempty"`                                                                  // e.g., 2025
        Month                 int32  `protobuf:"varint,2,opt,name=month,proto3" json:"month,omitempty"`                                                                // 1..12
        Locale                string `protobuf:"bytes,3,opt,name=locale,proto3" json:"locale,omitempty"`                                                               // preferred translation
        TargetCurrencyCode    string `protobuf:"bytes,4,opt,name=target_currency_code,json=targetCurrencyCode,proto3" json:"target_currency_code,omitempty"`           // if empty, use tenant default currency
        TimezoneOffsetMinutes int32  `protobuf:"varint,5,opt,name=timezone_offset_minutes,json=timezoneOffsetMinutes,proto3" json:"timezone_offset_minutes,omitempty"` // minutes to add to local time to get UTC (JS getTimezoneOffset)
}

func (x *GetMonthlySummaryRequest) Reset() <span class="cov0" title="0">{
        *x = GetMonthlySummaryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_report_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMonthlySummaryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMonthlySummaryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMonthlySummaryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_report_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMonthlySummaryRequest.ProtoReflect.Descriptor instead.
func (*GetMonthlySummaryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_report_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetMonthlySummaryRequest) GetYear() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Year
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetMonthlySummaryRequest) GetMonth() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Month
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetMonthlySummaryRequest) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetMonthlySummaryRequest) GetTargetCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TargetCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetMonthlySummaryRequest) GetTimezoneOffsetMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimezoneOffsetMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetMonthlySummaryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Items        []*MonthlyCategorySummaryItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        TotalIncome  *Money                        `protobuf:"bytes,2,opt,name=total_income,json=totalIncome,proto3" json:"total_income,omitempty"`    // in target currency
        TotalExpense *Money                        `protobuf:"bytes,3,opt,name=total_expense,json=totalExpense,proto3" json:"total_expense,omitempty"` // in target currency
}

func (x *GetMonthlySummaryResponse) Reset() <span class="cov0" title="0">{
        *x = GetMonthlySummaryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_report_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMonthlySummaryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMonthlySummaryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMonthlySummaryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_report_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMonthlySummaryResponse.ProtoReflect.Descriptor instead.
func (*GetMonthlySummaryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_report_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetMonthlySummaryResponse) GetItems() []*MonthlyCategorySummaryItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMonthlySummaryResponse) GetTotalIncome() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalIncome
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMonthlySummaryResponse) GetTotalExpense() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalExpense
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_budget_v1_report_proto protoreflect.FileDescriptor

var file_budget_v1_report_proto_rawDesc = []byte{
        0x0a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x65, 0x70, 0x6f,
        0x72, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x1a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x63,
        0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xba, 0x01, 0x0a, 0x1a,
        0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x53,
        0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x63,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0c, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x4e, 0x61, 0x6d, 0x65,
        0x12, 0x2e, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65,
        0x12, 0x26, 0x0a, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x10, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65,
        0x79, 0x52, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x22, 0xc6, 0x01, 0x0a, 0x18, 0x47, 0x65, 0x74,
        0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x79, 0x65, 0x61, 0x72, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x05, 0x52, 0x04, 0x79, 0x65, 0x61, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x6e,
        0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x12,
        0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x12, 0x30, 0x0a, 0x14, 0x74, 0x61, 0x72, 0x67, 0x65,
        0x74, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x43, 0x75, 0x72,
        0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x36, 0x0a, 0x17, 0x74, 0x69, 0x6d,
        0x65, 0x7a, 0x6f, 0x6e, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x5f, 0x6d, 0x69, 0x6e,
        0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x15, 0x74, 0x69, 0x6d, 0x65,
        0x7a, 0x6f, 0x6e, 0x65, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65,
        0x73, 0x22, 0xc4, 0x01, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79,
        0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x3b, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x74, 0x68,
        0x6c, 0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72,
        0x79, 0x49, 0x74, 0x65, 0x6d, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x33, 0x0a, 0x0c,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d,
        0x6f, 0x6e, 0x65, 0x79, 0x52, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x6e, 0x63, 0x6f, 0x6d,
        0x65, 0x12, 0x35, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x65, 0x78, 0x70, 0x65, 0x6e,
        0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x0c, 0x74, 0x6f, 0x74, 0x61,
        0x6c, 0x45, 0x78, 0x70, 0x65, 0x6e, 0x73, 0x65, 0x32, 0x6f, 0x0a, 0x0d, 0x52, 0x65, 0x70, 0x6f,
        0x72, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x5e, 0x0a, 0x11, 0x47, 0x65, 0x74,
        0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x23,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x6f,
        0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x47, 0x65, 0x74, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72,
        0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e,
        0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f,
        0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_report_proto_rawDescOnce sync.Once
        file_budget_v1_report_proto_rawDescData = file_budget_v1_report_proto_rawDesc
)

func file_budget_v1_report_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_report_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_report_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_report_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_report_proto_rawDescData</span>
}

var file_budget_v1_report_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_budget_v1_report_proto_goTypes = []interface{}{
        (*MonthlyCategorySummaryItem)(nil), // 0: budget.v1.MonthlyCategorySummaryItem
        (*GetMonthlySummaryRequest)(nil),   // 1: budget.v1.GetMonthlySummaryRequest
        (*GetMonthlySummaryResponse)(nil),  // 2: budget.v1.GetMonthlySummaryResponse
        (TransactionType)(0),               // 3: budget.v1.TransactionType
        (*Money)(nil),                      // 4: budget.v1.Money
}
var file_budget_v1_report_proto_depIdxs = []int32{
        3, // 0: budget.v1.MonthlyCategorySummaryItem.type:type_name -&gt; budget.v1.TransactionType
        4, // 1: budget.v1.MonthlyCategorySummaryItem.total:type_name -&gt; budget.v1.Money
        0, // 2: budget.v1.GetMonthlySummaryResponse.items:type_name -&gt; budget.v1.MonthlyCategorySummaryItem
        4, // 3: budget.v1.GetMonthlySummaryResponse.total_income:type_name -&gt; budget.v1.Money
        4, // 4: budget.v1.GetMonthlySummaryResponse.total_expense:type_name -&gt; budget.v1.Money
        1, // 5: budget.v1.ReportService.GetMonthlySummary:input_type -&gt; budget.v1.GetMonthlySummaryRequest
        2, // 6: budget.v1.ReportService.GetMonthlySummary:output_type -&gt; budget.v1.GetMonthlySummaryResponse
        6, // [6:7] is the sub-list for method output_type
        5, // [5:6] is the sub-list for method input_type
        5, // [5:5] is the sub-list for extension type_name
        5, // [5:5] is the sub-list for extension extendee
        0, // [0:5] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_report_proto_init() }</span>
func file_budget_v1_report_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_report_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_report_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MonthlyCategorySummaryItem); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_report_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMonthlySummaryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_report_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMonthlySummaryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_report_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_report_proto_goTypes,
                DependencyIndexes: file_budget_v1_report_proto_depIdxs,
                MessageInfos:      file_budget_v1_report_proto_msgTypes,
        }.Build()
        File_budget_v1_report_proto = out.File
        file_budget_v1_report_proto_rawDesc = nil
        file_budget_v1_report_proto_goTypes = nil
        file_budget_v1_report_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/report.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        ReportService_GetMonthlySummary_FullMethodName = "/budget.v1.ReportService/GetMonthlySummary"
)

// ReportServiceClient is the client API for ReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReportServiceClient interface {
        GetMonthlySummary(ctx context.Context, in *GetMonthlySummaryRequest, opts ...grpc.CallOption) (*GetMonthlySummaryResponse, error)
}

type reportServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewReportServiceClient(cc grpc.ClientConnInterface) ReportServiceClient <span class="cov0" title="0">{
        return &amp;reportServiceClient{cc}
}</span>

func (c *reportServiceClient) GetMonthlySummary(ctx context.Context, in *GetMonthlySummaryRequest, opts ...grpc.CallOption) (*GetMonthlySummaryResponse, error) <span class="cov0" title="0">{
        out := new(GetMonthlySummaryResponse)
        err := c.cc.Invoke(ctx, ReportService_GetMonthlySummary_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ReportServiceServer is the server API for ReportService service.
// All implementations must embed UnimplementedReportServiceServer
// for forward compatibility
type ReportServiceServer interface {
        GetMonthlySummary(context.Context, *GetMonthlySummaryRequest) (*GetMonthlySummaryResponse, error)
        mustEmbedUnimplementedReportServiceServer()
}

// UnimplementedReportServiceServer must be embedded to have forward compatible implementations.
type UnimplementedReportServiceServer struct {
}

func (UnimplementedReportServiceServer) GetMonthlySummary(context.Context, *GetMonthlySummaryRequest) (*GetMonthlySummaryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMonthlySummary not implemented")
}</span>
func (UnimplementedReportServiceServer) mustEmbedUnimplementedReportServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportServiceServer will
// result in compilation errors.
type UnsafeReportServiceServer interface {
        mustEmbedUnimplementedReportServiceServer()
}

func RegisterReportServiceServer(s grpc.ServiceRegistrar, srv ReportServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;ReportService_ServiceDesc, srv)
}</span>

func _ReportService_GetMonthlySummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMonthlySummaryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReportServiceServer).GetMonthlySummary(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ReportService_GetMonthlySummary_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReportServiceServer).GetMonthlySummary(ctx, req.(*GetMonthlySummaryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ReportService_ServiceDesc is the grpc.ServiceDesc for ReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReportService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.ReportService",
        HandlerType: (*ReportServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetMonthlySummary",
                        Handler:    _ReportService_GetMonthlySummary_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/report.proto",
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/tenant.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TenantRole int32

const (
        TenantRole_TENANT_ROLE_UNSPECIFIED TenantRole = 0
        TenantRole_TENANT_ROLE_OWNER       TenantRole = 1
        TenantRole_TENANT_ROLE_ADMIN       TenantRole = 2
        TenantRole_TENANT_ROLE_MEMBER      TenantRole = 3
)

// Enum value maps for TenantRole.
var (
        TenantRole_name = map[int32]string{
                0: "TENANT_ROLE_UNSPECIFIED",
                1: "TENANT_ROLE_OWNER",
                2: "TENANT_ROLE_ADMIN",
                3: "TENANT_ROLE_MEMBER",
        }
        TenantRole_value = map[string]int32{
                "TENANT_ROLE_UNSPECIFIED": 0,
                "TENANT_ROLE_OWNER":       1,
                "TENANT_ROLE_ADMIN":       2,
                "TENANT_ROLE_MEMBER":      3,
        }
)

func (x TenantRole) Enum() *TenantRole <span class="cov0" title="0">{
        p := new(TenantRole)
        *p = x
        return p
}</span>

func (x TenantRole) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TenantRole) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_enumTypes[0].Descriptor()
}</span>

func (TenantRole) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_budget_v1_tenant_proto_enumTypes[0]
}</span>

func (x TenantRole) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TenantRole.Descriptor instead.
func (TenantRole) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{0}
}</span>

type Tenant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id                  string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                                                // UUID
        Name                string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`                                                            // Display name
        Slug                string                 `protobuf:"bytes,3,opt,name=slug,proto3" json:"slug,omitempty"`                                                            // URL-friendly identifier
        DefaultCurrencyCode string                 `protobuf:"bytes,4,opt,name=default_currency_code,json=defaultCurrencyCode,proto3" json:"default_currency_code,omitempty"` // e.g. "USD", "RUB"
        CreatedAt           *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *Tenant) Reset() <span class="cov0" title="0">{
        *x = Tenant{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Tenant) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Tenant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Tenant) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Tenant.ProtoReflect.Descriptor instead.
func (*Tenant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Tenant) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tenant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tenant) GetSlug() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Slug
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tenant) GetDefaultCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tenant) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TenantMembership struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tenant    *Tenant    `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
        Role      TenantRole `protobuf:"varint,2,opt,name=role,proto3,enum=budget.v1.TenantRole" json:"role,omitempty"`
        IsDefault bool       `protobuf:"varint,3,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
}

func (x *TenantMembership) Reset() <span class="cov0" title="0">{
        *x = TenantMembership{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TenantMembership) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TenantMembership) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TenantMembership) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TenantMembership.ProtoReflect.Descriptor instead.
func (*TenantMembership) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{1}
}</span>

func (x *TenantMembership) GetTenant() *Tenant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TenantMembership) GetRole() TenantRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return TenantRole_TENANT_ROLE_UNSPECIFIED</span>
}

func (x *TenantMembership) GetIsDefault() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsDefault
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CreateTenantRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name                string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Slug                string `protobuf:"bytes,2,opt,name=slug,proto3" json:"slug,omitempty"` // optional, server may generate
        DefaultCurrencyCode string `protobuf:"bytes,3,opt,name=default_currency_code,json=defaultCurrencyCode,proto3" json:"default_currency_code,omitempty"`
}

func (x *CreateTenantRequest) Reset() <span class="cov0" title="0">{
        *x = CreateTenantRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateTenantRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTenantRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTenantRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTenantRequest.ProtoReflect.Descriptor instead.
func (*CreateTenantRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateTenantRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTenantRequest) GetSlug() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Slug
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTenantRequest) GetDefaultCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateTenantResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tenant *Tenant `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (x *CreateTenantResponse) Reset() <span class="cov0" title="0">{
        *x = CreateTenantResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateTenantResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTenantResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTenantResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTenantResponse.ProtoReflect.Descriptor instead.
func (*CreateTenantResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreateTenantResponse) GetTenant() *Tenant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListMyTenantsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ListMyTenantsRequest) Reset() <span class="cov0" title="0">{
        *x = ListMyTenantsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListMyTenantsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListMyTenantsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListMyTenantsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListMyTenantsRequest.ProtoReflect.Descriptor instead.
func (*ListMyTenantsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{4}
}</span>

type ListMyTenantsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Memberships []*TenantMembership `protobuf:"bytes,1,rep,name=memberships,proto3" json:"memberships,omitempty"`
}

func (x *ListMyTenantsResponse) Reset() <span class="cov0" title="0">{
        *x = ListMyTenantsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListMyTenantsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListMyTenantsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListMyTenantsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListMyTenantsResponse.ProtoReflect.Descriptor instead.
func (*ListMyTenantsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ListMyTenantsResponse) GetMemberships() []*TenantMembership <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Memberships
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update tenant settings (name, slug, default currency)
type UpdateTenantRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id                  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // tenant id
        Name                string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Slug                string `protobuf:"bytes,3,opt,name=slug,proto3" json:"slug,omitempty"`
        DefaultCurrencyCode string `protobuf:"bytes,4,opt,name=default_currency_code,json=defaultCurrencyCode,proto3" json:"default_currency_code,omitempty"`
}

func (x *UpdateTenantRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateTenantRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateTenantRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTenantRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTenantRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTenantRequest.ProtoReflect.Descriptor instead.
func (*UpdateTenantRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UpdateTenantRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTenantRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTenantRequest) GetSlug() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Slug
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTenantRequest) GetDefaultCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultCurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateTenantResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Tenant *Tenant `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (x *UpdateTenantResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateTenantResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateTenantResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTenantResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTenantResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTenantResponse.ProtoReflect.Descriptor instead.
func (*UpdateTenantResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{7}
}</span>

func (x *UpdateTenantResponse) GetTenant() *Tenant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tenant
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Members management
type TenantMember struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User      *User      `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Role      TenantRole `protobuf:"varint,2,opt,name=role,proto3,enum=budget.v1.TenantRole" json:"role,omitempty"`
        IsDefault bool       `protobuf:"varint,3,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
}

func (x *TenantMember) Reset() <span class="cov0" title="0">{
        *x = TenantMember{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TenantMember) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TenantMember) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TenantMember) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TenantMember.ProtoReflect.Descriptor instead.
func (*TenantMember) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{8}
}</span>

func (x *TenantMember) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TenantMember) GetRole() TenantRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return TenantRole_TENANT_ROLE_UNSPECIFIED</span>
}

func (x *TenantMember) GetIsDefault() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsDefault
        }</span>
        <span class="cov0" title="0">return false</span>
}

type ListMembersRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TenantId string `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (x *ListMembersRequest) Reset() <span class="cov0" title="0">{
        *x = ListMembersRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListMembersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListMembersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListMembersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListMembersRequest.ProtoReflect.Descriptor instead.
func (*ListMembersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ListMembersRequest) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListMembersResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Members []*TenantMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
}

func (x *ListMembersResponse) Reset() <span class="cov0" title="0">{
        *x = ListMembersResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListMembersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListMembersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListMembersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListMembersResponse.ProtoReflect.Descriptor instead.
func (*ListMembersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListMembersResponse) GetMembers() []*TenantMember <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Members
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddMemberRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TenantId string     `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
        Email    string     `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"` // existing user's email
        Role     TenantRole `protobuf:"varint,3,opt,name=role,proto3,enum=budget.v1.TenantRole" json:"role,omitempty"`
}

func (x *AddMemberRequest) Reset() <span class="cov0" title="0">{
        *x = AddMemberRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddMemberRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddMemberRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddMemberRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddMemberRequest.ProtoReflect.Descriptor instead.
func (*AddMemberRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{11}
}</span>

func (x *AddMemberRequest) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddMemberRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddMemberRequest) GetRole() TenantRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return TenantRole_TENANT_ROLE_UNSPECIFIED</span>
}

type AddMemberResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Member *TenantMember `protobuf:"bytes,1,opt,name=member,proto3" json:"member,omitempty"`
}

func (x *AddMemberResponse) Reset() <span class="cov0" title="0">{
        *x = AddMemberResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddMemberResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddMemberResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddMemberResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddMemberResponse.ProtoReflect.Descriptor instead.
func (*AddMemberResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{12}
}</span>

func (x *AddMemberResponse) GetMember() *TenantMember <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Member
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateMemberRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TenantId string     `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
        UserId   string     `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Role     TenantRole `protobuf:"varint,3,opt,name=role,proto3,enum=budget.v1.TenantRole" json:"role,omitempty"`
}

func (x *UpdateMemberRoleRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateMemberRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateMemberRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateMemberRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateMemberRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateMemberRoleRequest.ProtoReflect.Descriptor instead.
func (*UpdateMemberRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{13}
}</span>

func (x *UpdateMemberRoleRequest) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateMemberRoleRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateMemberRoleRequest) GetRole() TenantRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return TenantRole_TENANT_ROLE_UNSPECIFIED</span>
}

type UpdateMemberRoleResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Member *TenantMember `protobuf:"bytes,1,opt,name=member,proto3" json:"member,omitempty"`
}

func (x *UpdateMemberRoleResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateMemberRoleResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateMemberRoleResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateMemberRoleResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateMemberRoleResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateMemberRoleResponse.ProtoReflect.Descriptor instead.
func (*UpdateMemberRoleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{14}
}</span>

func (x *UpdateMemberRoleResponse) GetMember() *TenantMember <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Member
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RemoveMemberRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TenantId string `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
        UserId   string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *RemoveMemberRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveMemberRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveMemberRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveMemberRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveMemberRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveMemberRequest.ProtoReflect.Descriptor instead.
func (*RemoveMemberRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{15}
}</span>

func (x *RemoveMemberRequest) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RemoveMemberRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveMemberResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *RemoveMemberResponse) Reset() <span class="cov0" title="0">{
        *x = RemoveMemberResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_tenant_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveMemberResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveMemberResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveMemberResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_tenant_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveMemberResponse.ProtoReflect.Descriptor instead.
func (*RemoveMemberResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_tenant_proto_rawDescGZIP(), []int{16}
}</span>

var File_budget_v1_tenant_proto protoreflect.FileDescriptor

var file_budget_v1_tenant_proto_rawDesc = []byte{
        0x0a, 0x16, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f,
        0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xaf, 0x01, 0x0a, 0x06, 0x54,
        0x65, 0x6e, 0x61, 0x6e, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6c, 0x75,
        0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6c, 0x75, 0x67, 0x12, 0x32, 0x0a,
        0x15, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63,
        0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x64, 0x65,
        0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64,
        0x65, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x87, 0x01, 0x0a,
        0x10, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69,
        0x70, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65,
        0x6e, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x04,
        0x72, 0x6f, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x6f, 0x6c,
        0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x64, 0x65,
        0x66, 0x61, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44,
        0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x22, 0x71, 0x0a, 0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6c, 0x75, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x73, 0x6c, 0x75, 0x67, 0x12, 0x32, 0x0a, 0x15, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
        0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x43, 0x75, 0x72,
        0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x41, 0x0a, 0x14, 0x43, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65,
        0x6e, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x22, 0x16, 0x0a, 0x14,
        0x4c, 0x69, 0x73, 0x74, 0x4d, 0x79, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x22, 0x56, 0x0a, 0x15, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x79, 0x54, 0x65,
        0x6e, 0x61, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3d, 0x0a,
        0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54,
        0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x52,
        0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x73, 0x22, 0x81, 0x01, 0x0a,
        0x13, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6c, 0x75, 0x67,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6c, 0x75, 0x67, 0x12, 0x32, 0x0a, 0x15,
        0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
        0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x64, 0x65, 0x66,
        0x61, 0x75, 0x6c, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65,
        0x22, 0x41, 0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x74, 0x65, 0x6e,
        0x61, 0x6e, 0x74, 0x22, 0x7d, 0x0a, 0x0c, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d,
        0x62, 0x65, 0x72, 0x12, 0x23, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73,
        0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x29, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72,
        0x6f, 0x6c, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44, 0x65, 0x66, 0x61, 0x75,
        0x6c, 0x74, 0x22, 0x31, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e,
        0x61, 0x6e, 0x74, 0x49, 0x64, 0x22, 0x48, 0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x6d,
        0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x31, 0x0a, 0x07,
        0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74,
        0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x22,
        0x70, 0x0a, 0x10, 0x41, 0x64, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x49, 0x64,
        0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x29, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c,
        0x65, 0x22, 0x44, 0x0a, 0x11, 0x41, 0x64, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x06, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52,
        0x06, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x7a, 0x0a, 0x17, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x49, 0x64, 0x12,
        0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x29, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72,
        0x6f, 0x6c, 0x65, 0x22, 0x4b, 0x0a, 0x18, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x6d,
        0x62, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x2f, 0x0a, 0x06, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x17, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x06, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72,
        0x22, 0x4b, 0x0a, 0x13, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e,
        0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e, 0x61,
        0x6e, 0x74, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x16, 0x0a,
        0x14, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2a, 0x6f, 0x0a, 0x0a, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52,
        0x6f, 0x6c, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x54, 0x45, 0x4e, 0x41, 0x4e, 0x54, 0x5f, 0x52, 0x4f,
        0x4c, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00,
        0x12, 0x15, 0x0a, 0x11, 0x54, 0x45, 0x4e, 0x41, 0x4e, 0x54, 0x5f, 0x52, 0x4f, 0x4c, 0x45, 0x5f,
        0x4f, 0x57, 0x4e, 0x45, 0x52, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x54, 0x45, 0x4e, 0x41, 0x4e,
        0x54, 0x5f, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x41, 0x44, 0x4d, 0x49, 0x4e, 0x10, 0x02, 0x12, 0x16,
        0x0a, 0x12, 0x54, 0x45, 0x4e, 0x41, 0x4e, 0x54, 0x5f, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x4d, 0x45,
        0x4d, 0x42, 0x45, 0x52, 0x10, 0x03, 0x32, 0xc9, 0x04, 0x0a, 0x0d, 0x54, 0x65, 0x6e, 0x61, 0x6e,
        0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4f, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x12, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e,
        0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x4c, 0x69, 0x73,
        0x74, 0x4d, 0x79, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x1f, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x79, 0x54, 0x65, 0x6e,
        0x61, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x79, 0x54, 0x65,
        0x6e, 0x61, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a,
        0x0c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x12, 0x1e, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x54, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c,
        0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x12, 0x1d, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x65,
        0x6d, 0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x6d,
        0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x46, 0x0a, 0x09,
        0x41, 0x64, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1b, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5b, 0x0a, 0x10, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65,
        0x6d, 0x62, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x12, 0x22, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65,
        0x72, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d,
        0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x4f, 0x0a, 0x0c, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65,
        0x72, 0x12, 0x1e, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
        0x6d, 0x6f, 0x76, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x1f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
        0x6d, 0x6f, 0x76, 0x65, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_tenant_proto_rawDescOnce sync.Once
        file_budget_v1_tenant_proto_rawDescData = file_budget_v1_tenant_proto_rawDesc
)

func file_budget_v1_tenant_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_tenant_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_tenant_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_tenant_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_tenant_proto_rawDescData</span>
}

var file_budget_v1_tenant_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_budget_v1_tenant_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_budget_v1_tenant_proto_goTypes = []interface{}{
        (TenantRole)(0),                  // 0: budget.v1.TenantRole
        (*Tenant)(nil),                   // 1: budget.v1.Tenant
        (*TenantMembership)(nil),         // 2: budget.v1.TenantMembership
        (*CreateTenantRequest)(nil),      // 3: budget.v1.CreateTenantRequest
        (*CreateTenantResponse)(nil),     // 4: budget.v1.CreateTenantResponse
        (*ListMyTenantsRequest)(nil),     // 5: budget.v1.ListMyTenantsRequest
        (*ListMyTenantsResponse)(nil),    // 6: budget.v1.ListMyTenantsResponse
        (*UpdateTenantRequest)(nil),      // 7: budget.v1.UpdateTenantRequest
        (*UpdateTenantResponse)(nil),     // 8: budget.v1.UpdateTenantResponse
        (*TenantMember)(nil),             // 9: budget.v1.TenantMember
        (*ListMembersRequest)(nil),       // 10: budget.v1.ListMembersRequest
        (*ListMembersResponse)(nil),      // 11: budget.v1.ListMembersResponse
        (*AddMemberRequest)(nil),         // 12: budget.v1.AddMemberRequest
        (*AddMemberResponse)(nil),        // 13: budget.v1.AddMemberResponse
        (*UpdateMemberRoleRequest)(nil),  // 14: budget.v1.UpdateMemberRoleRequest
        (*UpdateMemberRoleResponse)(nil), // 15: budget.v1.UpdateMemberRoleResponse
        (*RemoveMemberRequest)(nil),      // 16: budget.v1.RemoveMemberRequest
        (*RemoveMemberResponse)(nil),     // 17: budget.v1.RemoveMemberResponse
        (*timestamppb.Timestamp)(nil),    // 18: google.protobuf.Timestamp
        (*User)(nil),                     // 19: budget.v1.User
}
var file_budget_v1_tenant_proto_depIdxs = []int32{
        18, // 0: budget.v1.Tenant.created_at:type_name -&gt; google.protobuf.Timestamp
        1,  // 1: budget.v1.TenantMembership.tenant:type_name -&gt; budget.v1.Tenant
        0,  // 2: budget.v1.TenantMembership.role:type_name -&gt; budget.v1.TenantRole
        1,  // 3: budget.v1.CreateTenantResponse.tenant:type_name -&gt; budget.v1.Tenant
        2,  // 4: budget.v1.ListMyTenantsResponse.memberships:type_name -&gt; budget.v1.TenantMembership
        1,  // 5: budget.v1.UpdateTenantResponse.tenant:type_name -&gt; budget.v1.Tenant
        19, // 6: budget.v1.TenantMember.user:type_name -&gt; budget.v1.User
        0,  // 7: budget.v1.TenantMember.role:type_name -&gt; budget.v1.TenantRole
        9,  // 8: budget.v1.ListMembersResponse.members:type_name -&gt; budget.v1.TenantMember
        0,  // 9: budget.v1.AddMemberRequest.role:type_name -&gt; budget.v1.TenantRole
        9,  // 10: budget.v1.AddMemberResponse.member:type_name -&gt; budget.v1.TenantMember
        0,  // 11: budget.v1.UpdateMemberRoleRequest.role:type_name -&gt; budget.v1.TenantRole
        9,  // 12: budget.v1.UpdateMemberRoleResponse.member:type_name -&gt; budget.v1.TenantMember
        3,  // 13: budget.v1.TenantService.CreateTenant:input_type -&gt; budget.v1.CreateTenantRequest
        5,  // 14: budget.v1.TenantService.ListMyTenants:input_type -&gt; budget.v1.ListMyTenantsRequest
        7,  // 15: budget.v1.TenantService.UpdateTenant:input_type -&gt; budget.v1.UpdateTenantRequest
        10, // 16: budget.v1.TenantService.ListMembers:input_type -&gt; budget.v1.ListMembersRequest
        12, // 17: budget.v1.TenantService.AddMember:input_type -&gt; budget.v1.AddMemberRequest
        14, // 18: budget.v1.TenantService.UpdateMemberRole:input_type -&gt; budget.v1.UpdateMemberRoleRequest
        16, // 19: budget.v1.TenantService.RemoveMember:input_type -&gt; budget.v1.RemoveMemberRequest
        4,  // 20: budget.v1.TenantService.CreateTenant:output_type -&gt; budget.v1.CreateTenantResponse
        6,  // 21: budget.v1.TenantService.ListMyTenants:output_type -&gt; budget.v1.ListMyTenantsResponse
        8,  // 22: budget.v1.TenantService.UpdateTenant:output_type -&gt; budget.v1.UpdateTenantResponse
        11, // 23: budget.v1.TenantService.ListMembers:output_type -&gt; budget.v1.ListMembersResponse
        13, // 24: budget.v1.TenantService.AddMember:output_type -&gt; budget.v1.AddMemberResponse
        15, // 25: budget.v1.TenantService.UpdateMemberRole:output_type -&gt; budget.v1.UpdateMemberRoleResponse
        17, // 26: budget.v1.TenantService.RemoveMember:output_type -&gt; budget.v1.RemoveMemberResponse
        20, // [20:27] is the sub-list for method output_type
        13, // [13:20] is the sub-list for method input_type
        13, // [13:13] is the sub-list for extension type_name
        13, // [13:13] is the sub-list for extension extendee
        0,  // [0:13] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_tenant_proto_init() }</span>
func file_budget_v1_tenant_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_tenant_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_user_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_tenant_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Tenant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TenantMembership); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateTenantRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateTenantResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListMyTenantsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListMyTenantsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateTenantRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateTenantResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TenantMember); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListMembersRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListMembersResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AddMemberRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AddMemberResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateMemberRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateMemberRoleResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveMemberRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_tenant_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveMemberResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_tenant_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_tenant_proto_goTypes,
                DependencyIndexes: file_budget_v1_tenant_proto_depIdxs,
                EnumInfos:         file_budget_v1_tenant_proto_enumTypes,
                MessageInfos:      file_budget_v1_tenant_proto_msgTypes,
        }.Build()
        File_budget_v1_tenant_proto = out.File
        file_budget_v1_tenant_proto_rawDesc = nil
        file_budget_v1_tenant_proto_goTypes = nil
        file_budget_v1_tenant_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/tenant.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        TenantService_CreateTenant_FullMethodName     = "/budget.v1.TenantService/CreateTenant"
        TenantService_ListMyTenants_FullMethodName    = "/budget.v1.TenantService/ListMyTenants"
        TenantService_UpdateTenant_FullMethodName     = "/budget.v1.TenantService/UpdateTenant"
        TenantService_ListMembers_FullMethodName      = "/budget.v1.TenantService/ListMembers"
        TenantService_AddMember_FullMethodName        = "/budget.v1.TenantService/AddMember"
        TenantService_UpdateMemberRole_FullMethodName = "/budget.v1.TenantService/UpdateMemberRole"
        TenantService_RemoveMember_FullMethodName     = "/budget.v1.TenantService/RemoveMember"
)

// TenantServiceClient is the client API for TenantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantServiceClient interface {
        CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error)
        ListMyTenants(ctx context.Context, in *ListMyTenantsRequest, opts ...grpc.CallOption) (*ListMyTenantsResponse, error)
        UpdateTenant(ctx context.Context, in *UpdateTenantRequest, opts ...grpc.CallOption) (*UpdateTenantResponse, error)
        ListMembers(ctx context.Context, in *ListMembersRequest, opts ...grpc.CallOption) (*ListMembersResponse, error)
        AddMember(ctx context.Context, in *AddMemberRequest, opts ...grpc.CallOption) (*AddMemberResponse, error)
        UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*UpdateMemberRoleResponse, error)
        RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error)
}

type tenantServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTenantServiceClient(cc grpc.ClientConnInterface) TenantServiceClient <span class="cov0" title="0">{
        return &amp;tenantServiceClient{cc}
}</span>

func (c *tenantServiceClient) CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error) <span class="cov0" title="0">{
        out := new(CreateTenantResponse)
        err := c.cc.Invoke(ctx, TenantService_CreateTenant_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) ListMyTenants(ctx context.Context, in *ListMyTenantsRequest, opts ...grpc.CallOption) (*ListMyTenantsResponse, error) <span class="cov0" title="0">{
        out := new(ListMyTenantsResponse)
        err := c.cc.Invoke(ctx, TenantService_ListMyTenants_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) UpdateTenant(ctx context.Context, in *UpdateTenantRequest, opts ...grpc.CallOption) (*UpdateTenantResponse, error) <span class="cov0" title="0">{
        out := new(UpdateTenantResponse)
        err := c.cc.Invoke(ctx, TenantService_UpdateTenant_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) ListMembers(ctx context.Context, in *ListMembersRequest, opts ...grpc.CallOption) (*ListMembersResponse, error) <span class="cov0" title="0">{
        out := new(ListMembersResponse)
        err := c.cc.Invoke(ctx, TenantService_ListMembers_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) AddMember(ctx context.Context, in *AddMemberRequest, opts ...grpc.CallOption) (*AddMemberResponse, error) <span class="cov0" title="0">{
        out := new(AddMemberResponse)
        err := c.cc.Invoke(ctx, TenantService_AddMember_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*UpdateMemberRoleResponse, error) <span class="cov0" title="0">{
        out := new(UpdateMemberRoleResponse)
        err := c.cc.Invoke(ctx, TenantService_UpdateMemberRole_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tenantServiceClient) RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error) <span class="cov0" title="0">{
        out := new(RemoveMemberResponse)
        err := c.cc.Invoke(ctx, TenantService_RemoveMember_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TenantServiceServer is the server API for TenantService service.
// All implementations must embed UnimplementedTenantServiceServer
// for forward compatibility
type TenantServiceServer interface {
        CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error)
        ListMyTenants(context.Context, *ListMyTenantsRequest) (*ListMyTenantsResponse, error)
        UpdateTenant(context.Context, *UpdateTenantRequest) (*UpdateTenantResponse, error)
        ListMembers(context.Context, *ListMembersRequest) (*ListMembersResponse, error)
        AddMember(context.Context, *AddMemberRequest) (*AddMemberResponse, error)
        UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*UpdateMemberRoleResponse, error)
        RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error)
        mustEmbedUnimplementedTenantServiceServer()
}

// UnimplementedTenantServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTenantServiceServer struct {
}

func (UnimplementedTenantServiceServer) CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateTenant not implemented")
}</span>
func (UnimplementedTenantServiceServer) ListMyTenants(context.Context, *ListMyTenantsRequest) (*ListMyTenantsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListMyTenants not implemented")
}</span>
func (UnimplementedTenantServiceServer) UpdateTenant(context.Context, *UpdateTenantRequest) (*UpdateTenantResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateTenant not implemented")
}</span>
func (UnimplementedTenantServiceServer) ListMembers(context.Context, *ListMembersRequest) (*ListMembersResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListMembers not implemented")
}</span>
func (UnimplementedTenantServiceServer) AddMember(context.Context, *AddMemberRequest) (*AddMemberResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddMember not implemented")
}</span>
func (UnimplementedTenantServiceServer) UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*UpdateMemberRoleResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateMemberRole not implemented")
}</span>
func (UnimplementedTenantServiceServer) RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveMember not implemented")
}</span>
func (UnimplementedTenantServiceServer) mustEmbedUnimplementedTenantServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeTenantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServiceServer will
// result in compilation errors.
type UnsafeTenantServiceServer interface {
        mustEmbedUnimplementedTenantServiceServer()
}

func RegisterTenantServiceServer(s grpc.ServiceRegistrar, srv TenantServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;TenantService_ServiceDesc, srv)
}</span>

func _TenantService_CreateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateTenantRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).CreateTenant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_CreateTenant_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).CreateTenant(ctx, req.(*CreateTenantRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_ListMyTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListMyTenantsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).ListMyTenants(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_ListMyTenants_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).ListMyTenants(ctx, req.(*ListMyTenantsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_UpdateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateTenantRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).UpdateTenant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_UpdateTenant_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).UpdateTenant(ctx, req.(*UpdateTenantRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_ListMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListMembersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).ListMembers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_ListMembers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).ListMembers(ctx, req.(*ListMembersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_AddMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddMemberRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).AddMember(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_AddMember_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).AddMember(ctx, req.(*AddMemberRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_UpdateMemberRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateMemberRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).UpdateMemberRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_UpdateMemberRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).UpdateMemberRole(ctx, req.(*UpdateMemberRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TenantService_RemoveMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveMemberRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).RemoveMember(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TenantService_RemoveMember_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TenantServiceServer).RemoveMember(ctx, req.(*RemoveMemberRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TenantService_ServiceDesc is the grpc.ServiceDesc for TenantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.TenantService",
        HandlerType: (*TenantServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateTenant",
                        Handler:    _TenantService_CreateTenant_Handler,
                },
                {
                        MethodName: "ListMyTenants",
                        Handler:    _TenantService_ListMyTenants_Handler,
                },
                {
                        MethodName: "UpdateTenant",
                        Handler:    _TenantService_UpdateTenant_Handler,
                },
                {
                        MethodName: "ListMembers",
                        Handler:    _TenantService_ListMembers_Handler,
                },
                {
                        MethodName: "AddMember",
                        Handler:    _TenantService_AddMember_Handler,
                },
                {
                        MethodName: "UpdateMemberRole",
                        Handler:    _TenantService_UpdateMemberRole_Handler,
                },
                {
                        MethodName: "RemoveMember",
                        Handler:    _TenantService_RemoveMember_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/tenant.proto",
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/transaction.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Transaction struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                     // UUID
        TenantId   string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`         // UUID
        UserId     string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`               // UUID
        CategoryId string                 `protobuf:"bytes,4,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`   // UUID
        Type       TransactionType        `protobuf:"varint,5,opt,name=type,proto3,enum=budget.v1.TransactionType" json:"type,omitempty"` // income / expense
        Amount     *Money                 `protobuf:"bytes,6,opt,name=amount,proto3" json:"amount,omitempty"`                             // original amount in transaction currency
        BaseAmount *Money                 `protobuf:"bytes,7,opt,name=base_amount,json=baseAmount,proto3" json:"base_amount,omitempty"`   // amount converted to tenant's base currency (if currency differs)
        Fx         *FxInfo                `protobuf:"bytes,8,opt,name=fx,proto3" json:"fx,omitempty"`                                     // FX used to compute base_amount (optional if same currency)
        OccurredAt *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=occurred_at,json=occurredAt,proto3" json:"occurred_at,omitempty"`
        Comment    string                 `protobuf:"bytes,10,opt,name=comment,proto3" json:"comment,omitempty"`
        CreatedAt  *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *Transaction) Reset() <span class="cov0" title="0">{
        *x = Transaction{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Transaction) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Transaction) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Transaction) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Transaction) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetTenantId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetCategoryId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
}

func (x *Transaction) GetAmount() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetBaseAmount() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BaseAmount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetFx() *FxInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fx
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetOccurredAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OccurredAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetComment() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comment
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateTransactionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Type       TransactionType        `protobuf:"varint,1,opt,name=type,proto3,enum=budget.v1.TransactionType" json:"type,omitempty"`
        CategoryId string                 `protobuf:"bytes,2,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Amount     *Money                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"` // original amount
        OccurredAt *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=occurred_at,json=occurredAt,proto3" json:"occurred_at,omitempty"`
        Comment    string                 `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (x *CreateTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = CreateTransactionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTransactionRequest.ProtoReflect.Descriptor instead.
func (*CreateTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateTransactionRequest) GetType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
}

func (x *CreateTransactionRequest) GetCategoryId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTransactionRequest) GetAmount() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateTransactionRequest) GetOccurredAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OccurredAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateTransactionRequest) GetComment() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comment
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateTransactionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (x *CreateTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = CreateTransactionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTransactionResponse.ProtoReflect.Descriptor instead.
func (*CreateTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateTransactionResponse) GetTransaction() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transaction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateTransactionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Transaction *Transaction           `protobuf:"bytes,2,opt,name=transaction,proto3" json:"transaction,omitempty"`                 // new values
        UpdateMask  *fieldmaskpb.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"` // paths relative to Transaction (e.g. "category_id,amount,comment,occurred_at")
}

func (x *UpdateTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateTransactionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTransactionRequest.ProtoReflect.Descriptor instead.
func (*UpdateTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UpdateTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTransactionRequest) GetTransaction() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transaction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateTransactionRequest) GetUpdateMask() *fieldmaskpb.FieldMask <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdateMask
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateTransactionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (x *UpdateTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateTransactionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTransactionResponse.ProtoReflect.Descriptor instead.
func (*UpdateTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UpdateTransactionResponse) GetTransaction() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transaction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteTransactionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteTransactionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteTransactionRequest.ProtoReflect.Descriptor instead.
func (*DeleteTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{5}
}</span>

func (x *DeleteTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteTransactionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *DeleteTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteTransactionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteTransactionResponse.ProtoReflect.Descriptor instead.
func (*DeleteTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{6}
}</span>

type GetTransactionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = GetTransactionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionRequest.ProtoReflect.Descriptor instead.
func (*GetTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTransactionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (x *GetTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = GetTransactionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionResponse.ProtoReflect.Descriptor instead.
func (*GetTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetTransactionResponse) GetTransaction() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transaction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTransactionsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Page          *PageRequest    `protobuf:"bytes,1,opt,name=page,proto3" json:"page,omitempty"`
        DateRange     *DateRange      `protobuf:"bytes,2,opt,name=date_range,json=dateRange,proto3" json:"date_range,omitempty"`
        CategoryIds   []string        `protobuf:"bytes,3,rep,name=category_ids,json=categoryIds,proto3" json:"category_ids,omitempty"`
        Type          TransactionType `protobuf:"varint,4,opt,name=type,proto3,enum=budget.v1.TransactionType" json:"type,omitempty"`           // optional filter
        MinMinorUnits int64           `protobuf:"varint,5,opt,name=min_minor_units,json=minMinorUnits,proto3" json:"min_minor_units,omitempty"` // optional amount filters
        MaxMinorUnits int64           `protobuf:"varint,6,opt,name=max_minor_units,json=maxMinorUnits,proto3" json:"max_minor_units,omitempty"`
        CurrencyCode  string          `protobuf:"bytes,7,opt,name=currency_code,json=currencyCode,proto3" json:"currency_code,omitempty"` // optional filter by transaction currency
        Search        string          `protobuf:"bytes,8,opt,name=search,proto3" json:"search,omitempty"`                                 // comment search
}

func (x *ListTransactionsRequest) Reset() <span class="cov0" title="0">{
        *x = ListTransactionsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListTransactionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTransactionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTransactionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTransactionsRequest.ProtoReflect.Descriptor instead.
func (*ListTransactionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ListTransactionsRequest) GetPage() *PageRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsRequest) GetDateRange() *DateRange <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateRange
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsRequest) GetCategoryIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsRequest) GetType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
}

func (x *ListTransactionsRequest) GetMinMinorUnits() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinMinorUnits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListTransactionsRequest) GetMaxMinorUnits() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxMinorUnits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListTransactionsRequest) GetCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListTransactionsRequest) GetSearch() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Search
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListTransactionsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
        Page         *PageResponse  `protobuf:"bytes,2,opt,name=page,proto3" json:"page,omitempty"`
}

func (x *ListTransactionsResponse) Reset() <span class="cov0" title="0">{
        *x = ListTransactionsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListTransactionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTransactionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTransactionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTransactionsResponse.ProtoReflect.Descriptor instead.
func (*ListTransactionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListTransactionsResponse) GetTransactions() []*Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Transactions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsResponse) GetPage() *PageResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Filtered totals for transactions (ignores pagination). Totals are returned in tenant base currency.
type GetTransactionsTotalsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        DateRange     *DateRange      `protobuf:"bytes,1,opt,name=date_range,json=dateRange,proto3" json:"date_range,omitempty"`
        CategoryIds   []string        `protobuf:"bytes,2,rep,name=category_ids,json=categoryIds,proto3" json:"category_ids,omitempty"`
        Type          TransactionType `protobuf:"varint,3,opt,name=type,proto3,enum=budget.v1.TransactionType" json:"type,omitempty"`           // optional filter
        MinMinorUnits int64           `protobuf:"varint,4,opt,name=min_minor_units,json=minMinorUnits,proto3" json:"min_minor_units,omitempty"` // optional amount filters (by original amount)
        MaxMinorUnits int64           `protobuf:"varint,5,opt,name=max_minor_units,json=maxMinorUnits,proto3" json:"max_minor_units,omitempty"`
        CurrencyCode  string          `protobuf:"bytes,6,opt,name=currency_code,json=currencyCode,proto3" json:"currency_code,omitempty"` // optional filter by transaction currency
        Search        string          `protobuf:"bytes,7,opt,name=search,proto3" json:"search,omitempty"`                                 // comment search
}

func (x *GetTransactionsTotalsRequest) Reset() <span class="cov0" title="0">{
        *x = GetTransactionsTotalsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransactionsTotalsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionsTotalsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionsTotalsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionsTotalsRequest.ProtoReflect.Descriptor instead.
func (*GetTransactionsTotalsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetTransactionsTotalsRequest) GetDateRange() *DateRange <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateRange
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTransactionsTotalsRequest) GetCategoryIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTransactionsTotalsRequest) GetType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransactionType_TRANSACTION_TYPE_UNSPECIFIED</span>
}

func (x *GetTransactionsTotalsRequest) GetMinMinorUnits() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinMinorUnits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTransactionsTotalsRequest) GetMaxMinorUnits() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxMinorUnits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTransactionsTotalsRequest) GetCurrencyCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrencyCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTransactionsTotalsRequest) GetSearch() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Search
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTransactionsTotalsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TotalIncome  *Money `protobuf:"bytes,1,opt,name=total_income,json=totalIncome,proto3" json:"total_income,omitempty"`    // in tenant base currency
        TotalExpense *Money `protobuf:"bytes,2,opt,name=total_expense,json=totalExpense,proto3" json:"total_expense,omitempty"` // in tenant base currency
}

func (x *GetTransactionsTotalsResponse) Reset() <span class="cov0" title="0">{
        *x = GetTransactionsTotalsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_transaction_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransactionsTotalsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionsTotalsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionsTotalsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_transaction_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionsTotalsResponse.ProtoReflect.Descriptor instead.
func (*GetTransactionsTotalsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_transaction_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetTransactionsTotalsResponse) GetTotalIncome() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalIncome
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTransactionsTotalsResponse) GetTotalExpense() *Money <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalExpense
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_budget_v1_transaction_proto protoreflect.FileDescriptor

var file_budget_v1_transaction_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x72, 0x61, 0x6e,
        0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x66, 0x69, 0x65, 0x6c, 0x64,
        0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0xb6, 0x03, 0x0a, 0x0b, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x69, 0x64,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74, 0x49, 0x64,
        0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x64, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x79,
        0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x28, 0x0a, 0x06, 0x61, 0x6d,
        0x6f, 0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x06, 0x61, 0x6d,
        0x6f, 0x75, 0x6e, 0x74, 0x12, 0x31, 0x0a, 0x0b, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x61, 0x6d, 0x6f,
        0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x0a, 0x62, 0x61, 0x73,
        0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x21, 0x0a, 0x02, 0x66, 0x78, 0x18, 0x08, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x46, 0x78, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x02, 0x66, 0x78, 0x12, 0x3b, 0x0a, 0x0b, 0x6f, 0x63,
        0x63, 0x75, 0x72, 0x72, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x6f, 0x63, 0x63,
        0x75, 0x72, 0x72, 0x65, 0x64, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
        0x74, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
        0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0xec, 0x01, 0x0a,
        0x18, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54,
        0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x64, 0x12, 0x28, 0x0a, 0x06, 0x61, 0x6d,
        0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x06, 0x61, 0x6d,
        0x6f, 0x75, 0x6e, 0x74, 0x12, 0x3b, 0x0a, 0x0b, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x64,
        0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x64, 0x41,
        0x74, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0x55, 0x0a, 0x19, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e,
        0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61,
        0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x22, 0xa1, 0x01, 0x0a, 0x18, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12,
        0x38, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x74, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3b, 0x0a, 0x0b, 0x75, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x61, 0x73, 0x6b, 0x52, 0x0a, 0x75, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x4d, 0x61, 0x73, 0x6b, 0x22, 0x55, 0x0a, 0x19, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2a, 0x0a,
        0x18, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x1b, 0x0a, 0x19, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x27, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22,
        0x52, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x0b, 0x74, 0x72, 0x61,
        0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x22, 0xda, 0x02, 0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x72, 0x61, 0x6e,
        0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x2a, 0x0a, 0x04, 0x70, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x67, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x04, 0x70, 0x61, 0x67, 0x65, 0x12, 0x33, 0x0a, 0x0a, 0x64,
        0x61, 0x74, 0x65, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x14, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x61, 0x74, 0x65,
        0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x09, 0x64, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65,
        0x12, 0x21, 0x0a, 0x0c, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x64, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
        0x49, 0x64, 0x73, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x0e, 0x32, 0x1a, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
        0x79, 0x70, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72,
        0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x6d, 0x69,
        0x6e, 0x4d, 0x69, 0x6e, 0x6f, 0x72, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x6d,
        0x61, 0x78, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x4d, 0x69, 0x6e, 0x6f, 0x72, 0x55, 0x6e,
        0x69, 0x74, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f,
        0x63, 0x6f, 0x64, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x75, 0x72, 0x72,
        0x65, 0x6e, 0x63, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x22, 0x83, 0x01, 0x0a, 0x18, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3a, 0x0a,
        0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x74, 0x72, 0x61,
        0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2b, 0x0a, 0x04, 0x70, 0x61, 0x67,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x52, 0x04, 0x70, 0x61, 0x67, 0x65, 0x22, 0xb3, 0x02, 0x0a, 0x1c, 0x47, 0x65, 0x74, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x73,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x33, 0x0a, 0x0a, 0x64, 0x61, 0x74, 0x65, 0x5f,
        0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6e, 0x67,
        0x65, 0x52, 0x09, 0x64, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x21, 0x0a, 0x0c,
        0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x0b, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x64, 0x73, 0x12,
        0x2e, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e,
        0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61,
        0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12,
        0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x75, 0x6e, 0x69,
        0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x4d, 0x69, 0x6e,
        0x6f, 0x72, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x61, 0x78, 0x5f, 0x6d,
        0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x0d, 0x6d, 0x61, 0x78, 0x4d, 0x69, 0x6e, 0x6f, 0x72, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12,
        0x23, 0x0a, 0x0d, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65,
        0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
        0x43, 0x6f, 0x64, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x18, 0x07,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x22, 0x8b, 0x01, 0x0a,
        0x1d, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x54, 0x6f, 0x74, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x33,
        0x0a, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31,
        0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x6e, 0x63,
        0x6f, 0x6d, 0x65, 0x12, 0x35, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x65, 0x78, 0x70,
        0x65, 0x6e, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x62, 0x75, 0x64,
        0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x6e, 0x65, 0x79, 0x52, 0x0c, 0x74, 0x6f,
        0x74, 0x61, 0x6c, 0x45, 0x78, 0x70, 0x65, 0x6e, 0x73, 0x65, 0x32, 0xd4, 0x04, 0x0a, 0x12, 0x54,
        0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x5e, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x5e, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x5e, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e,
        0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x55, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e,
        0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5b, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74,
        0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x22, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x23, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73,
        0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x6a, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e,
        0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x73, 0x12, 0x27,
        0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x73,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
        0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f, 0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65,
        0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f,
        0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_transaction_proto_rawDescOnce sync.Once
        file_budget_v1_transaction_proto_rawDescData = file_budget_v1_transaction_proto_rawDesc
)

func file_budget_v1_transaction_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_transaction_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_transaction_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_transaction_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_transaction_proto_rawDescData</span>
}

var file_budget_v1_transaction_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_budget_v1_transaction_proto_goTypes = []interface{}{
        (*Transaction)(nil),                   // 0: budget.v1.Transaction
        (*CreateTransactionRequest)(nil),      // 1: budget.v1.CreateTransactionRequest
        (*CreateTransactionResponse)(nil),     // 2: budget.v1.CreateTransactionResponse
        (*UpdateTransactionRequest)(nil),      // 3: budget.v1.UpdateTransactionRequest
        (*UpdateTransactionResponse)(nil),     // 4: budget.v1.UpdateTransactionResponse
        (*DeleteTransactionRequest)(nil),      // 5: budget.v1.DeleteTransactionRequest
        (*DeleteTransactionResponse)(nil),     // 6: budget.v1.DeleteTransactionResponse
        (*GetTransactionRequest)(nil),         // 7: budget.v1.GetTransactionRequest
        (*GetTransactionResponse)(nil),        // 8: budget.v1.GetTransactionResponse
        (*ListTransactionsRequest)(nil),       // 9: budget.v1.ListTransactionsRequest
        (*ListTransactionsResponse)(nil),      // 10: budget.v1.ListTransactionsResponse
        (*GetTransactionsTotalsRequest)(nil),  // 11: budget.v1.GetTransactionsTotalsRequest
        (*GetTransactionsTotalsResponse)(nil), // 12: budget.v1.GetTransactionsTotalsResponse
        (TransactionType)(0),                  // 13: budget.v1.TransactionType
        (*Money)(nil),                         // 14: budget.v1.Money
        (*FxInfo)(nil),                        // 15: budget.v1.FxInfo
        (*timestamppb.Timestamp)(nil),         // 16: google.protobuf.Timestamp
        (*fieldmaskpb.FieldMask)(nil),         // 17: google.protobuf.FieldMask
        (*PageRequest)(nil),                   // 18: budget.v1.PageRequest
        (*DateRange)(nil),                     // 19: budget.v1.DateRange
        (*PageResponse)(nil),                  // 20: budget.v1.PageResponse
}
var file_budget_v1_transaction_proto_depIdxs = []int32{
        13, // 0: budget.v1.Transaction.type:type_name -&gt; budget.v1.TransactionType
        14, // 1: budget.v1.Transaction.amount:type_name -&gt; budget.v1.Money
        14, // 2: budget.v1.Transaction.base_amount:type_name -&gt; budget.v1.Money
        15, // 3: budget.v1.Transaction.fx:type_name -&gt; budget.v1.FxInfo
        16, // 4: budget.v1.Transaction.occurred_at:type_name -&gt; google.protobuf.Timestamp
        16, // 5: budget.v1.Transaction.created_at:type_name -&gt; google.protobuf.Timestamp
        13, // 6: budget.v1.CreateTransactionRequest.type:type_name -&gt; budget.v1.TransactionType
        14, // 7: budget.v1.CreateTransactionRequest.amount:type_name -&gt; budget.v1.Money
        16, // 8: budget.v1.CreateTransactionRequest.occurred_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 9: budget.v1.CreateTransactionResponse.transaction:type_name -&gt; budget.v1.Transaction
        0,  // 10: budget.v1.UpdateTransactionRequest.transaction:type_name -&gt; budget.v1.Transaction
        17, // 11: budget.v1.UpdateTransactionRequest.update_mask:type_name -&gt; google.protobuf.FieldMask
        0,  // 12: budget.v1.UpdateTransactionResponse.transaction:type_name -&gt; budget.v1.Transaction
        0,  // 13: budget.v1.GetTransactionResponse.transaction:type_name -&gt; budget.v1.Transaction
        18, // 14: budget.v1.ListTransactionsRequest.page:type_name -&gt; budget.v1.PageRequest
        19, // 15: budget.v1.ListTransactionsRequest.date_range:type_name -&gt; budget.v1.DateRange
        13, // 16: budget.v1.ListTransactionsRequest.type:type_name -&gt; budget.v1.TransactionType
        0,  // 17: budget.v1.ListTransactionsResponse.transactions:type_name -&gt; budget.v1.Transaction
        20, // 18: budget.v1.ListTransactionsResponse.page:type_name -&gt; budget.v1.PageResponse
        19, // 19: budget.v1.GetTransactionsTotalsRequest.date_range:type_name -&gt; budget.v1.DateRange
        13, // 20: budget.v1.GetTransactionsTotalsRequest.type:type_name -&gt; budget.v1.TransactionType
        14, // 21: budget.v1.GetTransactionsTotalsResponse.total_income:type_name -&gt; budget.v1.Money
        14, // 22: budget.v1.GetTransactionsTotalsResponse.total_expense:type_name -&gt; budget.v1.Money
        1,  // 23: budget.v1.TransactionService.CreateTransaction:input_type -&gt; budget.v1.CreateTransactionRequest
        3,  // 24: budget.v1.TransactionService.UpdateTransaction:input_type -&gt; budget.v1.UpdateTransactionRequest
        5,  // 25: budget.v1.TransactionService.DeleteTransaction:input_type -&gt; budget.v1.DeleteTransactionRequest
        7,  // 26: budget.v1.TransactionService.GetTransaction:input_type -&gt; budget.v1.GetTransactionRequest
        9,  // 27: budget.v1.TransactionService.ListTransactions:input_type -&gt; budget.v1.ListTransactionsRequest
        11, // 28: budget.v1.TransactionService.GetTransactionsTotals:input_type -&gt; budget.v1.GetTransactionsTotalsRequest
        2,  // 29: budget.v1.TransactionService.CreateTransaction:output_type -&gt; budget.v1.CreateTransactionResponse
        4,  // 30: budget.v1.TransactionService.UpdateTransaction:output_type -&gt; budget.v1.UpdateTransactionResponse
        6,  // 31: budget.v1.TransactionService.DeleteTransaction:output_type -&gt; budget.v1.DeleteTransactionResponse
        8,  // 32: budget.v1.TransactionService.GetTransaction:output_type -&gt; budget.v1.GetTransactionResponse
        10, // 33: budget.v1.TransactionService.ListTransactions:output_type -&gt; budget.v1.ListTransactionsResponse
        12, // 34: budget.v1.TransactionService.GetTransactionsTotals:output_type -&gt; budget.v1.GetTransactionsTotalsResponse
        29, // [29:35] is the sub-list for method output_type
        23, // [23:29] is the sub-list for method input_type
        23, // [23:23] is the sub-list for extension type_name
        23, // [23:23] is the sub-list for extension extendee
        0,  // [0:23] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_transaction_proto_init() }</span>
func file_budget_v1_transaction_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_transaction_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_budget_v1_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_transaction_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Transaction); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateTransactionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateTransactionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateTransactionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateTransactionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteTransactionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteTransactionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransactionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransactionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListTransactionsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListTransactionsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransactionsTotalsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_transaction_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransactionsTotalsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_transaction_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_transaction_proto_goTypes,
                DependencyIndexes: file_budget_v1_transaction_proto_depIdxs,
                MessageInfos:      file_budget_v1_transaction_proto_msgTypes,
        }.Build()
        File_budget_v1_transaction_proto = out.File
        file_budget_v1_transaction_proto_rawDesc = nil
        file_budget_v1_transaction_proto_goTypes = nil
        file_budget_v1_transaction_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/transaction.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        TransactionService_CreateTransaction_FullMethodName     = "/budget.v1.TransactionService/CreateTransaction"
        TransactionService_UpdateTransaction_FullMethodName     = "/budget.v1.TransactionService/UpdateTransaction"
        TransactionService_DeleteTransaction_FullMethodName     = "/budget.v1.TransactionService/DeleteTransaction"
        TransactionService_GetTransaction_FullMethodName        = "/budget.v1.TransactionService/GetTransaction"
        TransactionService_ListTransactions_FullMethodName      = "/budget.v1.TransactionService/ListTransactions"
        TransactionService_GetTransactionsTotals_FullMethodName = "/budget.v1.TransactionService/GetTransactionsTotals"
)

// TransactionServiceClient is the client API for TransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactionServiceClient interface {
        CreateTransaction(ctx context.Context, in *CreateTransactionRequest, opts ...grpc.CallOption) (*CreateTransactionResponse, error)
        UpdateTransaction(ctx context.Context, in *UpdateTransactionRequest, opts ...grpc.CallOption) (*UpdateTransactionResponse, error)
        DeleteTransaction(ctx context.Context, in *DeleteTransactionRequest, opts ...grpc.CallOption) (*DeleteTransactionResponse, error)
        GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
        ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error)
        // Returns totals (income/expense) for the provided filters, ignoring pagination
        GetTransactionsTotals(ctx context.Context, in *GetTransactionsTotalsRequest, opts ...grpc.CallOption) (*GetTransactionsTotalsResponse, error)
}

type transactionServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTransactionServiceClient(cc grpc.ClientConnInterface) TransactionServiceClient <span class="cov0" title="0">{
        return &amp;transactionServiceClient{cc}
}</span>

func (c *transactionServiceClient) CreateTransaction(ctx context.Context, in *CreateTransactionRequest, opts ...grpc.CallOption) (*CreateTransactionResponse, error) <span class="cov0" title="0">{
        out := new(CreateTransactionResponse)
        err := c.cc.Invoke(ctx, TransactionService_CreateTransaction_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transactionServiceClient) UpdateTransaction(ctx context.Context, in *UpdateTransactionRequest, opts ...grpc.CallOption) (*UpdateTransactionResponse, error) <span class="cov0" title="0">{
        out := new(UpdateTransactionResponse)
        err := c.cc.Invoke(ctx, TransactionService_UpdateTransaction_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transactionServiceClient) DeleteTransaction(ctx context.Context, in *DeleteTransactionRequest, opts ...grpc.CallOption) (*DeleteTransactionResponse, error) <span class="cov0" title="0">{
        out := new(DeleteTransactionResponse)
        err := c.cc.Invoke(ctx, TransactionService_DeleteTransaction_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transactionServiceClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) <span class="cov0" title="0">{
        out := new(GetTransactionResponse)
        err := c.cc.Invoke(ctx, TransactionService_GetTransaction_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transactionServiceClient) ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error) <span class="cov0" title="0">{
        out := new(ListTransactionsResponse)
        err := c.cc.Invoke(ctx, TransactionService_ListTransactions_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transactionServiceClient) GetTransactionsTotals(ctx context.Context, in *GetTransactionsTotalsRequest, opts ...grpc.CallOption) (*GetTransactionsTotalsResponse, error) <span class="cov0" title="0">{
        out := new(GetTransactionsTotalsResponse)
        err := c.cc.Invoke(ctx, TransactionService_GetTransactionsTotals_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TransactionServiceServer is the server API for TransactionService service.
// All implementations must embed UnimplementedTransactionServiceServer
// for forward compatibility
type TransactionServiceServer interface {
        CreateTransaction(context.Context, *CreateTransactionRequest) (*CreateTransactionResponse, error)
        UpdateTransaction(context.Context, *UpdateTransactionRequest) (*UpdateTransactionResponse, error)
        DeleteTransaction(context.Context, *DeleteTransactionRequest) (*DeleteTransactionResponse, error)
        GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
        ListTransactions(context.Context, *ListTransactionsRequest) (*ListTransactionsResponse, error)
        // Returns totals (income/expense) for the provided filters, ignoring pagination
        GetTransactionsTotals(context.Context, *GetTransactionsTotalsRequest) (*GetTransactionsTotalsResponse, error)
        mustEmbedUnimplementedTransactionServiceServer()
}

// UnimplementedTransactionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTransactionServiceServer struct {
}

func (UnimplementedTransactionServiceServer) CreateTransaction(context.Context, *CreateTransactionRequest) (*CreateTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateTransaction not implemented")
}</span>
func (UnimplementedTransactionServiceServer) UpdateTransaction(context.Context, *UpdateTransactionRequest) (*UpdateTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateTransaction not implemented")
}</span>
func (UnimplementedTransactionServiceServer) DeleteTransaction(context.Context, *DeleteTransactionRequest) (*DeleteTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteTransaction not implemented")
}</span>
func (UnimplementedTransactionServiceServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}</span>
func (UnimplementedTransactionServiceServer) ListTransactions(context.Context, *ListTransactionsRequest) (*ListTransactionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListTransactions not implemented")
}</span>
func (UnimplementedTransactionServiceServer) GetTransactionsTotals(context.Context, *GetTransactionsTotalsRequest) (*GetTransactionsTotalsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTransactionsTotals not implemented")
}</span>
func (UnimplementedTransactionServiceServer) mustEmbedUnimplementedTransactionServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeTransactionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransactionServiceServer will
// result in compilation errors.
type UnsafeTransactionServiceServer interface {
        mustEmbedUnimplementedTransactionServiceServer()
}

func RegisterTransactionServiceServer(s grpc.ServiceRegistrar, srv TransactionServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;TransactionService_ServiceDesc, srv)
}</span>

func _TransactionService_CreateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).CreateTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_CreateTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).CreateTransaction(ctx, req.(*CreateTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransactionService_UpdateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).UpdateTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_UpdateTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).UpdateTransaction(ctx, req.(*UpdateTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransactionService_DeleteTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).DeleteTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_DeleteTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).DeleteTransaction(ctx, req.(*DeleteTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransactionService_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).GetTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_GetTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).GetTransaction(ctx, req.(*GetTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransactionService_ListTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListTransactionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).ListTransactions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_ListTransactions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).ListTransactions(ctx, req.(*ListTransactionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransactionService_GetTransactionsTotals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTransactionsTotalsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).GetTransactionsTotals(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransactionService_GetTransactionsTotals_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransactionServiceServer).GetTransactionsTotals(ctx, req.(*GetTransactionsTotalsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TransactionService_ServiceDesc is the grpc.ServiceDesc for TransactionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransactionService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.TransactionService",
        HandlerType: (*TransactionServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateTransaction",
                        Handler:    _TransactionService_CreateTransaction_Handler,
                },
                {
                        MethodName: "UpdateTransaction",
                        Handler:    _TransactionService_UpdateTransaction_Handler,
                },
                {
                        MethodName: "DeleteTransaction",
                        Handler:    _TransactionService_DeleteTransaction_Handler,
                },
                {
                        MethodName: "GetTransaction",
                        Handler:    _TransactionService_GetTransaction_Handler,
                },
                {
                        MethodName: "ListTransactions",
                        Handler:    _TransactionService_ListTransactions_Handler,
                },
                {
                        MethodName: "GetTransactionsTotals",
                        Handler:    _TransactionService_GetTransactionsTotals_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/transaction.proto",
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        (unknown)
// source: budget/v1/user.proto

package budgetv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // UUID
        Email         string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        Locale        string                 `protobuf:"bytes,4,opt,name=locale,proto3" json:"locale,omitempty"` // e.g. "en", "ru"
        EmailVerified bool                   `protobuf:"varint,5,opt,name=email_verified,json=emailVerified,proto3" json:"email_verified,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmailVerified() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EmailVerified
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *User) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetMeRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetMeRequest) Reset() <span class="cov0" title="0">{
        *x = GetMeRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMeRequest.ProtoReflect.Descriptor instead.
func (*GetMeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{1}
}</span>

type GetMeResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *GetMeResponse) Reset() <span class="cov0" title="0">{
        *x = GetMeResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMeResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMeResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMeResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMeResponse.ProtoReflect.Descriptor instead.
func (*GetMeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetMeResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateProfileRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Locale string `protobuf:"bytes,2,opt,name=locale,proto3" json:"locale,omitempty"`
}

func (x *UpdateProfileRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateProfileRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateProfileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateProfileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateProfileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateProfileRequest.ProtoReflect.Descriptor instead.
func (*UpdateProfileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UpdateProfileRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateProfileRequest) GetLocale() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locale
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateProfileResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *UpdateProfileResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateProfileResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateProfileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateProfileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateProfileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateProfileResponse.ProtoReflect.Descriptor instead.
func (*UpdateProfileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UpdateProfileResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ChangePasswordRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CurrentPassword string `protobuf:"bytes,1,opt,name=current_password,json=currentPassword,proto3" json:"current_password,omitempty"`
        NewPassword     string `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
}

func (x *ChangePasswordRequest) Reset() <span class="cov0" title="0">{
        *x = ChangePasswordRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ChangePasswordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChangePasswordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChangePasswordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChangePasswordRequest.ProtoReflect.Descriptor instead.
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ChangePasswordRequest) GetCurrentPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ChangePasswordRequest) GetNewPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ChangePasswordResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ChangePasswordResponse) Reset() <span class="cov0" title="0">{
        *x = ChangePasswordResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_budget_v1_user_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ChangePasswordResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChangePasswordResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChangePasswordResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_budget_v1_user_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChangePasswordResponse.ProtoReflect.Descriptor instead.
func (*ChangePasswordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_budget_v1_user_proto_rawDescGZIP(), []int{6}
}</span>

var File_budget_v1_user_proto protoreflect.FileDescriptor

var file_budget_v1_user_proto_rawDesc = []byte{
        0x0a, 0x14, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x22, 0xf5, 0x01, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65,
        0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69,
        0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x12, 0x25, 0x0a,
        0x0e, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x56, 0x65, 0x72, 0x69,
        0x66, 0x69, 0x65, 0x64, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12,
        0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
        0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x0e, 0x0a, 0x0c, 0x47, 0x65,
        0x74, 0x4d, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x34, 0x0a, 0x0d, 0x47, 0x65,
        0x74, 0x4d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x04, 0x75,
        0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72,
        0x22, 0x42, 0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06,
        0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f,
        0x63, 0x61, 0x6c, 0x65, 0x22, 0x3c, 0x0a, 0x15, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x72,
        0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a,
        0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x75,
        0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73,
        0x65, 0x72, 0x22, 0x65, 0x0a, 0x15, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73,
        0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x63,
        0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x50, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x65, 0x77, 0x5f, 0x70, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6e, 0x65,
        0x77, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x18, 0x0a, 0x16, 0x43, 0x68, 0x61,
        0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x32, 0xf4, 0x01, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x3a, 0x0a, 0x05, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x12, 0x17, 0x2e, 0x62,
        0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x52, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
        0x12, 0x1f, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2e, 0x76,
        0x31, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74,
        0x2e, 0x76, 0x31, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x38, 0x5a, 0x36, 0x67, 0x69,
        0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6f,
        0x6e, 0x34, 0x38, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67,
        0x6f, 0x2f, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x2f, 0x76, 0x31, 0x3b, 0x62, 0x75, 0x64, 0x67,
        0x65, 0x74, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_budget_v1_user_proto_rawDescOnce sync.Once
        file_budget_v1_user_proto_rawDescData = file_budget_v1_user_proto_rawDesc
)

func file_budget_v1_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_budget_v1_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_budget_v1_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_budget_v1_user_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_budget_v1_user_proto_rawDescData</span>
}

var file_budget_v1_user_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_budget_v1_user_proto_goTypes = []interface{}{
        (*User)(nil),                   // 0: budget.v1.User
        (*GetMeRequest)(nil),           // 1: budget.v1.GetMeRequest
        (*GetMeResponse)(nil),          // 2: budget.v1.GetMeResponse
        (*UpdateProfileRequest)(nil),   // 3: budget.v1.UpdateProfileRequest
        (*UpdateProfileResponse)(nil),  // 4: budget.v1.UpdateProfileResponse
        (*ChangePasswordRequest)(nil),  // 5: budget.v1.ChangePasswordRequest
        (*ChangePasswordResponse)(nil), // 6: budget.v1.ChangePasswordResponse
        (*timestamppb.Timestamp)(nil),  // 7: google.protobuf.Timestamp
}
var file_budget_v1_user_proto_depIdxs = []int32{
        7, // 0: budget.v1.User.created_at:type_name -&gt; google.protobuf.Timestamp
        7, // 1: budget.v1.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        0, // 2: budget.v1.GetMeResponse.user:type_name -&gt; budget.v1.User
        0, // 3: budget.v1.UpdateProfileResponse.user:type_name -&gt; budget.v1.User
        1, // 4: budget.v1.UserService.GetMe:input_type -&gt; budget.v1.GetMeRequest
        3, // 5: budget.v1.UserService.UpdateProfile:input_type -&gt; budget.v1.UpdateProfileRequest
        5, // 6: budget.v1.UserService.ChangePassword:input_type -&gt; budget.v1.ChangePasswordRequest
        2, // 7: budget.v1.UserService.GetMe:output_type -&gt; budget.v1.GetMeResponse
        4, // 8: budget.v1.UserService.UpdateProfile:output_type -&gt; budget.v1.UpdateProfileResponse
        6, // 9: budget.v1.UserService.ChangePassword:output_type -&gt; budget.v1.ChangePasswordResponse
        7, // [7:10] is the sub-list for method output_type
        4, // [4:7] is the sub-list for method input_type
        4, // [4:4] is the sub-list for extension type_name
        4, // [4:4] is the sub-list for extension extendee
        0, // [0:4] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_budget_v1_user_proto_init() }</span>
func file_budget_v1_user_proto_init() <span class="cov0" title="0">{
        if File_budget_v1_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_budget_v1_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*User); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMeRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMeResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateProfileRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateProfileResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ChangePasswordRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_budget_v1_user_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ChangePasswordResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_budget_v1_user_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   7,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_budget_v1_user_proto_goTypes,
                DependencyIndexes: file_budget_v1_user_proto_depIdxs,
                MessageInfos:      file_budget_v1_user_proto_msgTypes,
        }.Build()
        File_budget_v1_user_proto = out.File
        file_budget_v1_user_proto_rawDesc = nil
        file_budget_v1_user_proto_goTypes = nil
        file_budget_v1_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: budget/v1/user.proto

package budgetv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        UserService_GetMe_FullMethodName          = "/budget.v1.UserService/GetMe"
        UserService_UpdateProfile_FullMethodName  = "/budget.v1.UserService/UpdateProfile"
        UserService_ChangePassword_FullMethodName = "/budget.v1.UserService/ChangePassword"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
        GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error)
        UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UpdateProfileResponse, error)
        ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error) <span class="cov0" title="0">{
        out := new(GetMeResponse)
        err := c.cc.Invoke(ctx, UserService_GetMe_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UpdateProfileResponse, error) <span class="cov0" title="0">{
        out := new(UpdateProfileResponse)
        err := c.cc.Invoke(ctx, UserService_UpdateProfile_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) <span class="cov0" title="0">{
        out := new(ChangePasswordResponse)
        err := c.cc.Invoke(ctx, UserService_ChangePassword_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
        GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error)
        UpdateProfile(context.Context, *UpdateProfileRequest) (*UpdateProfileResponse, error)
        ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMe not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateProfile(context.Context, *UpdateProfileRequest) (*UpdateProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateProfile not implemented")
}</span>
func (UnimplementedUserServiceServer) ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;UserService_ServiceDesc, srv)
}</span>

func _UserService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetMe(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetMe_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetMe(ctx, req.(*GetMeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateProfileRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateProfile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateProfile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateProfile(ctx, req.(*UpdateProfileRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ChangePasswordRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ChangePassword(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_ChangePassword_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "budget.v1.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetMe",
                        Handler:    _UserService_GetMe_Handler,
                },
                {
                        MethodName: "UpdateProfile",
                        Handler:    _UserService_UpdateProfile_Handler,
                },
                {
                        MethodName: "ChangePassword",
                        Handler:    _UserService_ChangePassword_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "budget/v1/user.proto",
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package config loads and holds application configuration from files and env.
package config

import (
        "fmt"
        "strings"

        "github.com/joho/godotenv"
        "github.com/spf13/viper"
)

// Config is the root application configuration loaded from YAML/env.
type Config struct {
        Telegram TelegramConfig `mapstructure:"telegram"`
        GRPC     GRPCConfig     `mapstructure:"grpc"`
        Database DatabaseConfig `mapstructure:"database"`
        Logging  LoggingConfig  `mapstructure:"logging"`
        Metrics  MetricsConfig  `mapstructure:"metrics"`
        Server   ServerConfig   `mapstructure:"server"`
        OAuth    OAuthConfig    `mapstructure:"oauth"`
}

// TelegramConfig holds Telegram Bot API settings.
type TelegramConfig struct {
        // Token is a Telegram Bot API token
        Token string `mapstructure:"token"`
        // APIBaseURL allows pointing to a local Telegram emulator
        APIBaseURL string `mapstructure:"api_base_url"`
        // Debug enables verbose logging for bot API
        Debug bool `mapstructure:"debug"`
        // UpdatesTimeout long polling timeout in seconds
        UpdatesTimeout int `mapstructure:"updates_timeout"`
        // WebhookEnable toggles webhook mode
        WebhookEnable bool `mapstructure:"webhook_enable"`
        // WebhookURL public URL for webhook
        WebhookURL string `mapstructure:"webhook_url"`
        // WebhookDomain domain with protocol (http:// or https://) for webhook URL
        WebhookDomain string `mapstructure:"webhook_domain"`
        // WebhookPath path to serve webhook on
        WebhookPath string `mapstructure:"webhook_path"`
}

// GRPCConfig holds backend gRPC settings.
type GRPCConfig struct {
        // Address of backend gRPC server
        Address string `mapstructure:"address"`
        // Insecure skips TLS for local development
        Insecure bool `mapstructure:"insecure"`
}

// DatabaseConfig contains DB connection settings.
type DatabaseConfig struct {
        // Driver is a database driver name, e.g., sqlite
        Driver string `mapstructure:"driver"`
        // DSN is a connection string
        DSN string `mapstructure:"dsn"`
}

// LoggingConfig holds logger settings.
type LoggingConfig struct {
        // Level is a zap log level (debug, info, warn, error)
        Level string `mapstructure:"level"`
}

// MetricsConfig holds metrics service settings.
type MetricsConfig struct {
        // Enabled toggles Prometheus metrics endpoint
        Enabled bool `mapstructure:"enabled"`
        // Address is an HTTP listen address for metrics
        Address string `mapstructure:"address"`
}

// ServerConfig holds http server settings.
type ServerConfig struct {
        // Address is an HTTP listen address for health/metrics
        Address string `mapstructure:"address"`
}

// OAuthConfig holds OAuth2 settings.
type OAuthConfig struct {
        // WebBaseURL is the base URL for OAuth web interface
        WebBaseURL string `mapstructure:"web_base_url"`
}

// Load loads configuration from configs/config.yaml and environment variables.
func Load() (*Config, error) <span class="cov8" title="1">{
        v := viper.New()

        // Load environment variables from .env if present
        _ = godotenv.Load()

        // Defaults
        v.SetDefault("telegram.debug", true)
        v.SetDefault("telegram.updates_timeout", 30)
        v.SetDefault("telegram.webhook_enable", false)
        v.SetDefault("telegram.webhook_path", "/tg")
        v.SetDefault("grpc.address", "127.0.0.1:8081")
        v.SetDefault("grpc.insecure", true)
        v.SetDefault("database.driver", "sqlite")
        v.SetDefault("database.dsn", "file:./data/bot.sqlite?_foreign_keys=on")
        v.SetDefault("logging.level", "debug")
        v.SetDefault("metrics.enabled", false)
        v.SetDefault("metrics.address", ":9090")
        v.SetDefault("server.address", ":8088")
        v.SetDefault("oauth.web_base_url", "http://localhost:3000")

        // Files
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath("./configs")

        // Env
        v.SetEnvPrefix("BOT")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Map some convenient env names
        _ = v.BindEnv("telegram.token", "TELEGRAM_BOT_TOKEN")
        _ = v.BindEnv("telegram.api_base_url", "TELEGRAM_API_BASE_URL")
        _ = v.BindEnv("telegram.debug", "TELEGRAM_DEBUG")
        _ = v.BindEnv("telegram.updates_timeout", "TELEGRAM_UPDATES_TIMEOUT")
        _ = v.BindEnv("telegram.webhook_enable", "TELEGRAM_WEBHOOK_ENABLE")
        _ = v.BindEnv("telegram.webhook_url", "TELEGRAM_WEBHOOK_URL")
        _ = v.BindEnv("telegram.webhook_domain", "TELEGRAM_WEBHOOK_DOMAIN")
        _ = v.BindEnv("telegram.webhook_path", "TELEGRAM_WEBHOOK_PATH")

        _ = v.BindEnv("grpc.address", "GRPC_SERVER_ADDRESS")
        _ = v.BindEnv("grpc.insecure", "GRPC_INSECURE")

        _ = v.BindEnv("database.driver", "DATABASE_DRIVER")
        _ = v.BindEnv("database.dsn", "DATABASE_DSN")

        _ = v.BindEnv("logging.level", "LOG_LEVEL")

        _ = v.BindEnv("metrics.enabled", "METRICS_ENABLED")
        _ = v.BindEnv("metrics.address", "METRICS_ADDRESS")
        _ = v.BindEnv("server.address", "SERVER_ADDRESS")

        // Read file if present
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                // Non-fatal: allow running with only envs/defaults
                // But return a clearer error if it's an unexpected issue.
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed reading config file: %w", err)
                }</span>
        }

        <span class="cov8" title="1">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed unmarshalling config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}


</pre>
		
		<pre class="file" id="file45" style="display: none">// Package db provides database initialization and migrations.
package db

import (
        "database/sql"
        "fmt"

        migrate "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/sqlite"
        _ "github.com/golang-migrate/migrate/v4/source/file" // allow file:// migrations
        "go.uber.org/zap"
)

// OpenAndMigrate opens SQLite database and runs migrations from a directory path.
func OpenAndMigrate(dsn string, migrationsDir string, log *zap.Logger) (*sql.DB, error) <span class="cov8" title="1">{
        database, err := sql.Open("sqlite", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open sqlite: %w", err)
        }</span>

        // Ensure connection works
        <span class="cov8" title="1">if err = database.Ping(); err != nil </span><span class="cov0" title="0">{
                _ = database.Close()
                return nil, fmt.Errorf("ping sqlite: %w", err)
        }</span>

        <span class="cov8" title="1">driver, err := sqlite.WithInstance(database, &amp;sqlite.Config{})
        if err != nil </span><span class="cov0" title="0">{
                _ = database.Close()
                return nil, fmt.Errorf("migrate driver: %w", err)
        }</span>

        <span class="cov8" title="1">migrationsPath := fmt.Sprintf("file://%s", migrationsDir)
        m, err := migrate.NewWithDatabaseInstance(migrationsPath, "sqlite", driver)
        if err != nil </span><span class="cov0" title="0">{
                _ = database.Close()
                return nil, fmt.Errorf("migrate init: %w", err)
        }</span>

        <span class="cov8" title="1">if err = m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                _ = database.Close()
                return nil, fmt.Errorf("migrate up: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info("database ready")
        return database, nil</span>
}


</pre>
		
		<pre class="file" id="file46" style="display: none">// Package logger configures the application logger.
package logger

import (
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// New builds a zap.Logger based on textual level (debug, info, warn, error).
func New(level string) (*zap.Logger, error) <span class="cov8" title="1">{
        var cfg zap.Config
        if strings.ToLower(level) == "debug" </span><span class="cov8" title="1">{
                cfg = zap.NewDevelopmentConfig()
                cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        }</span> else<span class="cov8" title="1"> {
                cfg = zap.NewProductionConfig()
                cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        }</span>
        <span class="cov8" title="1">if level != "" </span><span class="cov8" title="1">{
                if err := cfg.Level.UnmarshalText([]byte(level)); err != nil </span><span class="cov8" title="1">{
                        _ = err // ignore invalid and keep default
                }</span>
        }
        <span class="cov8" title="1">return cfg.Build()</span>
}


</pre>
		
		<pre class="file" id="file47" style="display: none">// Package repository contains persistence layer implementations.
package repository

import (
        "context"
        "database/sql"
)

// CategoryMapping associates a keyword with a category within a tenant.
type CategoryMapping struct {
        ID         string
        TenantID   string
        Keyword    string
        CategoryID string
        Priority   int
}

// CategoryMappingRepository defines operations for mappings.
type CategoryMappingRepository interface {
        AddMapping(ctx context.Context, m *CategoryMapping) error
        RemoveMapping(ctx context.Context, tenantID string, keyword string) error
        FindMapping(ctx context.Context, tenantID string, keyword string) (*CategoryMapping, error)
        ListMappings(ctx context.Context, tenantID string) ([]*CategoryMapping, error)
}

// SQLiteCategoryMappingRepository implements CategoryMappingRepository over SQLite.
type SQLiteCategoryMappingRepository struct {
        db *sql.DB
}

// NewSQLiteCategoryMappingRepository constructs a repository.
func NewSQLiteCategoryMappingRepository(db *sql.DB) *SQLiteCategoryMappingRepository <span class="cov8" title="1">{
        return &amp;SQLiteCategoryMappingRepository{db: db}
}</span>

// AddMapping creates or updates a mapping.
func (r *SQLiteCategoryMappingRepository) AddMapping(ctx context.Context, m *CategoryMapping) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `
                INSERT INTO category_mappings (id, tenant_id, keyword, category_id, priority)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(tenant_id, keyword) DO UPDATE SET
                        category_id = excluded.category_id,
                        priority = excluded.priority
        `, m.ID, m.TenantID, m.Keyword, m.CategoryID, m.Priority)
        return err
}</span>

// RemoveMapping deletes a mapping.
func (r *SQLiteCategoryMappingRepository) RemoveMapping(ctx context.Context, tenantID string, keyword string) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `DELETE FROM category_mappings WHERE tenant_id = ? AND keyword = ?`, tenantID, keyword)
        return err
}</span>

// FindMapping returns a mapping by tenant and keyword.
func (r *SQLiteCategoryMappingRepository) FindMapping(ctx context.Context, tenantID string, keyword string) (*CategoryMapping, error) <span class="cov8" title="1">{
        row := r.db.QueryRowContext(ctx, `SELECT id, tenant_id, keyword, category_id, priority FROM category_mappings WHERE tenant_id = ? AND keyword = ?`, tenantID, keyword)
        var m CategoryMapping
        if err := row.Scan(&amp;m.ID, &amp;m.TenantID, &amp;m.Keyword, &amp;m.CategoryID, &amp;m.Priority); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;m, nil</span>
}

// ListMappings returns all mappings for a tenant.
func (r *SQLiteCategoryMappingRepository) ListMappings(ctx context.Context, tenantID string) ([]*CategoryMapping, error) <span class="cov8" title="1">{
        rows, err := r.db.QueryContext(ctx, `SELECT id, tenant_id, keyword, category_id, priority FROM category_mappings WHERE tenant_id = ? ORDER BY priority DESC, keyword ASC`, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func()</span><span class="cov8" title="1">{ _ = rows.Close() }</span>()
        <span class="cov8" title="1">var list []*CategoryMapping
        for rows.Next() </span><span class="cov8" title="1">{
                var m CategoryMapping
                if err := rows.Scan(&amp;m.ID, &amp;m.TenantID, &amp;m.Keyword, &amp;m.CategoryID, &amp;m.Priority); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">list = append(list, &amp;m)</span>
        }
        <span class="cov8" title="1">return list, rows.Err()</span>
}


</pre>
		
		<pre class="file" id="file48" style="display: none">// Package repository contains persistence layer implementations.
package repository

import (
        "context"
        "database/sql"
        "encoding/json"
)

// DialogState is a finite state of a user in a dialog.
type DialogState string

const (
        // StateIdle means no active dialog
        StateIdle DialogState = "idle"
        // StateWaitingForEmail when user is entering email
        StateWaitingForEmail DialogState = "waiting_for_email"
        // StateWaitingForPassword when user is entering password
        StateWaitingForPassword DialogState = "waiting_for_password"
        // StateWaitingForRegisterEmail when registering email
        StateWaitingForRegisterEmail DialogState = "waiting_for_register_email"
        // StateWaitingForRegisterPassword when registering password
        StateWaitingForRegisterPassword DialogState = "waiting_for_register_password"
        // StateWaitingForRegisterName when registering name
        StateWaitingForRegisterName DialogState = "waiting_for_register_name"
        // StateConfirmingTransaction when user confirms parsed transaction
        StateConfirmingTransaction DialogState = "confirming_transaction"
        // StateWaitingForCategory when user chooses a category
        StateWaitingForCategory DialogState = "waiting_for_category"
        // OAuth States
        StateWaitingForOAuthEmail DialogState = "waiting_for_oauth_email"
        StateWaitingForOAuthCode DialogState = "waiting_for_oauth_code"
)

// DialogStateRecord is a persisted dialog state.
type DialogStateRecord struct {
        TelegramID int64
        State      DialogState
        DraftID    *string
        Context    map[string]any
}

// DialogStateRepository defines dialog state operations.
type DialogStateRepository interface {
        SetState(ctx context.Context, telegramID int64, state DialogState, context map[string]any, draftID *string) error
        GetState(ctx context.Context, telegramID int64) (*DialogStateRecord, error)
        ClearState(ctx context.Context, telegramID int64) error
}

// SQLiteDialogStateRepository stores dialog state in SQLite.
type SQLiteDialogStateRepository struct {
        db *sql.DB
}

// NewSQLiteDialogStateRepository constructs a repository.
func NewSQLiteDialogStateRepository(db *sql.DB) *SQLiteDialogStateRepository <span class="cov8" title="1">{
        return &amp;SQLiteDialogStateRepository{db: db}
}</span>

// SetState upserts a dialog state.
func (r *SQLiteDialogStateRepository) SetState(ctx context.Context, telegramID int64, state DialogState, ctxMap map[string]any, draftID *string) error <span class="cov8" title="1">{
        var ctxJSON *string
        if ctxMap != nil </span><span class="cov8" title="1">{
                b, _ := json.Marshal(ctxMap)
                s := string(b)
                ctxJSON = &amp;s
        }</span>
        <span class="cov8" title="1">_, err := r.db.ExecContext(ctx, `
                INSERT INTO dialog_states (telegram_id, state, draft_id, context)
                VALUES (?, ?, ?, ?)
                ON CONFLICT(telegram_id) DO UPDATE SET
                        state = excluded.state,
                        draft_id = excluded.draft_id,
                        context = excluded.context,
                        updated_at = CURRENT_TIMESTAMP
        `, telegramID, string(state), draftID, ctxJSON)
        return err</span>
}

// GetState returns a dialog state by telegram id.
func (r *SQLiteDialogStateRepository) GetState(ctx context.Context, telegramID int64) (*DialogStateRecord, error) <span class="cov8" title="1">{
        row := r.db.QueryRowContext(ctx, `SELECT state, draft_id, context FROM dialog_states WHERE telegram_id = ?`, telegramID)
        var state string
        var draftID *string
        var ctxStr *string
        if err := row.Scan(&amp;state, &amp;draftID, &amp;ctxStr); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var ctxMap map[string]any
        if ctxStr != nil &amp;&amp; *ctxStr != "" </span><span class="cov8" title="1">{
                _ = json.Unmarshal([]byte(*ctxStr), &amp;ctxMap)
        }</span>
        <span class="cov8" title="1">return &amp;DialogStateRecord{TelegramID: telegramID, State: DialogState(state), DraftID: draftID, Context: ctxMap}, nil</span>
}

// ClearState deletes a dialog state by telegram id.
func (r *SQLiteDialogStateRepository) ClearState(ctx context.Context, telegramID int64) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `DELETE FROM dialog_states WHERE telegram_id = ?`, telegramID)
        return err
}</span>


</pre>
		
		<pre class="file" id="file49" style="display: none">// Package repository contains persistence layer implementations.
package repository

import (
    "context"
    "database/sql"
    "time"
)

// TransactionDraft is a DB representation of a draft transaction.
type TransactionDraft struct {
    ID          string
    TelegramID  int64
    Type        string
    AmountMinor int64
    Currency    string
    Description string
    CategoryID  string
    OccurredAt  *time.Time
    CreatedAt   time.Time
}

// DraftRepository defines operations for draft transactions.
type DraftRepository interface {
    Create(ctx context.Context, d *TransactionDraft) error
    Get(ctx context.Context, id string) (*TransactionDraft, error)
    Delete(ctx context.Context, id string) error
}

// SQLiteDraftRepository implements DraftRepository over SQLite.
type SQLiteDraftRepository struct { db *sql.DB }

// NewSQLiteDraftRepository constructs a repository.
func NewSQLiteDraftRepository(db *sql.DB) *SQLiteDraftRepository <span class="cov8" title="1">{ return &amp;SQLiteDraftRepository{db: db} }</span>

// Create inserts a new draft row.
func (r *SQLiteDraftRepository) Create(ctx context.Context, d *TransactionDraft) error <span class="cov8" title="1">{
    _, err := r.db.ExecContext(ctx, `INSERT INTO transaction_drafts (id, telegram_id, type, amount_minor, currency, description, category_id, occurred_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`, d.ID, d.TelegramID, d.Type, d.AmountMinor, d.Currency, d.Description, d.CategoryID, d.OccurredAt)
    return err
}</span>

// Get fetches a draft by id.
func (r *SQLiteDraftRepository) Get(ctx context.Context, id string) (*TransactionDraft, error) <span class="cov8" title="1">{
    row := r.db.QueryRowContext(ctx, `SELECT id, telegram_id, type, amount_minor, currency, description, category_id, occurred_at, created_at FROM transaction_drafts WHERE id = ?`, id)
    var d TransactionDraft
    if err := row.Scan(&amp;d.ID, &amp;d.TelegramID, &amp;d.Type, &amp;d.AmountMinor, &amp;d.Currency, &amp;d.Description, &amp;d.CategoryID, &amp;d.OccurredAt, &amp;d.CreatedAt); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">return &amp;d, nil</span>
}

// Delete removes a draft by id.
func (r *SQLiteDraftRepository) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
    _, err := r.db.ExecContext(ctx, `DELETE FROM transaction_drafts WHERE id = ?`, id)
    return err
}</span>


</pre>
		
		<pre class="file" id="file50" style="display: none">// Package repository contains persistence layer implementations.
package repository

import (
        "context"
        "database/sql"
)

// UserPreferences stores per-user settings.
type UserPreferences struct {
        TelegramID      int64
        Language        string
        DefaultCurrency string
}

// PreferencesRepository defines CRUD for user preferences.
type PreferencesRepository interface {
        SavePreferences(ctx context.Context, preferences *UserPreferences) error
        GetPreferences(ctx context.Context, telegramID int64) (*UserPreferences, error)
        UpdateLanguage(ctx context.Context, telegramID int64, language string) error
        UpdateDefaultCurrency(ctx context.Context, telegramID int64, currency string) error
}

// SQLitePreferencesRepository implements PreferencesRepository over SQLite.
type SQLitePreferencesRepository struct {
        db *sql.DB
}

// NewSQLitePreferencesRepository constructs a repository.
func NewSQLitePreferencesRepository(db *sql.DB) *SQLitePreferencesRepository <span class="cov8" title="1">{
        return &amp;SQLitePreferencesRepository{db: db}
}</span>

// SavePreferences upserts user preferences.
func (r *SQLitePreferencesRepository) SavePreferences(ctx context.Context, p *UserPreferences) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `
                INSERT INTO user_preferences (telegram_id, language, default_currency)
                VALUES (?, ?, ?)
                ON CONFLICT(telegram_id) DO UPDATE SET
                        language = excluded.language,
                        default_currency = excluded.default_currency
        `, p.TelegramID, p.Language, p.DefaultCurrency)
        return err
}</span>

// GetPreferences returns preferences for a user.
func (r *SQLitePreferencesRepository) GetPreferences(ctx context.Context, telegramID int64) (*UserPreferences, error) <span class="cov8" title="1">{
        row := r.db.QueryRowContext(ctx, `SELECT telegram_id, language, default_currency FROM user_preferences WHERE telegram_id = ?`, telegramID)
        var p UserPreferences
        if err := row.Scan(&amp;p.TelegramID, &amp;p.Language, &amp;p.DefaultCurrency); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;p, nil</span>
}

// UpdateLanguage sets user's language.
func (r *SQLitePreferencesRepository) UpdateLanguage(ctx context.Context, telegramID int64, language string) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `UPDATE user_preferences SET language = ? WHERE telegram_id = ?`, language, telegramID)
        return err
}</span>

// UpdateDefaultCurrency sets user's default currency.
func (r *SQLitePreferencesRepository) UpdateDefaultCurrency(ctx context.Context, telegramID int64, currency string) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `UPDATE user_preferences SET default_currency = ? WHERE telegram_id = ?`, currency, telegramID)
        return err
}</span>


</pre>
		
		<pre class="file" id="file51" style="display: none">// Package repository contains persistence layer implementations.
package repository

import (
        "context"
        "database/sql"
        "time"
)

// UserSession stores auth tokens and related metadata.
type UserSession struct {
        TelegramID              int64
        UserID                  string
        TenantID                string
        AccessToken             string
        RefreshToken            string
        AccessTokenExpiresAt    time.Time
        RefreshTokenExpiresAt   time.Time
        CreatedAt               time.Time
        UpdatedAt               time.Time
}

// TokenPair holds access/refresh tokens.
type TokenPair struct {
        AccessToken           string
        RefreshToken          string
        AccessTokenExpiresAt  time.Time
        RefreshTokenExpiresAt time.Time
}

// SessionRepository defines session persistence operations.
type SessionRepository interface {
        SaveSession(ctx context.Context, session *UserSession) error
        GetSession(ctx context.Context, telegramID int64) (*UserSession, error)
        DeleteSession(ctx context.Context, telegramID int64) error
        UpdateTokens(ctx context.Context, telegramID int64, tokens *TokenPair) error
        UpdateTenantID(ctx context.Context, telegramID int64, tenantID string) error
}

// SQLiteSessionRepository implements SessionRepository over SQLite.
type SQLiteSessionRepository struct {
        db *sql.DB
}

// NewSQLiteSessionRepository constructs a repository.
func NewSQLiteSessionRepository(db *sql.DB) *SQLiteSessionRepository <span class="cov8" title="1">{
        return &amp;SQLiteSessionRepository{db: db}
}</span>

// SaveSession inserts or updates a user session.
func (r *SQLiteSessionRepository) SaveSession(ctx context.Context, s *UserSession) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `
                INSERT INTO user_sessions (
                        telegram_id, user_id, tenant_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(telegram_id) DO UPDATE SET
                        user_id = excluded.user_id,
                        tenant_id = excluded.tenant_id,
                        access_token = excluded.access_token,
                        refresh_token = excluded.refresh_token,
                        access_token_expires_at = excluded.access_token_expires_at,
                        refresh_token_expires_at = excluded.refresh_token_expires_at,
                        updated_at = CURRENT_TIMESTAMP
        `, s.TelegramID, s.UserID, s.TenantID, s.AccessToken, s.RefreshToken, s.AccessTokenExpiresAt, s.RefreshTokenExpiresAt)
        return err
}</span>

// GetSession returns a session by telegram ID.
func (r *SQLiteSessionRepository) GetSession(ctx context.Context, telegramID int64) (*UserSession, error) <span class="cov8" title="1">{
        row := r.db.QueryRowContext(ctx, `
                SELECT telegram_id, user_id, tenant_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, created_at, updated_at
                FROM user_sessions WHERE telegram_id = ?
        `, telegramID)
        var s UserSession
        if err := row.Scan(&amp;s.TelegramID, &amp;s.UserID, &amp;s.TenantID, &amp;s.AccessToken, &amp;s.RefreshToken, &amp;s.AccessTokenExpiresAt, &amp;s.RefreshTokenExpiresAt, &amp;s.CreatedAt, &amp;s.UpdatedAt); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;s, nil</span>
}

// DeleteSession deletes a session by telegram ID.
func (r *SQLiteSessionRepository) DeleteSession(ctx context.Context, telegramID int64) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `DELETE FROM user_sessions WHERE telegram_id = ?`, telegramID)
        return err
}</span>

// UpdateTokens updates token pair.
func (r *SQLiteSessionRepository) UpdateTokens(ctx context.Context, telegramID int64, t *TokenPair) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `
                UPDATE user_sessions SET
                        access_token = ?,
                        refresh_token = ?,
                        access_token_expires_at = ?,
                        refresh_token_expires_at = ?,
                        updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
        `, t.AccessToken, t.RefreshToken, t.AccessTokenExpiresAt, t.RefreshTokenExpiresAt, telegramID)
        return err
}</span>

// UpdateTenantID updates tenant association.
func (r *SQLiteSessionRepository) UpdateTenantID(ctx context.Context, telegramID int64, tenantID string) error <span class="cov8" title="1">{
        _, err := r.db.ExecContext(ctx, `
                UPDATE user_sessions SET
                        tenant_id = ?,
                        updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
        `, tenantID, telegramID)
        return err
}</span>


</pre>
		
		<pre class="file" id="file52" style="display: none">// Package testutil provides helpers for tests (SQLite DB, Telegram fakes, etc.).
package testutil

import (
    "database/sql"
    "os"
    "path/filepath"
    "testing"

    appdb "budget-bot/internal/pkg/db"
    "go.uber.org/zap"
)

// OpenMigratedSQLite opens a temporary SQLite DB file and runs real migrations from repo root.
// It registers a cleanup to remove the temp file and close the DB.
func OpenMigratedSQLite(t *testing.T) *sql.DB <span class="cov0" title="0">{
    t.Helper()
    tmp, err := os.CreateTemp("", "botdb-*.sqlite")
    if err != nil </span><span class="cov0" title="0">{ t.Fatalf("temp file: %v", err) }</span>
    <span class="cov0" title="0">_ = tmp.Close()

    root := findRepoRoot(t)
    migrations := filepath.Join(root, "migrations")
    dsn := "file:" + tmp.Name() + "?_foreign_keys=on"

    log, _ := zap.NewDevelopment()
    db, err := appdb.OpenAndMigrate(dsn, migrations, log)
    if err != nil </span><span class="cov0" title="0">{ t.Fatalf("open and migrate: %v", err) }</span>
    <span class="cov0" title="0">t.Cleanup(func()</span><span class="cov0" title="0">{ _ = db.Close(); _ = os.Remove(tmp.Name()) }</span>)
    <span class="cov0" title="0">return db</span>
}

// findRepoRoot walks upwards to find a directory containing the migrations folder.
func findRepoRoot(t *testing.T) string <span class="cov0" title="0">{
    t.Helper()
    wd, err := os.Getwd()
    if err != nil </span><span class="cov0" title="0">{ t.Fatalf("getwd: %v", err) }</span>
    <span class="cov0" title="0">dir := wd
    for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
        if _, err := os.Stat(filepath.Join(dir, "migrations")); err == nil </span><span class="cov0" title="0">{
            return dir
        }</span>
        <span class="cov0" title="0">parent := filepath.Dir(dir)
        if parent == dir </span><span class="cov0" title="0">{ break</span> }
        <span class="cov0" title="0">dir = parent</span>
    }
    <span class="cov0" title="0">t.Fatalf("migrations folder not found upwards from %s", wd)
    return ""</span>
}


</pre>
		
		<pre class="file" id="file53" style="display: none">package testutil

import (
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"

    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// NewTestBot spins up a tiny Telegram API emulator and returns a BotAPI wired to it.
func NewTestBot(t testing.TB) *tgbotapi.BotAPI <span class="cov0" title="0">{
    t.Helper()
    ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        p := r.URL.Path
        switch </span>{
        case strings.HasSuffix(p, "/getMe"):<span class="cov0" title="0">
            _, _ = w.Write([]byte(`{"ok":true,"result":{"id":1,"is_bot":true,"first_name":"Test","username":"testbot"}}`))</span>
        case strings.HasSuffix(p, "/sendMessage"):<span class="cov0" title="0">
            _, _ = w.Write([]byte(`{"ok":true,"result":{"message_id":1}}`))</span>
        case strings.HasSuffix(p, "/answerCallbackQuery"):<span class="cov0" title="0">
            _, _ = w.Write([]byte(`{"ok":true,"result":true}`))</span>
        default:<span class="cov0" title="0">
            _, _ = w.Write([]byte(`{"ok":true,"result":true}`))</span>
        }
    }))
    <span class="cov0" title="0">t.Cleanup(ts.Close)
    endpoint := ts.URL + "/bot%s/%s"
    bot, err := tgbotapi.NewBotAPIWithAPIEndpoint("TEST:TOKEN", endpoint)
    if err != nil </span><span class="cov0" title="0">{ t.Fatalf("new bot: %v", err) }</span>
    <span class="cov0" title="0">return bot</span>
}


</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
